# 日本情報オリンピック過去問 難易度5まとめ

Last Change: 2020-09-19 02:08:58.

## [A. アナグラム ★](https://atcoder.jp/contests/joisc2007/tasks/joisc2007_anagra)

与えられた文字列が、考えられる並べ替えの中で何番目かを答える問題。

同じ文字が含まれる場合が難しいような気がしてなかなかコードを書き出せなかったが、
冷静に整理すると、先頭の文字から愚直に考えていけばよい。
各ポイントで残っているアルファベットの数を管理していけば、聞かれている文字列より前に
順序付けられる数は逐次求まっていく。

桁DPの考え方の基本にもなるので、もっと素早く考えられないといけない。

## [A. nile（ナイルドットコム） ★★★](https://atcoder.jp/contests/joisc2008/tasks/joisc2008_nile)

おそらく基本的なのだろうが、初めて経験した個人的に超重要な問題。
単純なナップサックDPだと思ったら計算量が爆発してしまって詰まってしまったので、解答を検索した。

- [ガナリヤさんの解説](https://scrapbox.io/ganariya/JOI2008%E6%98%A5%E5%90%88%E5%AE%BF_P6_%E3%80%8CNile.Com%E3%80%8D_(copy))
- [kimiyukiさんのDPの分類](https://wiki.kimiyuki.net/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95)

**貰うDPは配るDPに比べて「高速化しやすい」場合がある。**

今回の場合、前回と違う店を選ぶ、という選択をする場合には、直前のパターンは最も安い場合で良い、
ということに目をつけると、遷移を大幅に減らすことができる。

配るDPでは↑ができない。
最初、次の店は最も安いものを選ぶ、みたいな遷移を考えたが、
これは、この後の未来の店の決め方を考えると、最適パターンを網羅できておらず、嘘貪欲になっている。

## [C. 連鎖 ★](https://atcoder.jp/contests/joi2009yo/tasks/joi2009yo_c)

色々と難しさにノイズが載っているイメージ（？）

まず `N=10000` で方針に迷うが、TL10secなこともあり、単純な `O(N^2)` で良さそうと思い込むこと。
そして、なんと実際に10msec未満で余裕で間に合う。

実装は、バグらないこと最優先でできる限り愚直に考える。
すなわち、すべての箇所をすべての色に変更した場合のシミュレーションを行えば良い。

Codeforcesのタグで言うところのtwo pointersな実装を行えば良い。
最初の色を変えたときと、両端の処理には注意する。

## [E. 通勤経路 ★](https://atcoder.jp/contests/joi2010yo/tasks/joi2010yo_e)

組み合わせで求められそうだが、条件が複雑なためDPでフラグを付けながら数え上げる問題。

[テクニック集](https://shibh308.hatenablog.com/entry/2019/02/28/195542)にもある通り、
`H, W` が小さくて `H * W` が間に合うのでDPをする。

初期化の部分で混乱して、サンプルを通すのに少し時間がかかってしまった。
定数でフラグのマジックナンバーに名前をつけるのはやはり便利なので、積極的にやりたい。

なんと組み合わせでも求められるらしいが、こっちのほうがだいぶ難しく見える。

## [C. つらら](https://atcoder.jp/contests/joi2010ho/tasks/joi2010ho_c)

よくわからず考えていたらトポロジカルソートして最長経路を求める問題に帰着したので、そのように解いた。

が、他の人の解答を観ると、依存するのはせいぜい両隣だけなので、
両隣の折れるまでの時間がわかれば、それらの大きい方だけ見れば良い、となる。
ここまで考察できれば、もっと他の方法も考えられそうだった。

多分、大きいものを取るのに一番簡単なのはpriority queueなので、それが想定解法。

## [C. stairs](https://atcoder.jp/contests/joisc2010/tasks/joisc2010_stairs)

バグらせそうな問題だったが、一発で比較的スムーズに通せたのは良かった。

配るDPや貰うDPを愚直にやってしまうと `O(N^2)` のDPになってしまう。

そこで、貰うDPの遷移を束ねる高速化を目標に考える。
具体的には、 `dp[i]` に足し合わせる部分を累積和で一発で取れるようにする。

実際には始点からの累積和ではなく、ある区間の区間和が必要になるため、この端点は二分探索で求めた。
よって、自分の解法だと計算量は `O(N * logN)` 。

解答を読んだところ、たしかに尺取法を使えば `O(N)` でできそうだと思った。

## [B. 古本屋 ★](https://atcoder.jp/contests/joi2011ho/tasks/joi2011ho2)

最後の方の考察ほぼゴールに近づけたのに、詰めの部分がわからずググってしまった。

various sushiっぽいが、こちらは種類ごとに独立しているので、本質的に簡単。
あるジャンルについて `t` 冊買うと決めた場合、降順ソートして高いものから累積和をとってそれにボーナスが加わる形になる。

ここから詰まってしまったが、翌々考えたら後はただのナップサックDPをやるだけだった。。

## [A. 横断幕 ★★](https://atcoder.jp/contests/joisc2011/tasks/joisc2011_banner)

`O(W^2 * H)` の解法を閃いたが、TL1.5secに対して0.8secだったので、ちょっと微妙だったのかもしれない。

横の線分について全パターン足し合わせるデータをベースに、zero sum rangesの要領で数え上げた。
つまり、 `0, 1, 2` のビット集合和を考えて、向かい合うセグメント同士のビット和が `(111)` となるようなものを数えた。

模範解答はだいぶ天才に見えて、「異なる3色からならL字のパーツを全部数えて、重複分を考慮して最後に2で割る」というもの。
この方法は、累積和を縦方向と横方向に求めておいて、各点ごとに足し合わせていく必要があるが、ちょっとバグが怖い実装になりそう。

## [C. 国際情報オリンピック ★](https://atcoder.jp/contests/joisc2011/tasks/joisc2011_ioi)

設定が苦手、問題文を読み解くのにそもそも苦労した。

単調性があるので二分探索すれば良い。

おそらくは同じ点数のケースでバグるようなやり方を最初にしてしまったので、1WAしてしまった。

バグらせないことを意識して `O(N * (logN) ^ 2)` を選んだが、 `N <= 1e5` 程度であれば、400msecくらいで済む。

## [C. 夜店](https://atcoder.jp/contests/joi2012ho/tasks/joi2012ho3)

どこかで見たことのあるようなDP。

花火を見る条件が厄介で、その回避方法の模範解答はDPテーブルを2つ使うことだった。
これは自分も考えたがよくわからなかった。

なので、単純に各夜店の処理が終わった後に、適切に累積Maxで更新しておくことで、
その後の遷移を花火をまたがないように注意するだけで済むようにした。

ナップザックDPでは「選ばない」という選択肢を常に意識すること。
今の段階でたまにやらかすので流石にそろそろなくしていきたい。

※逆方向からDPすれば良さそう。

