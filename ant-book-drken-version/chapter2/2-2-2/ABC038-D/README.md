# プレゼント

貪欲法の例題として挙げられているが

## 部分点解法

- 幅をベースにソートして、幅の小さいものから決めていく（ネストする箱の内側から決めていく）という方針で解いた。
- `dp[i][j]: i-1番目まで見たときの一番外側の箱の高さがjの場合の、ネストされる箱の最大数` としてDPを行った。
  - 箱を包むときには一番外側のサイズだけを気にすれば良い、と考えるとDPしたくなる気がする。
  - 普通に高さを使うとGoだと不味そうだと思ったので、高さに関しては座標圧縮を行った。
  - 1つ目の箱を選ぶときや同じ幅の箱に関する扱い周りで、結構遷移でバグってしまった。
    - 部分点解法のコードもひょっとしたら嘘解法なコードになっているかもしれない。。
- 座標圧縮を応用できたのは良かったが、1次元でもかなり手間取ったので、2次元だと地力でやるのはまだ難しいかもしれない。。
  - 焦らず少しずつ覚えていきたい。

## 満点解法

- 部分点解法をよく見ると、そもそもやっていることがLISを求める操作っぽいことに気づいた。
  - ざっくり言ってしまうと、幅でソートした後、高さでLISを考えれば良い。
    - ただし、同じ幅の箱はネストができないので注意が必要。
- 当初、同じ幅の箱については、「小さいもののほうが有利」と考えて、高さが最小の箱のみ考慮する方法をとってしまった。
  - しかしながら、有利になるのは「その箱を採用できた場合」のみ。
  - 同じ幅の箱について複数あるうちの1つしか考えない場合、本来より大きい箱で包含できたかもしれないものを見逃してしまう可能性がある。
    - 仮に、後ろに十分大きな次々とネストできる箱が並んでいる場合、このミスはそのまま損失となってしまう。
- よって、幅が同じものでも、うまく全ての箱を考慮してLISを求める必要がある。
  - [kmjpさんのブログ記事](http://kmjp.hatenablog.jp/entry/2016/05/29/0900)が自分と同じ方針で参考になる。
  - **同じ箱の中では、高さが「降順」となるように** 考えれば良い。
    - このように考えると、LISの計算の際に同じ幅の箱をネストするようなLISの更新がなされないため、うまく求まってくれる。
    - 部分点解法のほうもこの考えを取り入れれば大丈夫（多分）。

## LISについて

この問題はLISについて理解する題材としてとても良いと思う。

- [pekempeyさんの解説記事](https://pekempey.hatenablog.com/entry/2016/05/29/132404)
- [noshi91さんのブログ記事](http://noshi91.hatenablog.com/entry/2018/02/03/204950)
  - LISをBIT（セグ木）で求める方法についての解説。
  - pekempeyさんも、LISをBITなどで求める方法に関して妥当性（？）のようなものを言及している。
