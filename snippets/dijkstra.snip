snippet     dijkstra
abbr        for pq.Len() > 0 {
options     head
  // 蟻本/AOJ
  // 隣接リストで辺を管理
  // node idは0-based

  const MAX_NODE_NUM = 200000 // 最大ノード数
  const INF_30 = 1 << 30 // dpテーブル初期化用

  var v, e int                   // v: 頂点数, e: 辺数
  var G [MAX_NODE_NUM + 5][]Edge // G: 隣接リストによるグラフ
  var dp [MAX_NODE_NUM + 5]int   // dp: 単一始点からの距離

  // sidを始点としてダイクストラ法を実行
  // O(|E| * log|V|)
  func Dijkstra(sid int) {
    // 昇順で取り出せるpriority queue
    temp := make(NodePQ, 0, 200000+5)
    pq := &temp
    heap.Init(pq)

    // 初期化
    for i := 0; i < v; i++ {
      dp[i] = INF_30
    }
    dp[sid] = 0
    heap.Push(pq, &Node{pri: dp[sid], dist: dp[sid], id: sid})

    for pq.Len() > 0 {
      node := heap.Pop(pq).(*Node)
      v := node.id

      // 最短距離でなければ無視する
      if dp[v] < node.dist {
        continue
      }

      for _, e := range G[v] {
        if dp[e.to] > dp[v]+e.cost {
          dp[e.to] = dp[v] + e.cost
          heap.Push(pq, &Node{pri: dp[e.to], dist: dp[e.to], id: e.to})
        }
      }
    }
  }

  type Edge struct {
    to   int
    cost int
  }

  type Node struct {
    pri      int
    dist, id int
  }
  type NodePQ []*Node

  func (pq NodePQ) Len() int           { return len(pq) }
  func (pq NodePQ) Less(i, j int) bool { return pq[i].pri < pq[j].pri } // <: ASC, >: DESC
  func (pq NodePQ) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
  }
  func (pq *NodePQ) Push(x interface{}) {
    item := x.(*Node)
    *pq = append(*pq, item)
  }
  func (pq *NodePQ) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
  }

  // how to use
  // temp := make(NodePQ, 0, 100000+1)
  // pq := &temp
  // heap.Init(pq)
  // heap.Push(pq, &Node{pri: intValue})
  // popped := heap.Pop(pq).(*Node)

snippet     dijkstraRasenVer
abbr        func dijkstra() []int
options     head
  const (
    MAX   = 200000 + 5
    INFTY = 1 << 30
    WHITE = 0
    GRAY  = 1
    BLACK = 2
  )

  var n int
  var adj [MAX][]Edge // 重み付き有向グラフの隣接リスト表現

  // O( (|V| + |E|) * log(|V|) )
  // 各ノードの最短路の長さを返す
  func dijkstra() []int {
    temp := make(NodePQ, 0)
    pq := &temp
    heap.Init(pq)
    color, d := make([]int, MAX), make([]int, MAX)
    for i := 0; i < n; i++ {
      d[i] = INFTY
      color[i] = WHITE
    }

    d[0] = 0
    heap.Push(pq, &Node{pri: 0, id: 0})
    color[0] = GRAY // この段階ではまだ最短経路木Sには含めない

    for pq.Len() > 0 {
      f := heap.Pop(pq).(*Node)
      u := f.id
      color[u] = BLACK // pqから取り出された段階でSに加えられる

      // 最小値を取り出し、それが最短でなければ無視（等号をつけてはいけない）
      if d[u] < f.pri {
        continue
      }

      for j := 0; j < len(adj[u]); j++ {
        v := adj[u][j].to
        // 余計なPushを防いでいる
        if color[v] == BLACK {
          continue
        }
        if d[v] > d[u]+adj[u][j].cost {
          d[v] = d[u] + adj[u][j].cost
          heap.Push(pq, &Node{pri: d[v], id: v})
          color[v] = GRAY
        }
      }
    }

    return d
  }

  type Edge struct {
    to, cost int
  }

  type Node struct {
    pri int
    id  int
  }
  type NodePQ []*Node

  func (pq NodePQ) Len() int           { return len(pq) }
  func (pq NodePQ) Less(i, j int) bool { return pq[i].pri < pq[j].pri } // <: ASC, >: DESC
  func (pq NodePQ) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
  }
  func (pq *NodePQ) Push(x interface{}) {
    item := x.(*Node)
    *pq = append(*pq, item)
  }
  func (pq *NodePQ) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
  }

  // how to use
  // temp := make(NodePQ, 0, 100000+1)
  // pq := &temp
  // heap.Init(pq)
  // heap.Push(pq, &Node{pri: intValue})
  // popped := heap.Pop(pq).(*Node)

snippet     dijkstraSquareOrderVer
abbr        func dijkstra() []int
options     head
  const (
    MAX   = 500 + 5
    INFTY = 1 << 30
    WHITE = 0
    GRAY  = 1
    BLACK = 2
  )

  var n int
  var M [MAX][MAX]int

  // O(|V|^2)
  // 各ノードの最短路の長さを返す
  func dijkstra() []int {
    var minv int
    d, color := make([]int, MAX), make([]int, MAX)

    for i := 0; i < n; i++ {
      d[i] = INFTY
      color[i] = WHITE
    }

    d[0] = 0
    color[0] = GRAY
    for {
      minv = INFTY
      u := -1
      for i := 0; i < n; i++ {
        if minv > d[i] && color[i] != BLACK {
          u = i
          minv = d[i]
        }
      }
      if u == -1 {
        break
      }

      color[u] = BLACK

      for v := 0; v < n; v++ {
        if color[v] != BLACK && M[u][v] != INFTY {
          if d[v] > d[u]+M[u][v] {
            d[v] = d[u] + M[u][v]
            color[v] = GRAY
          }
        }
      }
    }

    return d
  }

snippet     dijkstraHowTo
abbr        how to implement dijkstra
options     head
  // 1. グラフ |G| を隣接リストで作る
  //   - エッジ構造体 |Edge| には遷移先のノードID |to| と重み |w| が定義されていれば良い。
  // 2. ノード構造体 |Vertex| とそのpriority queueを定義する
  //   - ノード構造体 |Vertex| にはノードID |id| と必要な **コスト** を定義する必要がある。
  //   - priority queueは、コストに関して昇順となるように適当に |Less| を定義する必要がある。
  //     - ここは問題によってまちまちなので注意！
  //     - とはいえ大抵は |int| だと思われる。
  // 3. ノードの個数分だけ配列でコスト、色、親それぞれ |dp, colors, parents| を定義し初期化する。
  //   - |dp| の型はノード構造体におけるコストの型と一致。
  //   - |dp| の初期値はいわゆる無限大に当たる値。
  //   - |colors| の初期値はすべて |WHITE| 。
  //   - |parents| に関しては
  //     - アルゴリズム上は初期値は不要だが、デバッグ等の都合を考えると |-1| などがよさそう。
  // 4. キューに始点のノードのみ追加する。
  //   - 追加するノードのコストは |0| とする。
  //   - 始点の状態を変更する |dp[s] = 0, colors[s] = GRAY, parents[s] = -1| 。
  //     - 始点の親は当然なし。
  // 5. 以下をキューが空になるまで繰り返す。
  //   1. キューからノード構造体を取り出す。
  //   2. 取り出したノードを |BLACK| に変更する。
  //     - 冪等性があるので特に条件分岐は考えなくてよい。
  //   3. ノードのコストが |dp[cid]| **より大きい** 場合は無視してループを |continue| する（手順1へ）
  //     - 計算量削減のため。
  //       - **等号を含めて「以上」としては行けないことには注意！等号を入れると一切更新がなされなくなってしまう。**
  //     - 5.2の更新前にBLACKかどうかを判定するのも良さそう。
  //   4. ノード構造体から伸びるすべてのエッジについて調べる。
  //   5. 移動先がすでに |BLACK| の場合は確定しているので |continue| して次のエッジを調べる。
  //     - 計算量削減のため。
  //   6. そうでない場合かつ、移動先のコスト |dp[nid]| が |dp[cid] + {{エッジのコスト}}| よりも大きい場合、小さい方で更新する。
  //   7. 更新したコストでキューに移動先のノード構造体を追加。
  //   8. 移動先の色を |GRAY| に変更し、親を更新する |colors[nid] = GRAY, parents[nid] = cid|
  //     - 色に関しては冪等性があるので特に条件分岐は考えなくて良い。
