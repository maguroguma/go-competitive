# ABC098過去問感想

- A問題はちゃんとMax関数を使って省エネしよう。
- B問題はBにしては少し実装が面倒な部類。
  - `ans` の初期値を雑に設定してしまったためにコーナーケースで1つWAしてしまったので、初期値設定は低難度の問題でも慎重に。
- C問題は累積和なのはパット見でわかるのに、実装に時間がかかりすぎてしまった。
  - 変にメモリ節約をしようとして最初に時間を無駄にしてしまったので、ときはじめは割と贅沢なコードを書いても良い。
    - まずそうだったら最後にリファクタリングすればよい、ベースのコードがあれば雑になら簡単に治せる。
- D問題はXORなので頑張りたかったが、ギブアップ。
  - しゃくとり法なる手法の問題らしい。

---

## D問題（2019/3/20）

しゃくとり法の特訓中だったので取り組んだ。

しゃくとり法の実装としてはかなり素直なもので、XORの面白い性質と併せて学べる。

### XOR和と加算和の関係 `XOR和 <= 加算和`

理由は単純明快で、 **加算和には繰り上がりが存在するから。**

2項について考えたときに、両方の n bit 目だけを考えたとき、
`(0, 0), (0, 1), (1, 0)` のときは、加算とXORで両方とも同じになる。

しかし、 `(1, 1)` のときだけは、n bit 目に関してはXORと同じであるものの、
次の位へ繰り上がりが発生する。

この繰り上がりは、ビットを無限に連ねられるとすると（整数の格納領域を無限にとれるとすると）、
宙に消えるものではなく、必ず n+1 bit 目に渡るものである（当たり前だが）。

なので、必ず加算和のほうが大きくなる事が自然とわかる。

この問題のように、等号が成り立つ、すなわち `a ^ b == a + b` が成り立つのは、
すべてのビット同士の加算で繰り上がりが起こらない（ `(1, 1)` のビットが存在しない）ケースである。

（ここまで分析できると、しゃくとり法が適用できるのも頷ける。）

#### `(a+b) - (a^b) == 2 * (a & b)`

XOR和と加算和の関係。

繰り上がりに注目すると、式の意味が理解できる。

いろんな解釈につなげて応用ができそう。
