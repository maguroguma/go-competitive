snippet     pascalTriangle
abbr        C[n][r]
options     head
  var Comb [5001][5001]int
  func InitPascalTriangle(m int) {
    for i := 0; i <= 5000; i++ {
      for j := 0; j <= i; j++ {
        if j == 0 || j == i {
          Comb[i][j] = 1
        } else {
          Comb[i][j] = Comb[i-1][j-1] + Comb[i-1][j]
          Comb[i][j] %= m
        }
      }
    }
  }

snippet     combinationFactorial
abbr        cf.C(n, r)
options     head
  // cf := NewCombFactorial(500000) // maxNum == "maximum n" * 2 (for H(n,r))
  // res := cf.C(n, r) 	// 組み合わせ
  // res := cf.H(n, r) 	// 重複組合せ
  // res := cf.P(n, r) 	// 順列

  type CombFactorial struct {
    factorial, invFactorial []int
    maxNum                  int
  }

  func NewCombFactorial(maxNum int) *CombFactorial {
    cf := new(CombFactorial)
    cf.maxNum = maxNum
    cf.factorial = make([]int, maxNum+50)
    cf.invFactorial = make([]int, maxNum+50)
    cf.initCF()

    return cf
  }
  func (c *CombFactorial) modInv(a int) int {
    return c.modpow(a, MOD-2)
  }
  func (c *CombFactorial) modpow(a, e int) int {
    if e == 0 {
      return 1
    }

    if e%2 == 0 {
      halfE := e / 2
      half := c.modpow(a, halfE)
      return half * half % MOD
    }

    return a * c.modpow(a, e-1) % MOD
  }
  func (c *CombFactorial) initCF() {
    for i := 0; i <= c.maxNum; i++ {
      if i == 0 {
        c.factorial[i] = 1
        c.invFactorial[i] = c.modInv(c.factorial[i])
        continue
      }

      num := i * c.factorial[i-1]
      num %= MOD
      c.factorial[i] = num
      c.invFactorial[i] = c.modInv(c.factorial[i])
    }
  }
  func (c *CombFactorial) C(n, r int) int {
    res := 1
    res *= c.factorial[n]
    res %= MOD
    res *= c.invFactorial[r]
    res %= MOD
    res *= c.invFactorial[n-r]
    res %= MOD

    return res
  }
  func (c *CombFactorial) P(n, r int) int {
    res := 1
    res *= c.factorial[n]
    res %= MOD
    res *= c.invFactorial[n-r]
    res %= MOD

    return res
  }
  func (c *CombFactorial) H(n, r int) int {
    return c.C(n-1+r, r)
  }


snippet     combinationFactorialTrial
abbr        func (cf *CombFactorial) C(n, r int64) int64
options     head
  // cf := NewCombFactorial(500000) // maxNum == "maximum n" * 2 (for H(n,r))
  // res := cf.C(n, r) 	// 組み合わせ
  // res := cf.H(n, r) 	// 重複組合せ
  // res := cf.P(n, r) 	// 順列

  type CombFactorial struct {
    factorial, invFactorial []int64
    maxNum                  int64
  }

  func NewCombFactorial(maxNum int64) *CombFactorial {
    cf := new(CombFactorial)
    cf.maxNum = maxNum
    cf.factorial = make([]int64, maxNum+50)
    cf.invFactorial = make([]int64, maxNum+50)
    cf.initCF()

    return cf
  }
  func (c *CombFactorial) modInv(a int64) int64 {
    return c.modpow(a, MOD-2)
  }
  func (c *CombFactorial) modpow(a, e int64) int64 {
    if e == 0 {
      return 1
    }

    if e%2 == 0 {
      halfE := e / 2
      half := c.modpow(a, halfE)
      return half * half % MOD
    }

    return a * c.modpow(a, e-1) % MOD
  }
  func (c *CombFactorial) initCF() {
    var i int64

    for i = 0; i <= c.maxNum; i++ {
      if i == 0 {
        c.factorial[i] = 1
        c.invFactorial[i] = c.modInv(c.factorial[i])
        continue
      }

      num := i * c.factorial[i-1]
      num %= MOD
      c.factorial[i] = num
      c.invFactorial[i] = c.modInv(c.factorial[i])
    }
  }
  func (c *CombFactorial) C(n, r int64) int64 {
    var res int64

    res = 1
    res *= c.factorial[n]
    res %= MOD
    res *= c.invFactorial[r]
    res %= MOD
    res *= c.invFactorial[n-r]
    res %= MOD

    return res
  }
  func (c *CombFactorial) P(n, r int64) int64 {
    var res int64

    res = 1
    res *= c.factorial[n]
    res %= MOD
    res *= c.invFactorial[n-r]
    res %= MOD

    return res
  }
  func (c *CombFactorial) H(n, r int64) int64 {
    return c.C(n-1+r, r)
  }
