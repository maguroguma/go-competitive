# AtCoderのupsolveした問題たち

Last Change: 2020-11-02 00:10:57.

「コンテストに出て解けなかった問題の復習」というのはひときわ学習効果が高いと思うので、
@2020-11-01からではあるが、このディレクトリ内にまとめていく。

---

## [ARC104 C.Fair Elevator](https://atcoder.jp/contests/arc104/tasks/arc104_c)

※解法の概要は理解したが、実装が非常に大変そうなので、upsolveはあとに回している。

## [ABC179 F.Simplified Reversi](https://atcoder.jp/contests/abc179/tasks/abc179_f)

一応自力で解き直した。  
純粋に区間更新だけが可能な遅延セグ木を2本作ることでシミュレーションを効率化した感じ。  
こういった遅延セグ木の代わりになるもっと簡易なデータ構造ってないものだろうか。。

解説放送では、「点chmin更新、区間min取得」のセグ木でできることを説明している。

※「区間更新・点取得」→「点更新・区間取得」の変換は重要な気もするけど、
脳死で遅延セグ木使えるほうがコンテスト的には大事だと思うので、一旦は忘れておく。。

## [ABC181 F.Silver Woods](https://atcoder.jp/contests/abc181/tasks/abc181_f)

最小包含円の問題を思い出すような、易しめの幾何の問題。

半径を決め打って判定する問題を二分探索するのはわかるが、具体的な方法は回答PDFを見た。  
全ての点と点の間の距離を計算し、この距離が `2*r >= dist` ならば通れることがわかる。  
同様なことは点と直線に関しても言える。  

ここで、点と直線を頂点とみなして `n+2` 個の頂点からなるグラフを考える。  
また `2*r < dist` を満たす点と点、および点と直線、直線と直線の間にエッジを張る。  
最終的に、「直線ノードと直線ノードが連結ならば通り抜けられない」というふうに言い換えることができる。  
回答PDFには「右手法をイメージすれば良い」とあるが、まさに「エッジがはられている間は通り抜けられない」ことからも、
直線と直線が連結でなければ、なんらかの抜け道がある、と判定できる。

とても賢く、きれいな問題。

