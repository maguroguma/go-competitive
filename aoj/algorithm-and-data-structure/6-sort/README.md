# ソート

## 計数ソート

- 1オリジンの余分な記憶領域が必要
  - 1オリジンなのは累積和を使うからだと思われる
- 大雑把な説明だと、ソートしたい配列中の要素の数をカウントし累積和をすることで、後ろの要素から位置が順に確定できる
- 後ろから選んでいくことで安定ソートになる
- 各要素が0以上でないとだめなのと、 `A[i]` の最大値のサイズに比例する時間と記憶領域が必要となる。
  - そのかわり `O(n+k)` と高速

※初めて気づいたが、要素数が2000000ぐらいあるときに、雑にスライスの要素数を確保すると、
拡張時にそれに比例したものを余計に取ってしまうことがある関係上、MLEする可能性があるので注意したほうが良い
（レアケースだとは思うが）。

## パーティション

クイックソートの前段階

左側をピボットの値以下に、右側をピボットより大きい値のみで構成されるようにする。

右端をピボットとした場合、 `0~r-1` まで `j` を動かして、交換が必要かすべてチェックする。
小さい側のインデックスを管理する `i` の動かし方に注意が必要。

最後に忘れずにピボットも入れ替えるようにする。

## クイックソート

> クイックソートは次のような分割統治法に基づくアルゴリズムです。

- 配列全体を対象として `quickSort` を実行する。
- `quickSort` は次の通り。
  1. `partition` により、対象の部分配列を前後2つの部分配列へ分割する（Divide）
  2. 前方の部分配列に対して `quickSort` を行う（Solve）
  3. 後方の部分配列に対して `quickSort` を行う（Solve）

> クイックソートはマージソート同様に分割統治法に基づくアルゴリズムですが、
> 分割してパーティションを行ったときに既にもとの配列内でソートが完了するので、
> （マージソートのように）統治にあたる明示的な処理がありません。

> クイックソートは、 `partition` の内部で離れた要素を交換するので、 **安定なソートアルゴリズムではありません** 。
> 一方で、マージソートが `O(n)` の外部メモリを必要としたのに対し、
> クイックソートは追加のメモリ領域を必要としない、いわゆる **インプレースソート（内部ソート）**
> であるという特長があります。

- ソートアルゴリズムの中で最も高速
- ただし、データの並びが悪いと `O(N^2)` になる可能性がある。
  - ピボットの選び方で回避可能。

※動きがちょっとむずかしいが、葉の結果を根方向に戻して完成、というのではなく、上の方で `partition` してから分割していき、最終的に葉をすべて横に並べるとソートが済んでいる、というイメージ。

※標準ライブラリのいわゆる `Stable` はマージソートがベースになっているのは、初めて認識した。
（ずっとクイックソートは安定だと勘違いしていた。）

## 最小コストソート

実装も考察も結構むずかしい。

未ソートのもとの配列とソート済み配列の要素間で比較したとき、
注目している値に関して本来あるべき位置をたどっていくとループが発生する、
という観察は他の問題でも重要になりそう。

