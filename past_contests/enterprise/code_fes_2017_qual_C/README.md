## CODE FESTIVA 2017 qual C

- C問題は簡単に脳内で考察したものを実装すればいけると思ったが、悪手だった。
  - 嘘解法なのか実装ミスなのかもわからず。
  - **典型: 回文は先頭文字と末尾文字に注目する。**
    - 同年の qual A のC問題も先頭・末尾に注目して解法を導いたことを思い出す。
    - 難しいことを考えずに、まずはこの回文典型解法をよく覚えて次回に繋げられるようにすること。
  - 実際に文字列の切り詰めをシミュレートすると計算量が大きすぎるので、インデックスを左と右で保持して処理する。
    - この部分も勉強になる。

---

## C問題の誤った考察

ひょっとしたら正しいのかもしれないが、嘘の可能性が高い。
仮に正しくても、正しく実装するのが困難であるため、忘れる。

まずは、回文問題の典型解法を身に着けよう。

> アルファベットの偶奇性に着目したい。
> 挿入する x は任意個数、最初から存在してもいい。
> あとは1つの文字を除いて偶数個存在しないといけない。軸となる1文字がある場合は、その1文字に関しては奇数個でもよい。
> 最終形を考えたい。
> xを除いたときに回文になっていることが条件な気がする（証明なしで一回答えを書いてみても良さそう）
> 回文判定はruneスライスで愚直につなげて、反転させたやつも同じように作って、stringキャストして一致するかを確かめれば良さそう。
>
> 回文の構築はどうすればよいか？
> とりあえず、前半の工程で軸となる位置が決まる。
> 前半と後半を分けてしまって、それらが一致するような x の挿入手順を考える。
> （ほしいのは挿入回数だけであることに注意。）
> ↑なので、前半、後半パートの x の個数を揃えることさえわかれば良いので、それぞれのパートの x の個数さえ数えてしまえば答えを導けてしまえる気がする。
> ↑だけでは流石に駄目（サンプル1）、ちょっと考えないといけない。
>
> 左パート＝右パートの反転
> となるようにすればよい
> xa -> ax なので、xの挿入によってこれらが一致するようにしたい。
> xa.
> .ax
> のように、既存のx以外の文字で揃えて挿入箇所を数えられないか？