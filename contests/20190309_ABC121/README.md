# ABC121感想

D問題解けず。
すごく難しいと感じたが、800人ぐらい通していて恐ろしいことになっていた。

- A問題は簡単な図を描いて愚直な実装を行った。
  - 解答見た感じ、五十歩百歩な気がしたのであまり気にしない。
- B問題は文書のsimilarityの計算の雰囲気を感じた（コサイン類似度的ななにか）
- C問題は簡単な貪欲法。
  - 構造体のソートが必要になるので、いい加減ここらへんのGoのコードをもっと速く書けるようにしたい。
- 問題のD問題。
  - 実験して規則性を見つける、というのが、知識がなかった場合に求められる問題だった。
    - 紙で実験はしたが、効率が悪いのでなんとかしたい。
      - **とりあえず、2進数のコンソール表示をパッとできるように、デバッグ用の関数をこさえておく。**
  - 自分が一番今回学びだと感じたことは、 **剰余をとる値を小さくすると、調べる対象が大幅に少なくなる** ということ。
    - あまりにも自明、いままで自然とやってきたことでもあるはず。
    - しかしながら、コンテスト中「i桁目の各ビットに関しては `2^i` の周期があるけど、AやBが大きいときは使えないなぁ」などと考えてしまった。
    - あまり賢く一般化しようとせず、紙の上で実験した結果を見て、もっと小規模な範囲でパターンを見つけるべきだった。
      - 今回は1と0がきれいに並んでいるのだから、別に周期2でもコードは書けたはず。
    - 今後は剰余を取るにしても **小さい値でとっているのだからうまくいく** ということを思い出しながら問題に取り組みたい。
  - これも当たり前だが、 **XORだけに演算が閉じているのであれば、各ビットの偶奇性だけがわかれば十分。**
    - この間のXXORなどは足し算が挟まっているため、偶奇性だけでは不十分だったので、このときの記憶に引っ張られすぎた気がする。
  - 周期性が見つけられればビットごとに逐一考えても大丈夫だが、実装は結構めんどくさい。
  - 賢いのは **対象が絞れた後は直接XOR演算してしまう** というもの。
    - どうやって進めるかは下記のXORの性質を用いる（特に単位元が重要）。
    - XOR問題はビットごとに考えるのがしばしば妥当であるので、こういった問題はなかなか難しく感じる。

---

## 実験について

紙で実験するのもいいが、2進数などはコンピュータが扱うほうが正確でコードも簡単に書けるはずなので、
なるべくコンテスト中にコードを書くようにしたい。

たとえば、今回のような `f(a, b)` については以下のようなコードで簡単に観察できる。

```go
current := 0
for i := 0; i < 11; i++ {
  current ^= i
  fmt.Println(current)
}
```

ゼロ埋めする2進数のデバッグ用関数なども作ったので、困ったら積極的に活用していきたい。

---

## writerのdrafearさんのコンテスト後のツイート

XORの基礎セット。

> 排他的論理和については
>
> ・交換法則
> x XOR y = y XOR x
>
> 結合法則
> x XOR (y XOR z) = (x XOR y) XOR z
>
> 単位元
> x XOR x = 0
>
> なのと "ビットごと" なのでビットごとに独立に求められることが多かったり、上位/下位ビットから調べていく問題が頻出です
>
> 2n XOR (2n+1) = 1 は普通知らなくていいです。

ビットごとに観ることができればどれも自明。

## 竹雄さんの一連のツイート

XORの逆演算がXOR自身ということを説明したツイート一連。
丁寧で非常にわかりやすい。

（上記のdrafearさんの内容が自明に感じられるのであれば、特に読まなくても良い）

> たとえば和(+)の逆演算は差(-)で、これは
> A=A+x-x=A-x+x
> みたいな性質（ある演算をしたあとに、その逆演算をすると打ち消せる）があることを意味しているんですが、
>
> xor の逆演算が xor 自身というのは
> A=A xor x xor x
> みたいな性質（ある整数に整数xをxor演算した後に、もう一度同じ整数をxor演算すると打ち消せる）
> があるということです（説明が下手）
>
> （中略）
>
> それでは
> 「3から5までの整数をすべてxor演算したもの」
> を求めてみます。
>
> 0から2までの総xorは
> 0 xor 1 xor 2
> で
> 0から5までの総xorは
> 0 xor 1 xor 2 xor 3 xor 4 xor 5
> です。
>
> ここから
> (0から2まで) xor (0から5まで)
> は
> (0 xor 1 xor 2) xor (0 xor 1 xor 2 xor 3 xor 4 xor 5)
> = (0 xor 0) xor (1 xor 1) xor (2 xor 2) xor (3 xor 4 xor 5)
> となるので、同じ整数どうしをxorしている部分がxorの性質よりすべて消えて
> = 3 xor 4 xor 5
> となります。
>
> これは(3から5までの総xor)になっています。
> xor演算は可換性があるので順番を入れ替えられることに注意してください。

## 学習用記事

なにか困ったことがあれば思い出して振り返りたい

[ぽーぽーさんのブログ記事](http://purple-jwl.hatenablog.com/entry/20121008/1349694710)
どうやら既出の問題で、ググり方がうまいひとは見つけられたのかもしれない。

[けんちょんさんのブログ記事](http://drken1215.hatenablog.com/entry/2019/03/09/224100)
XORの逆演算について丁寧に説明されている。