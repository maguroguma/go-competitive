# 平方分割の基礎練習

[しょラーさんのブログ記事](https://kujira16.hateblo.jp/entry/2016/12/15/000000)にて、
基本練習を行う。

## はじめに

> 上手に実装したセグメント木と比べても3~5倍遅くなる程度で収まることが多いです。

とりあえずAOJでチェックしてみたところ、クエリ・データ数ともに `100000` 程度ならば全く問題なさそう。

## Range Sum Query

> 平方分割を書くときには **「どのような補助データが必要か」「クエリに対する処理はどのようにすればよいか」** を考える必要があります。

以下の3つの条件をベースに考える。

1. 変更クエリは `O(sqrt(N))` か？
2. 変更クエリのあとで、1つのバケット全体に対する質問クエリに `O(1)` で答えられるか？
3. 変更クエリのあとで、バケットの中に対する質問クエリに `O(sqrt(N))` で答えられるか？

> これらの条件を満たす処理が実現できれば、バケットの個数は `sqrt(N)` 個なので、
> どのような質問クエリに対しても `O(1) * sqrt(N) + O(sqrt(N)) * 2` で全体として `O(sqrt(N))` です。

※最悪なクエリでも、バケット単位に見えるのは `sqrt(N)` 個だけだし、具体的にバケットの中を走査することになるのも `2 * sqrt(N)` 個未満になる、ということ。

ここでは、補助データ構造として、バケット和をもたせれば良い。

## Range Minimum Query

ここでは、補助データとして、バケット最小値をもたせれば良い。

## Range Add Query

ここでは、補助データとして、バケット増加分（バケット全体に一様に加えられた値の和）をもたせれば良い。

点クエリの際は、実際のデータ値に対して、所属するバケットにおけるバケット増加分を加算したものを返してやれば良い。

## Range Update Query

> 今回の「区間の値をまとめて変更する」という操作のように、
> 操作の種類によっては「遅延伝搬」や「遅延評価」「遅延更新」「遅延セグメント木」などとよばれる
> テクニックが必要になることがあります。
> もう少し詳しく言うと、
> **「操作の順番を入れ替えると結果が変わってしまう操作」では遅延伝搬テクが必要** です。

今回の場合は、遅延評価は「質問クエリ」と「バケットの中に対する変更クエリ」の直前に、
対応するバケットについてのみ同期を取れば、条件を満たせる。

## RSQ and RAQ

遅延伝搬を使わない方針で解いてみる。

区間に対する操作と区間に対する質問クエリを考える場合は、以下の4つに気をつける。

1. バケットの中に対する変更クエリは `O(sqrt(N))` か？
2. バケットの中に対する質問クエリに `O(sqrt(N))` で答えられるか？
3. 1つのバケット全体に対する変更クエリは `O(1)` か？
4. 1つのバケット全体に対する質問クエリに `O(1)` で答えられるか？

## RMQ and RUQ

遅延伝搬テクを使う。



