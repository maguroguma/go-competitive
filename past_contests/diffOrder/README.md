# difficulty順に埋める

Last Change: 2020-07-12 10:16:07.

@2020-06-29より、埋めていないところから順に埋めていく。
おそらくは復習が必要な問題が並ぶはずなので、最初から集めておく。

## [ABC161-F ★](https://atcoder.jp/contests/abc161/tasks/abc161_f) @2020-06-29

こどふぉならmath, number theoryタグがついてdiff 1600ぐらいになりそうな問題。
でもわからずに解説AC。

剰余の推移に目をつけたのは良かったが、逆から考えようとした時点で間違いだった。

ていうか誤読してた、死にたい。

## [ABC030-D](https://atcoder.jp/contests/abc030/tasks/abc030_d) @2020-06-30

[ABC167-D](https://atcoder.jp/contests/abc167/tasks/abc167_d)とほぼ同じな気がする。

バカでかい `k` の対処は桁DPなどでよくある剰余の扱いをすればよいが、違いはそこだけだと思う。

これもダブリングをするとライブラリ貼るだけとかにできるのかもしれないが、
ライブラリチェックはよりシンプルな問題の方だけで試せば良い気がする。

## [AGC044-A ★](https://atcoder.jp/contests/agc044/tasks/agc044_a) @2020-06-30

難しい。答えを効いても計算量見積もりが非常に難しい。
すぬけさんの解説放送でのざっくりとした見積もりが一番わかり易い気がする。

とりあえずは「ハッシュマップを使ったメモ化再帰」というのがこの問題で一番手にしておきたい経験値だと思う。

## [ABC025-C ★★](https://atcoder.jp/contests/abc025/tasks/abc025_c) @2020-07-01

答えを見たが面白かった。ゲーム木の基本問題として覚えておきたい。

ゲーム木の考え方（再帰部分）もそうだが、
「ゲームにおいて最大化と最小化を考える2プレイヤーがいるとき、総和が一定であることに注目すると見通しが良くなる」
という部分は応用の幅が広そうであるため、ぜひ覚えておきたい。

## [ABC013-D](https://atcoder.jp/contests/abc013/tasks/abc013_4) @2020-07-01

自力。ダブリングの練習ができた。

ダブリングのコードは[けんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2020/06/20/190700)
がわかりやすかったので、変数名なども含めて写経した感じになった。

## [ARC023-C](https://atcoder.jp/contests/arc023/tasks/arc023_3) @2020-07-02

自力。

逆元が一般的でなかった時代の過去のもの。
注意点としては、制約が最近では見ない感じで、もろもろを前計算する自前の組み合わせライブラリではうまく行かず、
コンビネーションを愚直に計算しないと駄目なタイプだった。

## [ABC011-D ★](https://atcoder.jp/contests/abc011/tasks/abc011_4) @2020-07-02

解説AC。

場合の数なら簡単だが、確率を求めろとなると場合の数を考えると失敗してしまう。

パスカルの三角形を応用すると、 `C(n, r), r = 0, 1, .., n` までのすべての組み合わせの確率が直接求まる。
この事実をうまく利用すると、所望の確率が計算できる。

ポイントは、一度場合の数の考え方をリセットして忘れて、 `C(n, r)` に閉じた積事象の確率で考えること。

`O(N^2)` で任意の確率が求まる可能性があることについては覚えておきたい（これから出題される可能性は低そうだが）。

## [ABC023-D](https://atcoder.jp/contests/abc023/tasks/abc023_d) @2020-07-03

自力。

最大値の最小化といえば二分探索がまっさきに思いつくので、そこを狙って考えれば簡単だと思う。

判定関数の中でソート処理が含まれるので計算量にはlogが2つつくことになるが、
制限時間が5秒なので大抵の言語で余裕だと思う。
Goだと1100msecぐらいだった。

## [ABC014-D](https://atcoder.jp/contests/abc014/tasks/abc014_4) @2020-07-04

自力。

木のLCAを求めて、与えられたノード2つの根からの深さとLCAの根からの深さを用いて計算してやる。
LCAの利用問題としては最易の部類だと思う（ので、verify用問題として良さそう）。

※LCAはフルスクラッチで書ける必要はないが、アルゴリズムの動作原理や内部で保持しているデータ構造（ `depth` ）については理解しておくべきだと思う。

## [ABC162-F ★★](https://atcoder.jp/contests/abc162/tasks/abc162_f) @2020-07-04

解説放送AC。

解説PDFだけだと理解がきつい。
解説放送ではDPの組み方まで教えてくれたのでわかりやすかった。

制約が厳しいことから状況を整理して、最終的にやるべきDPを見出したい。

## [ABC171-F ★★](https://atcoder.jp/contests/abc171/tasks/abc171_f) @2020-07-05

解説放送AC。

これもPDFだけだと理解がきつい。

独立？な数え上げをうまくやる方法として「最終的なものが部分列として含まなければ行けない」という点から出発している（多分）。
発想がとても賢い。。

最終的には、組み合わせライブラリを用いるシンプルな数え上げになる。

- 操作手順を考えると重複が出てきてわけがわからない。
- **挿入後に出来上がる文字列が「どういう性質を持つか？」から考える。**
- ある文字列が部分列を含むか？の判定はシンプルに前からみる貪欲法で良い。

## [ABC154-F ★★](https://atcoder.jp/contests/abc154/tasks/abc154_f) @2020-07-05

解説（放送）AC。

まず、2次元累積和的な発想が求められる。
これにより、原点中心の「量」が高速に求められればOKというシンプルな問題になる。

※実際に小さい範囲でマス目を書いて、通り数を埋める実験をやるべき！

※すぬけさんの解説放送の方法はパスカルの三角形の理解が深まるので、これはこれで面白い。
（というより「組み合わせ」という量の性質が色々見つかって面白い。）

**※今までパスカルの三角形は「貰うDP」っぽく考えていたが、すぬけさんの解説のように「配るDP」の視点も持てると、色々と応用幅が出そうな気がした。**

## [ABC165-F](https://atcoder.jp/contests/abc165/tasks/abc165_f) @2020-07-05

久しぶりに自力で解けるABC-Fが出てきた。

「DPの巻き戻し」と呼ばれるテクニックを使うらしい（復元とは全くの別物っぽい？）。

何やらstackを使うと良いらしいとあるが、自分はLISのデータ構造をスライスのスライスとして持って、
最後尾の該当するものを都度削除するという方法をとったらうまくいった。

※同じ値の要素が存在するLISは少し注意が必要！（1回WAしてしまったので）

## [ABC159-F ★★](https://atcoder.jp/contests/abc159/tasks/abc159_f) @2020-07-05

解説AC。

耳DPが難しい。。
絶対に復習が必要となる問題。

※解説放送を見ればわかるが、部分和問題の数え上げ問題は、多項式の係数と深い関わりがある。
割り算だったり順序を入れ替えたり、とかの正当性がすっきりわかるので、数え上げ手段としては強力（っぽい）。
実装も多項式バージョンを紹介しているっぽいので、気になったときにチェックして写経してみるといいかもしれない。

※いつも頼りになる[けんちょんさんの解説ブログ](https://drken1215.hatenablog.com/entry/2020/03/22/224200)

## [ABC173-E ★](https://atcoder.jp/contests/abc173/tasks/abc173_e) @2020-07-06

コンテスト中に解けなかった問題。注意力要素も強めな気がする。

解説放送で勉強する。

- 適当にやると場合分けがやばいので、丁寧にやりましょう。
- 0は一旦無視する。
- 「積を正にできるか⇔負を偶数個選べるか」←これが結構難しい。
  - 「正が1つでもあるかどうか」という視点は重要（最後の1つで帳尻合わせできる）
    - 実際、「負の数をk個選んだらどうなるか」を考えると、帳尻合わせが簡単に出来る（正は1つかならず残るので）。

## [ABC173-F ★★](https://atcoder.jp/contests/abc173/tasks/abc173_f) @2020-07-06

解説放送AC。簡単とか言われてたが、PDFを読んだ感じ初めて出会う考察だったように見える。

- 連結成分数を言い換える
  - `頂点数 - 辺数`
    - **これは「木の頂点数と辺数の関係を森の各木に対して適用してやる」ことで知らなくても発想できる！**
  - サイクルが起き得ない木グラフだからこそできる言い換え
- 辺数を数えるときは「横から見るものを縦から見る」やつで数える
  - 「主客転倒」とか「寄与ゲー」とかも言われるらしい（個人的に前者の言い回しが好き）

## [ARC014-D](https://atcoder.jp/contests/arc014/tasks/arc014_4) @2020-07-07

自力。易しめではあるものの、ノーミスで通せたのは嬉しい。

マージされる行間に注目すると良い。
マージされるものが増えていくと、その分 `x+y+1` を考えるべき個数が減っていく
（ちょうど↑の問題で、森に閉路とならないように辺を足すと連結成分が1つずつ減っていくように）。
その代わりにマージされた間の長さを加算すれば良いことになる。

これらの計算は行間のdiffを集めた配列を照準ソートして、
二分探索によってマージする個数が、prefix sumによって加算すべき値（寄与させる値）がわかる。

端っこの処理に注意。

## [ABC131-F ★★](https://atcoder.jp/contests/abc131/tasks/abc131_f) @2020-07-07

解説放送AC。PDFだけでは考察の流れ（気持ち）がわからなかった。

- 2次元の点を軸に射影するのは典型？[多分そう。](https://drken1215.hatenablog.com/entry/2019/06/23/004700)
  - 点を辺だと考える。2部グラフ上の点。
  - **完全二部グラフになるまで辺を追加する。**

**典型: 格子点を二部グラフとして考える。**

「二部グラフの奇数長のパス」というのも既視感があるので、発想の種として覚えておきたい。

実装は割と簡単かも（ちょっと考えたものが解説のすぬけさんのものとほぼ同等だったのは自分を誉めたい）。
連結成分でちょっと複雑なことをしたいときは、アドホックにDFSを書いたほうが融通がききそう。
（ABCの序盤ではunion findで雑にやるのも検討したい。）

## [ABC142-F ★★](https://atcoder.jp/contests/abc142/tasks/abc142_f)

解説放送AC。

なんとなくやりたいことはわかっても実装方法がよくわからない問題だった。
ので、最初から解説を参照した。

閉路ができたら必ずOKなものが存在する。
閉路があって条件を満たさない場合、その中に余計な辺があることになるが、
それを利用してより小さい閉路ができる。
よって、再帰的に調べていけば、いずれ条件を満たす閉路が見つかる。

↑多分、この考察が一番配点の大きい部分だと思う。
実装は割と適当でもいい、はずだがよくわからなかった。

また、言い換えるとBFSで最小（極小）サイズのサイクルを見つける、というのでよい。

BFS, DFS両方の実装をやってみたい。
が、BFSのほうが大分素直に見えるし、BFSにもっと慣れたいこともあるので、まずはここを強く覚えるのが良いかもしれない。

。。この問題などを見ると、ABC-Fは意外とシンプルに考えて良いものが多いのかもしれない。

**典型: BFS, DFSで有向グラフの閉路を取得する実装。**

※DFSの実装は[毎度おなじみのけんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2019/09/29/012000)が大いに参考になりそう。

## [ARC031-C ★★](https://atcoder.jp/contests/arc031/tasks/arc031_3) @2020-07-10

解説AC。簡単だと思ったが、多分どこかに間違いがあり、サンプルを除いて全然テストをパスしていなかった。

転倒数っぽいからBITを使う発想はすぐに出てきたが、転倒数の発想のママでは解けなかった。
てっきり累積和的なものを使って、最大のものをどこに置くかを全探索するものだと思ったが。。

正解は、その時点で最も小さいものを左右の端どちらかに寄せる必要があるが、どちらでも問題ないので近い方に寄せる貪欲を繰り返す、というものだった。
「小さいものから処理していく」というのは典型発想だったので、これも考えたかった。

この手法は、BITを使うことによって実装できるが、BITの扱い自体もあまり慣れていないので、いい練習問題として覚えておきたい。

**典型: 小さいものから処理していく。**

※転倒数を考えて全探索する方法もあまり間違いっぽくはない気がするので、どこかで解き直してみても良いかもしれない。

## [ARC051-C ★](https://atcoder.jp/contests/arc051/tasks/arc051_c) @2020-07-10

解説AC。というか、公式PDFを読んでもよくわからなかったので、色々なブログ解説を読んだ。
が、それでも最初はよくわからなかった。

よーく考えたら簡単な話だった。

「最小値にAをかけたものが、直前の状態の最大値以上になったら、以降は周期性を伴って変化する」というのは簡単な話だった。
最初、なぜそうなるのか理解できなかったが、具体的に昇順に並べた数列に対して、例えば2でもかけたものを書いてみると良い。

`A[n] <= A[1]*2` となったら、当然次は `A[1]*2 <= A[2]*2` となる。
これが繰り返されるのだから、周期性に疑問を抱く必要はない。

よって、最大値を超えるまではシミュレーションして、それ以降は周期性を利用して、二分累乗法によって計算を進めれば良い。
最初のシミュレーションについて注意が必要そうに見えるかが、結果は `int64` に収まるのと、
最大値を超えるまでに必要な掛け算の数はせいぜい30回もあれば十分なのはすぐわかる。
よって、そんなに悩む必要はない。

## [CODE FESTIVAL 2014 予選A C ★★](https://atcoder.jp/contests/code-festival-2014-quala/tasks/code_festival_qualA_d) @2020-07-11

解説AC。実装でコーナーに気づけず、地獄を見た。

桁DP的な考え方で数を捉える必要がある。
すなわち、貪欲的に左の桁をあわせたいわけだが、どこかでずらさざるを得ない時が来る。
これ以降は、大きくしてしまったなら選べる選択肢の中で最小を目指し続けるし、
小さくなってしまったら選べる選択肢の中で最大を目指し続ける必要がある。

よって、元の数字を左からいくつコピーするか、次の桁はどの数字にするか（ずらすか）、以降の桁はどの数字を連続させるか、
を全探索すれば良い。

おそらく、leading zeroをちゃんと扱わないと最小値を見逃してしまうテストケースが2つ存在する（具体的にどのようなものかは調べていないが）。
[この方の記事](https://qiita.com/ophhdn/items/339133a31b9e33c8c264)で気づけた。
「なんで戦闘のものだけ除けば十分なのだろう？」と思ったが、2つ0が続くようなものは最適にはなりえないため（多分）。
。。一回整数に変換してからまたOK判定するほうが賢かったかもしれない。。

その他、計算量は大分余裕があるので、イミュータブルなコーディングを心がけるのも大事。

※bitDPと桁DPをあわせたようなDPでも解けるようなので、いつか練習してみても良いかもしれない。

## [Indeedなう予選A D ★★](https://atcoder.jp/contests/indeednow-quala/tasks/indeednow_2015_quala_4) @2020-07-11

解説AC。実装が大変だが面白かった。

半分全列挙の考え方。
すなわち、 `3^24` は探索できないけど、 `3^12` ならOKなことを利用する。

初期状態から12階層、ゴール状態から12階層探索する。
盤面をハッシュ化することでハッシュマップに載せられるため、初期状態あるいはゴール状態からその盤面に至る最短手数を求めておく。
最後に、初期状態から到達可能な盤面とゴール状態から到達可能な盤面で一致するものを調べ、
最短手数を更新していけば良い。

**複雑なものでも、一致判定ではハッシュ化、あるいはソートをすぐさま検討できるようにしたい。**

※DFSの場合は途中で更新が起きうる場合があることに注意！その意味ではBFSのほうが高速な気がする。

※Aスターアルゴリズムでも解けるっぽい。kenkooooさんがブログを上げていた。

## [ABC167-F ★](https://atcoder.jp/contests/abc167/tasks/abc167_f) @2020-07-11

解説（放送）AC。

貪欲を詰めていくのが難しいと思う。
とはいえ、特別なアルゴリズムは用いない。

すぬけさん曰く、「アドホックな問題」。

- **カッコ列は折れ線グラフで考えると良い。**
  - **正しいカッコ列であるための条件は「0で終わる、0未満にならない」となる。**
- 断片を2つの値で表す。
  - ここはいろいろな見方ができそう。
  - 最下点と最終的な増加量を調べる。
    - 一度下がって一度上がる、シンプルなV字のものに統一できる。
- 増加量の正負でわけると、理想的な高さまで上がり下がりする、という考え方のもとでは、並べ方をシンプルにできる。
  - 上がるときは、最下点が大きいものからつなげるのが良い。
    - くっつけやすいものからくっつけていることになるので、それが無理ならどうあがいても無理。
  - 下がるときは難しい。逆から考えると同じ話になっていることに着目しないといけない。

## [ABC152-F ★★★](https://atcoder.jp/contests/abc152/tasks/abc152_f) @2020-07-11

解説（放送）AC。これも包除原理だった。

余事象っぽく考えれば良いのでは？と思ったが、あまりにもシンプルに考えすぎた。

包除原理を真面目に計算するタイプの問題に初めて出会えたので良かった。
**包除原理は、余事象を考慮するときに一緒に考えておくと良さそう。**

- 包除原理は、一般的には2のべき乗の計算量になる。

※すぬけさんの放送でやっていた実装では、パスを求めるのにDFSを行って、
「ゴールを引数に入れてそこに到達したらそこから巻き戻してパスを逆順にスライスに突っ込む」
というのが賢かった（ゴールとは違う終点にたどり着いたら `false` を返すことで無視できる）。
パスのスライスは、グローバルにおいてDFSを大元で呼ぶ前に初期化すれば良い。
シグネチャは `func dfs(cid, gid, pid int) bool` という感じ。

※包除原理の辺の数を数えるところは一貫してビット演算に閉じると、ビットマスクのOR演算で収まったり、大分高速になりそう。

※LCAを使った「木上の累積和」というのは結局謎のままだった。

