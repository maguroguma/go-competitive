# Codeforcesのmathタグの問題

Last Change: 2020-06-03 23:16:09.

## [1354A](https://codeforces.com/problemset/problem/1354/A)

900、問題文を読み取るのが難しいだけ。

## [1355D ★](https://codeforces.com/problemset/problem/1355/D)

1400って嘘でしょ？

構築っぽさもある。

正当性の証明がゲキムズに見える。
リングバッファみたいなものと、その上での累積和から背理法で導ける。
リングバッファと累積和を想起するのは大事だが、厳密な証明はコンテスト中は厳しそう。
そこからは雰囲気で解きたい。

もう少し考えたら、

- リングバッファみたいなのを考えて循環する累積和（区間和）もOK
- 正の整数しか含まないので累積和は1つ伸びると必ず大きくなる
- 作れる区間和の種類に対してkの種類が足りずNOになる

みたいな感じで直感的にイメージするのがいいかもしれない。

## [1355C](https://codeforces.com/problemset/problem/1355/C)

1800だけどこっちのほうが上のやつよりはるかに簡単。
あんまり数学要素はない気がする。

三角形の成立条件はよく覚えておきたい。
三辺の大小関係がわからないと条件は「ある2つの辺の和が他よりも厳密に大きい（3つの不等式を調べる必要がある）」だけど、
最大辺がわかっている場合は1つの不等式だけを試せば良い。
競技ではよく使うことになりそう。

今回は `x+y` を固定して、条件を満たす `z` を数える、というのをすべての `x+y` に対して調べれば良い。
ここは二分探索を使ったが、別にしゃくとり法でもいけるし、多分もっと簡単な方法でも良い。

`x+y` の作り方のパターン数を求める部分はいもす法がいいと思う。
数学で都度 `O(1)` で求めることも出来るかもしれないが、自分にはよくわからない。

## [1354C1](https://codeforces.com/problemset/problem/1354/C1)

1400。

なんとなく求めるものはわかったけど、それの求め方がわからなかったのでググったら公式が出てきた。

[正多角形の辺心距離](https://ja.wikipedia.org/wiki/%E8%BE%BA%E5%BF%83%E8%B7%9D%E9%9B%A2)とかいうらしい。

## [1355A](https://codeforces.com/problemset/problem/1355/A)

1200。

コンテスト本番だったらはまって解けていなかったと思う。
ギャグに近くて、桁に0が現れると変化しなくなる。
そして冷静に考えると、たかだか81までしか増えないので、近い将来100の桁に0がでてくる。

## [1342C ★★](https://codeforces.com/problemset/problem/1342/C)

1600。

全くわからなかったので答えを見た。

まず、区間に関する個数を問われているため、 `[0, r]` がわかれば累積和の感覚で任意の区間について解答できることに注意。

`x => a*b + x` としても両辺とも変わらないため、 `a*b` で周期性があると考えることが出来る。
そのため、 `a*b-1` までは所望の性質を満たすものについて真面目に調べて、後は周期性を利用して大まかに求め、
区間の端数部分は累積和で丁寧に求める。

結局、MODが与える周期性に気づき、それを利用する必要があるが、以下の点から気づきたかった。

- `[l, r]` がバカでかい割にクエリがめちゃくちゃ多いので、周期性から `O(1)` で各クエリに回答できる可能性がある
- そもそもMOD演算というのが周期性を与えるもの

## [1336B ★](https://codeforces.com/problemset/problem/1336/B)

1700。

ABCで似たようなものがあるが、これは真ん中にRGBの何を持ってくるかをすべて試す必要がある。
実装を簡易的にするために番兵を入れるが、回答するものが2乗和であることから何も考えずにやるとオーバーフローしてしまう。

自作のオーバーフローチェッカーを使って通したが、本番でやらないといけないとなると結構辛い。

**全部の順序関係における、ある真ん中を固定したときの最小パターンだけを求めれば良い** という部分がmath要素だと思う。

## [1334C](https://codeforces.com/problemset/problem/1334/C)

1600。

モンスターを全部倒すにあたり、すべての爆破は利用可能であることをイメージする。
すると、最初に倒すモンスター以外は後ろの爆撃を利用するのが最適で、
すべてのモンスターに対して爆撃を利用する場合に必要な残りの弾数というのを計算しておけばよい。
前計算を利用すると、すべてのモンスターを一番最初に倒した場合の弾数が求まるので、その最小を答えれば良い。

二分探索が必要かと思ったが、それすらいらずに `O(N)` で解ける問題だった。

## [1363A](https://codeforces.com/contest/1363/problem/A)

1200。

0と1にエンコードした後ソートする。
ここから連続する `x` の区間和をすべて調べれば、可能かどうか判断できる。
なぜなら、 `x` 個のうち何個奇数を含めるかを1つずつ増やしながら検証できるから。

## [1334A](https://codeforces.com/contest/1334/problem/A)

1200。

注意力コンテスト。気をつける部分が多い。

## [1338A](https://codeforces.com/contest/1338/problem/A)

1500。

Difficultyの割に簡単だと思った。
2進数をイメージすると好きな数を好きなタイミングで足せる、というふうに考えることが出来るため、
結局最も差が大きくなるところに注目すれば良い。

## [1330B](https://codeforces.com/contest/1330/problem/B)

1400。

前半と後半で順列になっているかどうかをチェックする。
前から見たときと後ろから見たときで、prefix or suffixが順列になっているかどうかを最初にチェックしておけば、
各境界で正しいかどうかを `O(1)` で検証できる。

多分実装の難しさでスコアが上がっている。

## [1329B ★](https://codeforces.com/contest/1329/problem/B)

1700。

考察は直ぐにできたが、実装でバグらせまくってしまった。
確実で思考をバグらせにくい方法もぼんやりあとから浮かんだので、いつか復習したい。

## [1332D](https://codeforces.com/problemset/problem/1332/D) @2020-06-02

1700。

構築。わからなかったので解答をそのまま通した。
結果だけ見るとギャグっぽさがあるけど、制約とか結構絶妙で、システス通すのも本番だと結構大変な気がする。

「ジャッジはどうするんだろう？」とかは考えない。

---

ここからは `math, number theory` の2つのタグからフィルタリングしたものを解いていく。

## [1332B](https://codeforces.com/problemset/problem/1332/B) @2020-06-02

1400。

登場する素数が少ないことに着目する。
構築では座圧を使うとバグがでなくて良さそう。

## [1312C](https://codeforces.com/problemset/problem/1312/C) @2020-06-02

1400。

k進数になおして、全要素に渡って各桁の総和が2以上にならなければOK。

## [1305C ★★](https://codeforces.com/problemset/problem/1305/C) @2020-06-02

1600。

わからなかったので答えを見たら、わからなかったことにめちゃくちゃ腹が立った。

鳩の巣原理が関係している。また、`m` のあまりが等しい2数の差は `m` の倍数、というのも必要。
`n <= m` なら真面目に計算すれば良い。
`n > m` なら必ずあまりが等しいものが2つ以上存在するので、答えは必ず0になる。

## [1294C](https://codeforces.com/problemset/problem/1294/C) @2020-06-03

1300。

考察はめちゃくちゃ簡単だけど `a^2 * b^2` でもOKにできることを見落としており、1ペナと長時間を失った。

## [1285C](https://codeforces.com/problemset/problem/1285/C) @2020-06-03

1400。

`x` を素因数分解して、素数のまとまりを `a, b` のどちらかに寄せればよいが、
それに関してはbit全探索で愚直にやって良い。

なぜなら、素数を小さい順に20個程度かけ合わせた段階で `10^12` という制約はオーバーしてしまうことから、
必要なビットはたかだか20個以下で抑えられるため。

考察を進めて自力で解けたが、割と非直感的な事実だと思った。

## [1349A ★](https://codeforces.com/problemset/problem/1349/A) @2020-06-03

1600。

本番で解けなくて解説ACしたのに全く覚えていなかった。
というか想定解法の `O(NlogA[i])` は天才過ぎて無理だった。

すべてを素因数分解すると、少なくとも `n-1` 個がある素数を素因数として持っていれば、
それは最後のGCDで生き残れることがわかる。
また `n` 個ある場合は下から2番目の指数を採用していいことに注意（これを忘れて1WAしてしまった）。

この解法だと `O(N * sqrt(A[i]))` になってしまうが、TLが3secなあたり、これも想定されてそう。

