# 3-4: 動的計画法を極める！

---

## bitDP

### 巡回セールスマン問題

- 再帰バージョンは書いたことがないので、一度社協だけしてみる。
- ループバージョンも蟻本流のテクニックを学ぶ。

#### 気になる文言

> 整数値以外の場合、ループで正しく順序付けて回すのが困難でメモ化再帰を行った
> ほうが良い場合が多いですが、
> 今回のように集合を扱う場合は、整数 `i, j` に対し、その表す集合が
> $S(i) \in S(j)$ ならば $i \leq j$
> となるので、次のようにループで書くことができます。

個人的にはbitDPは普通にループのみで書きたい。。

### Traveling by Stagecoach

- 乗車券を集合で管理すると、遷移辺を加えたグラフ上でダイクストラ法を用いれば最短路が求まる。
- 集合は真に小さくなる（＝戻れない）ため、DAGとなる。
  - **DAGの最短路はわざわざダイクストラ法を用いなくてもDPでかんたんに計算ができる。**
    - これはまだよくわからない。。

#### 写経してみて

- dpテーブルの更新と最終的な出力は分けたほうがいい気がする
  - dpテーブルの更新をする際はそちらに集中したい
    - 書き直したがそれでもちゃんと通るので、認識は間違っていない
- 「今どこにいるのか」「これからどこに行くのか」「どのチケットを使うのか」という点についてループになるが、順番は任意なので、自分がわかりやすい順番で書くのがいいと思う。
  - 個人的にしっくりするもので書き直してみた。

### ドミノ敷き詰め

まずは、愚直なやり方を書いてみて、bitDPでどのように高速化しているかを見るのが良い。

※このような敷き詰め問題は、グラフ理論の世界では **完全マッチング問題** と呼ばれるらしい。

#### 愚直版

コレ自体の写経も色々学べる。
AtCoder的には、難易度的にもそれなりの部分点がもらえてもいいぐらいな問題な気がする。

- 再帰関数の実装
- 2次元平面の敷き詰めパターンの典型的な数え上げ方
  - 再帰関数の呼び出し前後でフラグの上げ下げをしている部分が賢いと思った

状態数が `n * m * 2^(nm)` もあるため、これじゃだめ。

#### bitDP版

状態をうまく減らすことを考える。

※DPテーブルの再利用が行われており、ちょっとむずかしい。。

[このスライド](https://www.slideshare.net/hcpc_hokudai/advanced-dp-2016)が死ぬほどわかりやすい。

---

## 行列累乗

### 例題: フィボナッチ数列

行列累乗の最もシンプルな例題。

m項間漸化式は、行列累乗を考えることによって解ける。

**計算量は `O(m^3logn)`**

※累乗に関しては二分累乗法の要領で対数オーダーになる。

※3乗の部分は、単純にm次の正方行列の積に要する時間（3重ループになるため）。

※単純な行列の積の実装にあまり馴染みがなかったので、いい機会としてしっかり身につけておきたい（forループの回し方の都合上、手計算とは手順が異なっているので注意、あまり順序にこだわらず、最終的な結果が積の定義にはずれていないことが認識できればよい）。

### 例題: Blocks

**この問題は、数え上げの漸化式の考え方や初期値の設定がDPっぽくてよい。**

行列累乗は、最後に出力するものが何かをちゃんと明確に意識しておくのが重要だと思う。
### 例題: グラフの長さ `k` のパスの総数

結論から言うと、 **N点のグラフの隣接行列の累乗で求まる。**

※積事象の場合の数＋帰納法（？）＋行列の積の定義、で導かれる。

※行列のサイズが大きいため、 `O(N^3logk)` に耐えうるかは考える必要がある。

### 例題: Matrix Power Series

行列の累乗の和が求められる。

もともとの行列のサイズを行・列ともに2倍したものの累乗が求められるのと、
最後に余分な単位行列を引いてやる必要があるので、実装は結構気を使う。

