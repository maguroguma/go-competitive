# DDCC2020予選 感想

Cの400の実装がバグったりそもそも遅くて1100弱の緑パフォ。
D解けないのはちょっと経験不足で仕方ない感があるが、Cに関してはもう少し頑張りたかった。

- Aはifだけだとめんどくさそうだったので、配列の力も借りた。
- Bはちょっとコーナーケースがありそうで怖かったが、累積和でちゃんと整理できてよかった。
  - 全体と比較しても早めに解けたのは良かった。
- CはCodeforcesに出そうな重めの実装がテーマの問題。
  - いちごが存在しない行がネックになることに気づけなかったので、その時点で負けていた。

## Cの解説、解説放送より学ぶ

### 自分の考えに近い方

**1次元に落として簡単に考える** というのが最重要ポイント。

いちごが乗っている行を先に検出することに重点を置いて考える。

コードは[E869120さんの参考コード](https://atcoder.jp/contests/ddcc2020-qual/submissions/8320839)が提供されているので、
そちらをGoバージョンに写経してみることにする。

。。。と思ったが、ぱっとコードを見た感じ、自分の脳みそにとてつもなくマッチしなかったので、
参考にしつつ自分の脳みそにしっくり来る方法を考えてみることにする。

### 再帰的に考えるやり方

## Dの解説、解説放送より学ぶ

1桁の整数同士の足し算について、素朴に考える。

1. 繰り上がりが起こらないのであれば、桁数は `1` 減るが、桁和は不変
2. 繰り上がりが起こる場合、桁数は不変だが、桁和は `-9` される
  - `+10` が上の桁の `1` として肩代わりされるのが繰り上がりという事象の詳細なので、 `+10 -> +1` という変化から `-9` になる

`(桁数, 桁和) = (d, S)` と表すと、

1. `(d, S) -> (d-1, S)`
2. `(d, S) -> (d, S-9)`

のような変化がそれぞれ起こる。

操作の順番の詳細などは気にせず俯瞰してみると、
1, 2の操作の行える回数がそれぞれ計算できるため、それらの回数の和が答えとなる。

※ `S` は最終的に `1, 2, ..., 9` のいずれかであり `0` はありえないため、そのケースの考慮は必要となることに注意。

**典型: 不変量に着目する（広い意味で見た数列の和を不変量とみなすのも一種の典型）**

**典型チック: 桁和の動きを観察**

### maspyさんのツイート

学びがあったので。

> 目標物を意識して実例をいじる。
> ・桁数を維持したい
> ・数の大きさを維持したい
>
> 上手く両立できない気持ちになる。
>
> これを具体的に記述する方法を考える。数の大きさの表現として和を持ってくる。(桁、和)をきちんと数式にしてみる。完。
>
> 気持ちが生まれたらきちんと記述しようと努力してみよう。

### kyopro_friendsさんのツイート

> サーバル「「できなくなるまで操作を繰り返す」って問題は、「操作をするごとに減っていく量」を探すっていうのが基本的な考え方の1つだね！
> 今回だと、1回ごとにだいたい桁数が1減る気がするから、繰り上がりがあるときに「桁数の代わりに減ってるもの」を探したよ！」

**典型: 「できなくなるまで操作を繰り返す」って問題は、「操作をするごとに減っていく量」を探すっていうのが基本的な考え方の1つ**

### ダブリング？

シミュレーションを賢くするやり方で、高速に計算できるらしい。

以下はうまるちゃんのツイート

> DDCC予選お疲れ様!
> 目標だった4完を達成できたよ!
> D問題は同じ数字D[i]がC[i]個並んでいるのを半分づつにしていく感じで残ったものをシミュレーションしたら通ったよ!
> Yay!

