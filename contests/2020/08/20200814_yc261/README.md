# yukicoder261 感想

Bがギリギリ、Cが解けずという感じだったが、どちらも重要な知見があったので、ちゃんと復習すべし。

## A問題

素直にシミュレーションを行ったが、なにか重要な知見が隠されているかもしれない。

### `O(1)` で求められる

桁和を繰り返しとると値は急激に小さくなり、すぐに一桁になる。
さらに、数列のすべての要素を9で割ったあまりは等しい（なぜ？※）ので、答えは数列の最初の要素を9で割ったあまりに等しい。

※よくよく考えると `10^n % 9 = 1` が常に成り立つので、「桁和のmod9＝元の数値のmod9」が成り立つ。

### 数字根

[数字根](https://ja.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E6%A0%B9)という名前がついているらしい。

> 数字根（すうじこん、英: digital root）とは、
> 正の整数値の各位の和（数字和）を求め、結果の数字和を求め、という操作を繰り返し、最終的に得られる 1 桁の数を指す。

性質の一つとして、本問題の1つも書かれている。

> 一般に正の整数値 n の数字根は n を 9 で割った余りに等しい。ただし、余りが 0 の場合は、数字根は 9 に等しい。

## B問題

ほぼほぼエスパーのような手法で導いた。

自分がやったのは以下の通り。

1. 2行目以降を `[1, 2, ..., n]` を1つ左にスライドさせたもので続けていく。
2. 本来対角成分に来るべき要素はすべて1列目に存在することになるので、これを目的のものとスワップする。
3. 2までを終えて今のところは条件をすべて満たしているので、1行目を一意に確定させる。

想定解法は剰余を使ったものだったので、ちゃんと学習する。

### 想定解法

`A[i][j] = 2*i-j (i, jは1-based)` によって生成される行列が、すべての性質を満たすことを証明する。

各要素の `n` の剰余（ただし、1-basedなので0のときは `n` とする）がすべて衝突しないことを証明することになる。
その中で「整数の有名な性質」を使う。

> `a, 2*a, 3*a, ..., (b-1)*a` を `b` で割ったあまりはすべて異なる。
> （多分 `b*a` も含んで良さそう？）

※高校数学の美しい物語さんによれば、覚えてしまって良いとのこと（背理法で簡潔に証明できる）。

## C問題

そもそも連結成分を求める問題だと認識できなかったので、非常によろしくない。

解法は2つあるので、どちらも学習する。

### 連結成分を求める

愚直にエッジをはろうとすると、エッジの数が多すぎるので、工夫してエッジの本数をへらす問題、
というのが本質。

コレ自体は、二分探索で見つけた区間に対して、隣接するノードのみに辺を貼れば良い。
また、隣接ノード間の辺は当然1本で十分なので、それは区間の併合を予め行うことによって対処する。

区間の併合は、今回の問題の制約ではいもす法でよいが、久しぶりの練習のために、区間の端の値が大きくても大丈夫な、
ソートを使った方法を採用した（始点でソートしてやればよい）。

### union findを強くする

[ei1333さんのブログ](https://ei1333.github.io/algorithm/union-find.html)より。

これの「2部グラフの頂点彩色」や「左端と右端をもたせたUnionFind」あたりは作っておきたい。
とはいえ、習得するのはもう少し先に回したい。

### 「区間に辺を張る一般的なテクニック」

[これ](https://www.slideshare.net/secret/r8gjH9xYxFR0Fu)など。

役に立ちそうではあるが、今の自分が持っても持て余すだけになりそうであるため、さしあたってはスルーしておく。

