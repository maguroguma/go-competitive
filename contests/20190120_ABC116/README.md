# ABC116感想

- A問題は珍しく入力を一つ使わなくても解ける問題。
  - Goは使わない変数があるとCEするので、 `_` で受け取らなければいけないのを思い出す。
- B問題はちょっと解釈するのに時間がかかってしまったが、落ち着いて解くほうが大事なのでOK。
  - [コラッツの問題](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%A9%E3%83%83%E3%83%84%E3%81%AE%E5%95%8F%E9%A1%8C)なるものらしい。
    - 初項によらず収束する（？）のは確かに不思議で面白い。
      - 余談：コラッツ問題の概要を知っていると半分以下の時間でACできそうな気がする。
- C問題はかなり時間がかかってしまった。
  - Dが難しくて正解者が少なかったため、もったいなかった。
  - 水色になるまではCの安定速解きが最重要なのを再認識。
  - 自分はシミュレーションでやったが、シミュレーションを書くときはアルゴリズムを日本語で整理しきってから書くと良いのかもしれない（？）
    - **こういった問題を早く解くためにはどうすべきだったかを反省すること。**
  - ~~PDFにあるようなスマートな解法も理解すること。~~
    - PDFは証明をきっちりやってくれているもの（多分）。
  - 解説放送のすぬけさんのやり方は面白いし参考になりそうだが、自分の脳にはあまりなじまなかった。
- D問題は実装も大変な貪欲法。
  - 模範解答のやり方だと、priority queueが必要だったりする。
    - 解説ブログなどを散策すると、累積和などを使って解く方法もある模様。

---

## 自分がやったC問題の実装

コンテスト中に慌てて通したコードは余計なものがあって分かりづらかったため、後日整理したやり方。

```go
maxHight := Max(H...)
ans := 0
for i := 0; i < maxHight; i++ {

  for j := 0; j < n; j++ {
    if H[j] > 0 {
      H[j]--

      if (j+1 < n && H[j+1] == 0) || j+1 == n {
        ans++
      }
    }
  }

}
```

`ans` のインクリメントするタイミングが難しくて本番では時間がかかってしまった。

水をやり始めたタイミング＝非ゼロな高さに出会ったらインクリメントするのが自然だったのでそうしたかったが、
走査する過程で直前の花を枯らせてしまい、直前がもともと高さゼロだったのか、もしくは本来1以上の高さが連続していたが直前にゼロまで枯らせてしまったのか、
判断できなくなり困ってしまった。

なので、高さがゼロ

---

## 懐古DPさんのC問題の解き方・実装

twitterでおみかけしたもの。とてもスマートなやりかた。
こういう方法にはなにか名前とかあったりするんだろうか？

**直前の花の高さと比較して、自分の方が高かったらその差分を加算するだけ。**
確かに数えたいブロックの数が正しく数えられていることになる。

```go
ans := 0
for i := 0; i < n; i++ {
  if i == 0 {
    ans += H[i]
    continue
  }

  ans += Max(H[i]-H[i-1], 0)
}
```

