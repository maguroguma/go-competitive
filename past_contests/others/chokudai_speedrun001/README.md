# Chokudai SpeedRun 001 過去問感想

Last Change: 2020-04-25 20:27:04.

## A~F問題（@2020-04-25）

やるだけ。

## G問題（@2020-04-25）

剰余を常に計算していけば良い。

「連結」という操作は「四則演算でどのようにすれば等価になるか？」を考えると解ける。

## H問題（@2020-04-13）

問題名そのもので、LISを求める問題。

## I問題（@2020-04-25）

かなり初歩的なしゃくとり法

## J問題（@2020-04-12）

問題通り転倒数を `O(NlogN)` で求める問題。

蟻本の以下の説明の通りに求めるには、BITをSetとして捉えてやるのがよい。

> 各 `j` に対して「 `i < j, A[i] > A[j]` となるような `i` の個数」を効率的に求める。

以下のロジックを繰り返せば良い。

```go
ans += i - bit.Count(A[i])
bit.Insert(A[i], 1)
```

順番を逆にするとバグるので注意（おそらくは `i` が0-basedだから（？））。

**挿入前の `bit.Count(A[i])` によって `A[i]` 以下の要素の数が求まる。**
**また、 `i(0-based)` を見ている時点で、BITに詰まっている要素の全体数は `i` に等しい。**
**よって、 `i - bit.Count(A[i])` を加算していくことで、最終的には転倒数が求まる。**

※区間の右端を固定して、今まで見てきた左側全体を監視する構造からすると、zero sum rangesのような区間問題の雰囲気もある。

## K問題（@2020-04-25）

数え上げ。自力で解けたが、データ構造とかロジックはちょっと考えた。

桁DPっぽい考え方が重要。
そして、加算する際は「現在注目中の数値より小さく、かつ、未登場のもの」の数を高速に取得できる必要がある。
この部分はBITによるSetを用いた。

## L問題（@2020-04-25）

スワップが題材の問題だが、個人的に難しいと思うし苦手なタイプの問題。

手法自体は思いついたものであっていたが、明確な証明ができていない気がする。

[この方のブログ記事](https://nemupm.com/blog/2019/03/03/chokudai-speed-run-001/)にあるように、
「操作過程で影響を受けない場所がある」という考え方は、他でも活きてくる重要な考え方だと思った。

