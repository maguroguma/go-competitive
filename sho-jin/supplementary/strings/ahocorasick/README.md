# Aho-Corasick

Last Change: 2020-10-10 16:55:58.

KMP + Trie。  
これを最初に聞いていれば、もっと早く理解できたかもしれない。

## 参考

- [naoyaさんのブログ](https://naoya-2.hatenadiary.org/entry/20090405/aho_corasick)
  - 一番最初に参照したのはこの方のブログ。
  - Trieをいじるというのはわかったが、具体的に幅優先探索をどうすればよいのかわからず、困ってしまった。
- [Algoogle](http://algoogle.hadrori.jp/algorithm/aho-corasick.html)
  - コードはこちらから拝借した。
  - いくら説明を読んでも理解できなかったので、まずは写経してから理解をしようとした。
    - コードリーディングで理解できた。
- [tmaeharaさんのブログ](http://www.prefield.com/algorithm/string/aho_corasick.html)
  - この人が「KMPを行う」と明言してくれるのならば間違いないだろう、と思えた。
- [すぬけさんのKMP法の解説](https://snuke.hatenablog.com/entry/2014/12/01/235807)
  - 結局、Aho-Corasickの理解にはKMP法を理解することが重要。

## アルゴリズム

1. パターン文字列のリスト（辞書とも解釈できる）から、ベースとなるTrie木を（オフラインで）構築する。
2. Trie木を幅優先探索しながら、「現在見ているノードの先に、各アルファベットの遷移先が存在する場合に、
**その先のノードのfailure link** を設定」する。
3. 修正されたTrie木を用いて、テキストを入力としパターンマッチを調べる。

1,2の前処理によって構成されるTrie木は、パターンマッチオートマトン（PMA）と呼ばれる。

※通常のTrie木と異なる点として、failure link用のポインタ領域が必要。  
※オンラインでPMAを更新するアルゴリズムもあるらしい。

### failure link

これをちゃんと理解することがまず第一歩。

failure linkとは、テキスト検索において、
**通常の照合に失敗した際に、「文字を消費せずに（ε遷移のように）遷移する」リンクのこと。**

どこに遷移すればよいかというと、「これまで照合してきたパターンに対する、最長のsuffixに相当するノード」といえる。  
そのようなノードに遷移することで、照合済みのテキストを戻ることなく、一方向に継続して進んでいけることになる。  
（※このあたりで、KMP法っぽさが見えてくる。tagged borderのprefixを、そのままsuffixにずらせるだけずらしたようなイメージ。）

テキスト検索が効率的になることは理解しやすいが、肝心のfailure linkの張り方が少し難しい。  
幅優先探索のため、はじめにキューを初期化することになる。  
この際、rootノードから伸びるノードに対して、そのノードのfailure link先をrootノードに設定する。  
また、例外的にrootノードについては、failure link先、およびすべての文字の遷移先を、自身であるrootノードとする。  
これは、failure linkの定義に沿っている。  
これが初期化処理となり、以降は幅優先探索を行い、初期化と同様に、
**「現在注目中のノードの遷移先ノードがある場合、その遷移先ノードに対するfailure linkを設定してやる」**
というふうにアルゴリズムは進む。  
また、最長のsuffixの見つけ方は、照合中の文字を `c` とした場合、
「failure link先のノードが `c` によって遷移できるかどうか」を調べ、
「遷移先が存在すればそのノードがfailure link先、存在しなければさらにfailure linkをたどり、見つかるまで繰り返す。」
というふうにして見つけられる。  
（※rootノードは遷移先が存在しない場合でも自身にループさせるため、最悪rootノードがfailure link先となる。これは、最長のsuffixが空文字列のケースと言える。）

### 実装

色々あると思われるが、ポイントは以下のあたり？

- Trieのノードに対して、failure link先を格納する領域を確保する。
  - 参考にした実装では、固定長配列の `0` 番目としていた。
    - これは、文字のasciiコードをそのまま利用していたため。
  - failure link用の領域を特別に用意しても問題ないと思われる。
- 次のノードの受理対象に、本来のTrieノードが持っているものに加えて、祖先が一致した文字列の情報も持たせるようにする。
  - 例えば、パターンに `"a", "ab", "cab"` といった文字列がある場合、
  `"cab"` まで照合されてfailure linkによって `"ab"` のノードに飛ばされるとき、 `"a"` についても受理されてほしいため。
  - テキスト検索時の受理文字列をカウントしたり調べたりするタイミングには注意すること！
    - failure linkによる遷移時（ε遷移したとき）には受理情報を参照してはいけない。

### 余談: 日本語のテキストを扱う場合

ASCIIコードの範囲は小さいため、競技用のコードでは基本的にすべての文字について全探索するような実装となっている。  
実際の自然言語、例えば日本語に関しては文字数が多すぎてこのような実装をするわけには行かない。

そういった場合は、おそらくはPMAのノードが辞書を持つような実装になるのだと思う。

※かなり雑な推測です。

## 計算量

前処理: `O(M), M: パターン文字列群の長さの合計`  
テキスト検索: `O(N), N: 入力テキストの長さ`

後者については、遷移失敗時にfailure linkをたどれば再び照合を再開でき、failure linkの遷移が `O(1)` なのだから、
この計算量になることはすぐ納得できる。

一方で、前処理部分は難しい（個人的には難しいと思うが、詳しく解説している箇所がなかった）。  
一見すると、各ノードでfailure link先を見つける部分で、最悪の場合は毎回文字列長の分だけバックトラックが必要になりそうで、
そうなると計算量は `O(M^2)` となってしまいそうにも見える。

しかしながら、PMAの構築は「Trieに対してKMP法を適用している」と考えると合点がいく。  
つまり、failure linkをたどるということはTrie木における最長suffixまでもどるということである。  
幅優先探索の都合上、次は別のノードについて考えることになるが、このバックトラックの情報はfailure linkとして保存される。  
そして、KMPの計算量の考え方を用いると、各パターンについて計算量は線形であると言える。  

KMPと異なる点として、あるパターン文字列Aについて、A自身の最長suffixだけを考えるのではなく、
Trie木が持っている他のパターン文字列も含めて、最長suffixを探索する、という違いはある（はず）。  
しかしながら、結局パターンごとに考えると、バックトラックできる最大量はパターン文字列の長さ、
というKMPの計算量の考え方の肝は失われておらず、前処理の計算量が導かれる。

