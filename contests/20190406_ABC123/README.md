# ABC123 感想

大反省回。

[解答リンク](https://img.atcoder.jp/abc123/editorial.pdf)

- A問題は全部チェックする。配列にすると楽だけど、慣れてない人はたくさんタイピングさせられてそうだと思った。
- B問題は順列を求めて全パターンチェック。これもはじめての人はたくさんコードを欠かされることになりそう。
- C問題はあまりにも雑に考えすぎた。
  - 制約のためシミュレーションは不可。
  - ボトルネックに着目した `O(1)` 解法をやらないとだめなわけだが、雑なやつを投げたら中途半端にACが出たため、違う方法に進んでしまった。
    - **とりあえず投げる -> 実は正しい方向だったのにWAで迷走する** 、というのは今後も有り得そうなのでちょっと考えたい。
  - `ceil` するのは、詰まっている部分で全員を次の都市に進ませるための時間。
    - `floor` してしまったが、これだと何人か（あまりの人数）を置いていくことになる。
  - `+4` 加算するのは、詰まっている部分以外で4都市分進行するため。
- D問題は嘘解法を最後に投げて息絶えた。
  - 嘘解法は、300個ぐらいをグローバルに大きいものをとってきて、ABCを1つずつ含むようにした和をすべて計算してK個取り出すというもの。
    - そもそも3000個作れないときもある（例えばほとんどをAからとってくることになる場合など）
  - PDFの解説が充実しており、4通りすべてがコードと共に与えられているので、全部理解すること。

## D問題

### 解法1: ソートを工夫する

一番理解が簡単だが、自力で思いつくのは大変だと思う（この方法で解いているのは黄色以上が多い印象だった）。

最初に `A+B` の和のパターン（最大 `10^6` 通り）を計算する。

これらのすべてのパターンにCの各要素を足したものが、グローバルなパターンになるが、
**グローバルで上位K個にランクインするパターンについては、この100万通りの中ですでに上位K個にランクインしているはずである。**

なので、求めた100万通りのうち、上位K個（最大3000個）とCの各要素との和をすべて計算してやり、ソートした上で上位K個を出力すれば良い。

ソートを2回することになるが、どちらも `10^6` のオーダーなので十分間に合う。

**予選・決勝法的な雰囲気を感じる。**

実際に実装してみたところ 1800msec 程度と、かなり危ういところとなってしまった。
これぐらいの規模だと、スライスの容量確保のあたりはきっちりやらないとダメかもしれない。

### 解法2: 「ある条件」を満たす最大 106307 通りをすべてソート

A の中で a 番目、B の中で b 番目、C の中で c 番目だとしたときに、
`a*b*c > K` の場合、絶対に上位K個には入らない、というもの。
（一番高いケースでも、せいぜい上から `a*b*c` 番目にしかならない、とのこと。）

これは正直、自分にとって自明ではない。

[chokudaiさんの解説放送（大体 1:02 あたりから）](https://www.youtube.com/watch?v=KwHd_LKcnrY)では、
2部グラフ（または3部グラフ）っぽい説明がなされていて、なんとなく香りは伝わった。

お互いにエッジを張って、下位同士のペアは上位には入れない、というイメージ。
例えば、1501位と2位でペアを組んでも、3000位には入れない。
ただし、1501位と1位は3000位に入る可能性が十分にある。
こういう意味で、**3000位をこえる3人組は見なくて良くなる。**

ただし、計算量解析が難しい（らしい）。

### 解法3: 優先度付きキューで頑張る

この方法が今回最も学びにしたいと思う（青色を始めとして、色々な人がこの方法をとっていて、一番自然な解法なのだと思われる）。

まず、A,B,Cを降順ソートする。

起点を `A[0], B[0], C[0]` として、これを和とともに優先度付きキューに入れる。
優先度はこの和に相当する。

優先度最大のオブジェクトを pop したとき、次は、
`(1, 0, 0), (0, 1, 0), (0, 0, 1)` の3種類を入れる。
直前で pop したものの次に和が大きいものはこの中に存在する。
（`(1, 1, 0)` や `(2, 0, 0)` を、上で挙げたものを差し置いて候補に追加する意味はない。）

実装に関しては、一度入れたものを重複して入れないように注意が必要。
（`map[obj]bool` あたりを使うのが妥当か？）

解説放送では `set` を使っていた。
**`int hash = (a << 20) + (b << 10) + c` というのはテクニックを感じた。**
（大体 a を1000000倍, b を 1000倍 しているので、目安にする。）
（番兵を入れるテクもあったっぽいが、このあたりは自分で書いてみて必要そうだったら検討してみる。）

これも[chokudaiさんの解説放送（大体 1:11 ぐらいから）](https://www.youtube.com/watch?v=KwHd_LKcnrY)がわかりやすい。
**3つはややこしいので2つでシンプルに考えましょう、というスタンスが素晴らしかった。**

**ダイクストラ法に言及するコメントもナイスだった（脳みそが刺激されて良い）。**

考えるべき候補を追加して考えられるようにしつつ、必要に応じて以前追加した候補に（優先度によって自然と）戻るようになっている。
そして、pop したものに応じてさらに考えるべき候補を追加する。
これはまさしくダイクストラ法と似た動き。

### 解法4: 二分探索

これも枝刈り全探索がはさまるため、あまりやりたい手法とは思わない。
（計算量的に不安のあるコードに感じる。）
