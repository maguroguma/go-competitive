# LIS: 補講

Last Change: 2020-04-12 16:39:09.

蟻本の理解も曖昧なので。

また、二分探索で求まるDPテーブルとは別定義のもの（BITで高速化するやつ）についても、
応用力を鍛えるために理解度をあげる。

## 二分探索で高速に求める

「なんでDPテーブル上で二分探索して求まるの？」という感じがするが、
以下のように一つ一つポイントを整理していくと納得できる、気がする。

### DPテーブルの定義

`dp[i] := 長さが i+1 であるような増加部分列における、最終要素の最小値（存在しない場合は INF）`

### 重要な観察

> DP配列は（INF部分を除いて） **狭義** 単調増加となる。

これはLISの定義より明らか。
長さ `l` の最終要素より真に大きい必要があるため、このようになる。

> もとの数列を前から見て、ある要素については更新箇所は唯一である。

これも1つ目の事実からほぼ明らか。
なぜなら、ある `dp[i]` について `a` で更新したとしたら、
`dp[i+1]` 以降は `a` で更新してはいけないに決まっているため。

### 蟻本の説明で読んでてよく混乱するところ

> 与えられた数列を前の方から見ていき、各 `A[j]` に対して、 `i=0` または `dp[i-1] < A[j]` ならば、
> `dp[i] = Min(dp[i], A[j])` と更新される。

もう少し冗長な表現に変えてみる。

LISなので直前の要素よりも大きい要素が続く必要があるわけだが、 `i=0` だと直前の要素はないので、
無条件に `dp[i] = Min(dp[i], A[j])` としてよい。
一方で、 `i>0` のときは直前の要素より大きい、すなわち `dp[i-1] < A[j]` という条件を満たす場合のみ、
`dp[i] = Min(dp[i], A[j])` という更新を考慮できる。

### 愚直な `O(n^2)` はどのようなコードになる？

```go
for j := 0; j < len(A); j++ {
  for i := 0; i < len(A); i++ {
    if (i == 0) || (i > 0 && dp[i-1] < A[j]) {
      isBreak := ChMin(&dp[i], A[j])
      if isBreak {
        break
      }
    }
  }
}
```

※適宜、 `INF` が現れだしたら `break` していいはず。

※[この問題](https://atcoder.jp/contests/abc006/tasks/abc006_4)ぐらいの制約なら、このアルゴリズムでもギリギリ通せちゃう模様（C++なら余裕そう）

