# 日本情報オリンピック過去問 難易度6まとめ

Last Change: 2020-10-23 00:02:37.

## [B. お菓子の分割 ★★★](https://atcoder.jp/contests/joi2010ho/tasks/joi2010ho_b)

わからなくて解説を読んだのにオリジナルの実装で非常に苦労した。

DPでやりたいなぁと思いつつ、遷移はおぼろげながらイメージが付いても状態の持ち方がわからず、解答を漁った。

[kutimotiさんのブログ](http://kutimoti.hatenablog.com/entry/2018/01/19/234001)が参考になったが、微妙に実装はオリジナルに変えた。

「1つ1つ区切られたお菓子を片方の人に配り続け、コストを支払うことでもう片方の人へ分配をチェンジできる」
と問題文を読み替えることが最重要。
そうすると、「以前どこで切ったのか？」というような情報を持たずに済む。

**「ステートレスに考える」**
とも捉えられそう、な気もするし、そういう言い方は不適切な気もする。

結局、自分の場合 `[M][M][Y][Y][M]...` のようにブロックを分けるように考えて、
`dp[i][j][M or Y] := i番目まで観たとき、自分がj個お菓子を獲得しているときの、コストの最小値`
として考えた。

ただし、初期化と遷移が微妙に難しい。
コストを考えるポイントはお菓子に相当するブロックではなく、ブロック間の「仕切り部分」であることから、慎重に進めなければならない。

## [B. IOI列車で行こう ★★★★★](https://atcoder.jp/contests/joi2013ho/tasks/joi2013ho2)

DPの発想すらできなかったので完敗だった。  
「とりあえず考えられる並びを全探索して、そこで出来上がる部分文字列で最大のものを取ろう」というのがベースの考え方。  
なので、弱い制約では愚直な全探索ができるし、中程度の制約では値がbool値の「（やや）自明なDP」が通るようになっている。

満点回答は `dp[i][j][flag] := Sからi文字分, Tからj文字分とって作る文字列の最大長、ただしフラグによって末尾が変わる`
というような状態を考えることで計算できる。  
これはLCSのような貰うDPを考えるのが簡単だが、なんか初期化方法がよくわからなくて無理やり配るDPを書いてしまった。

※あとで貰うDPでも解いてみたが、この場合はLCSとは違って、 `dp[0][0~m]` と `dp[0~n][0]` の初期化が最初に必要となることに注意する。

## [E. 魚の生息範囲 ★★★](https://atcoder.jp/contests/joi2013yo/tasks/joi2013yo_e)

3次元の座標圧縮。

この問題では、 `x-1, x, x+1` のように、一点あたり3つの座標を放り込むとなぜか（体積計算が）うまく行かなかった。  
また、そもそもこのような点の増やし方はメモリがめちゃくちゃ増えてしまうので、むやみやたらにやるのはやめたほうがいいと思われる。

※追記: 普通に最後のforループの上限を変更し忘れていたからだった。

## [C. バームクーヘン ★★★★](https://atcoder.jp/contests/joi2014ho/tasks/joi2014ho3)

二分探索だが、この形は始めてで面白かった。

**分割して出来た値の最小値の最大化を考えるとき、**
**「すべての分割してできたオブジェクトが `x` 以上かどうか？」という判定問題の二分探索を行うことで解ける**
、というのは初めて出会うタイプの問題だった。

この問題では、判定問題を解く中でも更に2回二分探索をする必要があり、全体の計算量はlogが2つつく形になる。

※尺取法を使ってlogを1つ削ったり、全体で尺取法しか使わずに定数オーダーで解くことも出来てしまうらしい。

## [C. JOI公園](https://atcoder.jp/contests/joi2015ho/tasks/joi2015ho_c)

難易度7の中でようやく自力で解けた。というか今の所これだけぶっちぎりで簡単だった。

とりあえずダイクストラ法すれば単一最短経路の距離はわかる。  
結果をIDを保持しながら昇順ソートすれば、広場1に近い順にスキャンできる。  
ここで、ベースの値を「舗装すべき全ての道路の長さの和」として、これを地下道を作ることで緩和していく方針で考える。  
ソート結果から `x` を0から離散的にすべて調べることが出来、また、ある広場を調べるときに、
その隣接リストをスキャンすれば、すでに相互接続されている広場が確認できる。  
この部分の計算量は `O(n + m)` になるので、実装上二重ループになっても全く問題ない。

## [M. ストラップ](https://atcoder.jp/contests/joisc2014/tasks/joisc2014_m)

これも自力で解けた。1WAしたけど。。

DPなのはすぐわかる。  
`dp[i][j] := i番目までみたときに残りの穴数がj個の場合の最大` とすれば良い。  
`j` が普通にやると `10^6` になってしまうが、ストラップの付け方から、穴の数は `n` 個アレば十分なので、 `j <= n` までで十分。

WAの原因は、穴の数で降順ソートしていなかったため。  
ソートしておかないと、途中でストラップの穴がなくなってしまう可能性がある。  
厳密には、ソートしなくても、穴が0個のストラップさえ後ろに回せば、それ以外の順序は問題ない。

## [E. 砂の城](https://atcoder.jp/contests/joi2015yo/tasks/joi2015yo_e)

ちょっと迷ったが、わかってしまえば簡単だった。

愚直に考えると、ドットの位置から強度分削っていきたい気持ちになる。  
一見すると計算量が爆発してしまうように見えるが、1ドットあたり1回しかその処理をしないように考えると、
普通に1ドットに付き周囲の8マスをデクリメント、とするだけでよい。

あとはQueueを使ってFIFOで処理していけば良い。

