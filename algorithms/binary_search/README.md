# C++における `lower_bound, upper_bound` 相当の二分探索

- 左側のindexをleft、右側のindexをrightとしたとき、 `right - left == 1` でかつrightより右側は真、leftより左側は偽となるようなleft, rightを見つける二分探索
- 初期値を配列の範囲外に設定すること、左端と右端の差が1になるまで続けることに注意
- 配列がソートされていることから真偽値についてもインデックスに対して単調性を有しており、条件判定の部分が別の関数に分けられているところがわかりやすい
    - **`mid == false` だったならば、偽であってほしい左端を `mid` で上書きし、`mid == true` だったならば、真であってほしい右端を `mid` で上書きする。**
    - 本来の二分探索と異なり `+1, -1` の移動がないため途中で無限ループになってしまいそうに見えるが、左端と右端の差が1より大きいときは必ず動く
- ~~`lower_bound` に対して `upper_bound` に実装し直す場合、 **真と偽の境界を反転させる必要がある** 点に注意~~
  - **C++の実装と異なる実装を当初行っていたこともあり、↑の考え方は一旦忘れる。**

## (2019/01/20修正)

- C++の実装に正しく修正した（はず）なので、当面は昇順ソートに対する利用に慣れる。
