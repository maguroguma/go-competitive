# Mujin Programming Challenge 2018

- C問題は前処理については正しく考えられていたが、肝心の答えを求める部分がわからず解説を読んだ。
  - とりあえず、各マスについて上下左右の進める数を累積和の容量で求める必要があるところは理解できた。
    - 累積和の容量で、前の結果を利用することをしないと計算量的にまずくなる。
  - 具体的な計算などは[しまむむさんのこのブログ解説記事](https://simamumu.hatenablog.com/entry/2018/08/07/230258)が参考になる。
    - グリッドグラフ系でも応用できそうな小技が光る。
  - あるマスに注目し、 **注目マスにて右折するルートを数える！**
    - **典型: 真ん中に注目する。**
      - この問題では、ルートを「始点・右折点・終点」と捉えることができ、その真中である右折する箇所に注目する必要があった。
- D問題は規則性を見つけようとしたが、探せる気がしなかったので、おとなしく解説を読んで勉強した。
  - アルメリアさんのブログで、**「この問題は「整数の遷移をグラフとして考える」というパターンを思い出すべきでした」** という言及がなされていた。
    - そんなのあるのか。。という気分になったが、あるならしょうがないので覚えておく。
    - 写像とか全射とか、そのあたりのイメージが明確だと自然と理解できそう。
  - 解説にあるとおり、整数のペアを頂点としてみたときに、ペア `(x,y)` に対して操作を行って遷移を続けて無限ループになるようなペアを答える、というので行ける。
    - 。。が、それがわかったからと言って素直にコードは（少なくとも自分は）書けない。
    - [はまやんはまやんさんの解法](https://www.hamayanhamayan.com/entry/2018/08/05/092606)は比較的素直に感じる。
      - 無限ループの検出を直接行う感じ。ただ、理解はできても、次回以降自分が同じことをできるかはちょっと自信がない。
        - **遷移が難しいが、仮のものを置いておいて、再検出したら無限ループと判定する部分は勉強になる。**
      - **メモ化をすらすらと使っているところを真似したい気がする。**
    - [Bwambocosさんの実装](https://babcs2035.hateblo.jp/entry/2018/10/30/220813)は想定解法を書いたもの。
      - こういったコードがスラスラ書けるようになりたい。
      - **グラフを作るときは全体を一気に作る、という意識ではなく、ある点から1つ先だけにエッジを張ることを繰り返す、という意識を持っておくと、取り組みやすくなるかもしれない。
  - 何週間ぶりかわからないがDFSをする解法で解いてみたが、全く刃が立たなかった（というか注意深く写経してやっと、といった感じだった）。
  - 何回か混乱しそうになるが、この問題で与えられる操作では、必ず数値は10進数で3桁から飛び出ないことには注意（無駄な思考に時間を費やさないこと）。
  - 実装テクニック的にも重要で、復習の価値が高そう。
  - 以下は実装テクニック。
    - ハッシュマップではキーに構造体インスタンスを使うこともできるが、競技では避ける。 **ハッシュ化を考える！**
      - TLEしない安全な方法を選ぶこと。
    - DFSにおいて、来たノードを再訪問しないために、 `isVisited` フラグを設けておく。
      - これは自分もやってたかもしれないが、念の為。

---

## C問題: しまむむさんのグリッド系の小技

あるあるなんだとは思うが、なかなか自発的にはできない気がするので、メモしておく。

### グリッドに外壁を作る。

- `'#'` で外壁を作る。これによって、`n*m` のグリッドは `(n+2)*(m+2)` のグリッドとなる。
- これに伴い、スキャンする範囲は、0-basedな添字で表すと `[1, n], [1, m]` となる。
  - forループなどでは条件式に `>=, <=` を使ったほうが間違えにくいと思われる。
- **この工夫によって、out of index errorを思考から除去できるため、実装は楽だと感じた。**
  - 実際のところ、この工夫を持ってしてもやや神経を使うが、これはなれるまでは仕方がないと思われる。
    - 慣れても一定の慎重さが要求されるかもしれないが、これは問題自体が内包する複雑さだと思って受け入れて頑張る。

### 当該マスから上下左右にそれぞれ何マス進めるかの数え方

- 壁のあるマスを `-1` で初期化する。
  - 解説では全マスについて `-1` で初期化しているが、念の為。
- 上左に関しては添字の小さいところから、下右に関しては添字の大きいところから遷移させることで、正しい値を導く。
  - これは自然に考えればこうなる。

累積和などもそうだが、自分が自然にやろうとすると、別の変数を用意してそこに暫定値を記憶させて、それを使って行列の値を埋めていく、ということをやりがちだが、これは極力避けるようにしたい。

**すでに計算が完了した値を使って、しかるべき遷移によって欲しい答えを得るように思考を矯正したい。**

**こういうやり方はDPっぽい気もする（すでに計算が完了した答えを利用しているので）。**

---

## D問題: 思ったことなど

### メモ化再帰の熟語

別に特別取り上げる話ではないが、こういうコードに慣れておくと、メモ化再帰ももっと自分に馴染んでくると思ったので。

```cpp
return memo[x] = res;
```

Goでもこういう書き方がしたい（業務ではしたくない）が、Goではコンパイルエラーとなるため、
以下の2行を熟語として覚えておく。

```go
memo[x] = res
return memo[x]
```

### 全射とか単射とか全単射のワードの整理

学部初期に習って以来ほとんど使ってこなかったため、忘れてしまっていたので、改めて整理しておく。


