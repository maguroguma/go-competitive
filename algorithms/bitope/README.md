# bit演算

基本的だけど「九九や呼吸と同じくらい自然に考えられているか？」と言われると頷けないので、
ちゃんとまとめておく。

おなじみ、[けんちょんさんのbitに関する記事](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#bit-dp)をさらっていく。

---

## 基本操作

任意ビットを立てる操作は、立てたいビットのみを1としたビットマスクでOR演算をかますだけ、というのはわかりやすい。
冪等性があるのも自明。

しかしながら、任意ビットを降ろす操作は、冪等性のあるものを自分は作れていなかったので、これはよく覚えておきたい。

**`&= ^maskbitset` のように、マスクビットの反転についてAND演算をかましてやれば良い。**

---

## ビット演算は集合演算

bit DPなどはこのあたりの考え方が前提となっていると思うので、メモ。

### bit全探索

> bit全探索とは、`n`個の要素からなる集合`{0, 1, ..., n-1}`の **部分集合** をすべて調べ上げる手法のことです。

きっちり言語化するとこういうこと。

### 部分集合の部分集合の全列挙

```go
A := (1 << 2) | (1 << 3) | (1 << 5) | (1 << 7)
for bit := A; ; bit = (bit - 1) & A {
}
```

これで実現できる。

#### 直感的な理解

- `bit-1` によって、1が立っている最も下位のビットが降ろされるとともに、マスクにはそれより下位に立っているビットがあれば、それらがすべて立つことになる
  - 影響する下位桁 `10...0 - 1 == 01...1` に対してマスクがかまされるため。
- 集合的な列挙のイメージで考えると、、
  - はじめはすべての要素が含まれた要素からスタート。
  - 最も下位のビットにあたるものから消えていく。
  - 要素の消え方・復活の仕方は、2進数の数え上げを逆からやっているイメージ。
    - 全要素→空集合へ、自然な減り方をしている。

---

## `next_combination`

ABC018Dでこれを使った解法もあるらしいが、ちょっと今は学ぶモチベーションが薄いので、また機会があれば。

---

## Xorshift

ビットを用いたシンプルな乱数生成方法で、乱数の質が高い割に超高速で、しかも実装もシンプルとのこと。

---

## Binary Indexed Tree (BIT)

これもビット演算が要となっているらしい。
（別パッケージで別にまとめる。）

---

## bit DP

例題として巡回セールスマン問題を解く。
（またやる気が出たら更新する。）
