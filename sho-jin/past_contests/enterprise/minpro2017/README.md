# みんプロ2017過去問感想

- C問題は重要な制約を見逃して、2分探索を利用した `O(nlogn)` 解法で解いた。
  - 初めに思いついた方法はTLEをしてしまったので、[じゅっぴーさんのブログ記事](https://juppy.hatenablog.com/entry/2019/02/08/Yahoo_%E3%81%BF%E3%82%93%E3%83%97%E3%83%AD%282017%29_-C-_Python_%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)を参考にして解いた。
    - 全体的な解き方も非常に参考になるので学ばせていただく。
    - **辞書順についての理解が深まる良い経験となった。**
  - **今回のように、数式とは別に自然言語で制約に対するとても重要な補足が合ったりすることがあるので、油断せずに確認すること！**
    - **「和が `10^5`」というのは特に初めて見るものだったので、見事に見逃してしまった。**
  - **典型ポイント: 辞書式順序、2分探索**
    - どちらも想定解法では必要とされていないが。。

---

## C問題の自分の解き方の概略

自分は基本的に、ある接頭辞を考えたときに、それを使ってAだけをヒットさせられるかどうか？の判定を愚直に `O(n)` で行った。
（ここを短縮する方法がわからなかったため。）

Aをすべてヒットさせる接頭辞の中で最長のものは、A以外の文字列をヒットさせないのに一番有利な検索文字列であり、
ここから1文字ずつ減らした文字列に対し愚直に条件を満たすかチェックすればよい。
しかし、この方法は `O(N^2)` であるため明らかにTLEしてしまう。

そこで、1文字ずつ減らすのではなく、2分探索で条件を満たす最短の接頭辞を `O(logn)` で見つけることを考えた。
条件を満たす最長の接頭辞から1文字ずつ減らしたとき、どこかで条件を満たさなくなる。
また、条件を満たさなくなってからさらに短くした接頭辞は、同様に条件を満たさない。
このように単調性を有しているため、2分探索が可能となる。

このとき、単にAの中で最短の文字列を起点としてしまうと、 `ng -> ok -> ng` のように、
最初に条件を満たさない区間が存在しうるため、嘘解法となってしまうので注意。
あくまでも2分探索は単調性があるからなりたつものであることを改めて認識する。
（全部が条件を満たしたり、逆に全部が条件を満たさない、というのも単調性のうちなので問題なし。）

[（単調性が満たされないときの2分探索の誤り例。）](./c.jpg)

そこでまず、Aのすべての文字列にヒットする最長の接頭辞を取得することを考える。
自分は当初、Aの中で最短の文字列を起点にして1文字ずつ切り詰めて、それらが条件を満たすか愚直にチェックする（`O(n)`）としていたが、
冷静に考えるとこの部分は最悪 `O(N^2)` となってしまうことに気づかず、TLEしてしまった。

最長の接頭辞候補を見つけるいい方法が自力で浮かばなかったため、じゅっぴーさんのブログを参照してみると、
**検索したい文字列だけを集めてソートすると辞書順に並ぶため、共通の接頭辞を調べるためには、文字列リストの先頭と末尾のものについて、**
**`i` 文字目が一致しているかどうかを見るだけで良い、**
という知見が得られた。
これによって、 `O(n)` で最長の接頭辞が得られることになったため、正解にたどり着けるようになった。

以上をまとめると、

- 最長の接頭辞候補の取得に `O(n)`
- 最短の接頭辞候補の探索に `O(logn)`
- 各接頭辞候補の条件を満たすかどうかのチェックに `O(n)`

となるため、全体の計算量は `O(nlogn)` となり、十分高速に求められた。

（2分探索の条件チェックは愚直にやったため遅くなるかと思ったが、90msecで済んでくれた。
Goはやはり早いほうだと言っていいと思う。）

## C問題のじゅっぴーさんの解法

辞書順についての理解が明瞭という印象を受ける。全体的に方法が賢い。

接頭辞の探索に加えて、ある接頭辞が条件を満たすかどうかのチェックの仕方がうまい。

[辞書順ソートの文字列配列に対する、接頭辞をキーとした文字列でヒットするSの個数の調べ方。](./c.dictionary_order.jpg)

まず、Sを昇順ソートする。
すると図のように、ある候補接頭辞をもつ文字列が並ぶ区間が存在する。
条件を満たすかどうかというのは、 **この区間の文字列の数がちょうど `k` 個であるかどうか** ということになる。
（そもそも候補とする接頭辞が、検索したい文字列にすべてヒットするものとして選んでいるため、
区間にちょうど `k` 個存在するとは、検索したくないものは1つも含んでいないということが言えるため。）

そしてこの区間の個数は、2分探索の `lower_bound` 実装によって取得することができる。
図のように、候補接頭辞に対して `z` をひたすら連結したものをキーとして得られる添字の下限から、
候補接頭辞をキーとして得られる添字の下限を引き算すれば良いことがわかる。

このように、文字列の配列も整数の配列に対する2分探索と同じようなことができるようになる。
（素晴らしい解法。）

。。ただし、自分が当初提出した `z` を100000文字連結したものだとTLEしてしまった。
10000文字だとなんとか通った（600msecぐらいかかる）が、文字列連結はメモリ再取得とかで相当重いのかもしれない。
（このあたりの事象はちゃんと解明しておきたい。）

## C問題の想定解法

公式のPDFはなんか難しく聞こえる。。

[Nominさんのブログ解説](http://noimin.hatenablog.com/entry/2017/12/25/230134)がわかりやすいし、多分、模範解答と同じ方針、多分。

見逃してしまった制約を利用している。

keywordと定義しているものを探すのにも、検索したい文字列以外とkeywordとの共通接頭辞を探すのにも、
`O(（全文字数の和）)` しかかからないというのがポイント。
（文字全部をスキャンするというのを定数回繰り返すだけ。）
