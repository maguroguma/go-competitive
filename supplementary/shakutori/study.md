# しゃくとり法の学習

Last Change: 2020-04-04 15:26:35.

苦手なのでみっちり復習する。

## 参考

- [けんちょんさんの記事](https://qiita.com/drken/items/ecd1a472d3a0e7db8dce)

---

## けんちょんさん

### 以下のような問題で使える可能性がある

- 「条件」を満たす区間のうち、最小の長さ
- 「条件」を満たす区間のうち、最大の長さ
- 「条件」を満たす区間の数え上げ

### 準備: 配列の半開区間について

`[3, 7)` といった半開区間は、指し示すインデックスが **要素間の仕切り** と捉えると良い。

長さ `n` の配列の場合、仕切りは `0 ~ n` の `n+1` 個になることがわかる。

累積和などでも使える考え方なので、頭に入れておきたい。

### 基本アイデア

- 区間の左端leftを固定すると、条件を満たす右端rightは **leftから始まる連続自然数になっている。**
  - 単調性がある。
- あるleftに対して条件を満たす区間の右端rightの最大値を `f(left)` とすると **`f(left)` は広義単調増加関数** となる。
  - やはり単調性がある。
  - つまりは、動かしたrightをバックさせる必要がない、ということ。

**`f(left)` まで求まっているときに次の `f(left+1)` を求めるときは、 `right = f(left)` から出発して**
**条件を満たさなくなるまでインクリメントしていく。**

### 実装案

ここを他人からの受け売りで統一しようとするのは無理がありそう。
なので自己流をしっかり考えたい。

せいぜい以下の部分は覚えてしまっても良いかもしれない。

```go
right := 0
for left := 0; left < n; left++ {
  for right < n && ${cond} {
    ...
    right++
  }
  ...

  if right == left {
    right++
  } else {
    ...
  }
}
```

### 個人的注意点

- leftを進める前の処理は特にそうだが、半開区間（仕切りを指定している）を強く意識すると正しい実装ができる。
  - **「leftとrightが一致することは合っても、処理中にleftがrightを追い越すことは絶対にない」** ということは強く意識すると良い。
- 数え上げなのか、区間長の最大・最小を聞かれているのかは意識する。
  - 問題によっては例外処理が必要なものもある。

### 個人的スニペット

とりあえずは以下のフレームワークを運用してみる

```go
right := 0
for left := 0; left < n; left++ {
  for right < n && ${1:safe-condition} {
    // change condition(right)
    right++
  }

  // query processing

  // preprocessing before preceding LEFT
  if right == left {
    right++
  } else {
    // change condition(left)
  }
}
```
