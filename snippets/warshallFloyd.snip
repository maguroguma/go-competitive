snippet     warshallFloyd
abbr        dp[i][j] = Min(dp[i][j], dp[i][k]+dp[k][j])
options     head
  // AOJ
  // node idは0-based
  // dp[i][i]が負ならばノードiは負の閉路に含まれる
  // dpテーブルの更新に条件がないことに注意（負のコストがある場合初期値の同値判定は不可）

  const MNN = 300
  const INF_30 = 1 << 30

  var v, e int
  var dp [MNN + 5][MNN + 5]int

  // dpをグローバルに設定する必要がある
  func warshallFloyd(n int) {
    // dp[u][v] = e[u][v] or INF
    // dp[i][i] = 0
    for k := 0; k < n; k++ {
      for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
          // 1. 頂点kをちょうど一度通る場合
          // 2. 頂点kを全く通らない場合
          // の排反な2ケースを加味したもの
          dp[i][j] = Min(dp[i][j], dp[i][k]+dp[k][j])
        }
      }
    }
  }

snippet     warshallFloydEx
abbr        dp[k+1][i][j] = Min(dp[k][i][j], dp[k][i][k]+dp[k][k][j])
options     head
  // dpをグローバルに設定する必要がある
  func warshallFloyd() {
    // dp[0][u][v] = e[u][v] or INF
    // dp[0][i][i] = 0
    for k := 0; k <= ${1:#:|V|}; k++ {
      for i := 1; i <= $1; i++ {
        for j := 1; j <= $1; j++ {
          // 1. 頂点kをちょうど一度通る場合
          // 2. 頂点kを全く通らない場合
          // の排反な2ケースを加味したもの
          dp[k+1][i][j] = Min(dp[k][i][j], dp[k][i][k]+dp[k][k][j])
        }
      }
    }
    // 最終的な答えは dp[$1+1][i][j]
  }
