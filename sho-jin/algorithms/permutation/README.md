# 順列・重複順列

- 階乗に関しては `10! == 3628800 > 3M` であるため、使える問題は限られるが、その実装方法は重複順列にも応用できるため重要。
  - `6! == 720, 7! == 5040, 8! == 40320, 9! == 362880` も暗記しておきたい。
- 重複順列は `n**r` の `n` が小さい場合、やはり `r == 10` 程度までなら耐えられる。
  - `3**10 == 59049`
  - ABC114のC問題など、桁関連の全探索には使えるため、習熟しておきたい。
  - 01のビット列もよくよく考えると0と1の重複を許した順列。

## 実装方法

- 再帰関数を使う。
  - 2進数であればビットごとの演算で素直に計算できるのでforループでもできるが、ABC114のC問題など、3進数の場合はやや面倒。
  - とはいえ、10進数からn進数への変換は基本であるため、頭に染み込ませておく。
    - やり方に迷ったら、10進数の各桁をとるときに `10**n` で割ったあまりを取り続けることを思い出せば良い。
- 順列を再帰で生成する関数の実装のtips
  1. 大本となる関数のシグネチャは `func() [][]interface{}`
  2. 大本となる関数で呼び出す再帰関数のシグネチャは `func(interim []interface{}) [][]interface{}`
  3. 大本となる関数で、空のスライスを引数として再帰関数を呼ぶ
  4. 再帰関数では、受け取ったスライスがすでに終了条件を満たしている場合、そのスライスを `[][]interface{}` に単一要素として含め、返り値とする
  5. 再帰関数では、受け取ったスライスのコピースライスを作成した上で、そのコピースライスに追加候補をappendし、それを引数としてさらに再帰関数を呼び出す
  6. 再帰関数では、更に呼ばれた再帰関数の返り値を、空の `[][]interface{}` に対してすべてappendし、それを返り値とする
  7. 3-6でやっていることは、末端の再帰関数で生成された条件を満たすスライスを、大本で1つにまとめる作業であり、最終的に大元の関数で各パターンを表すスライスのスライスが得られる
