# 重み付きグラフ

## 最小全域木

木では、ある頂点 `r` から頂点 `v` まで、必ず1通りの経路がある。

### グラフ `G=(V, E)` の全域木（spanning tree） `G=(V', E')`

グラフのすべての頂点 `V` を含む部分グラフであって（ `V = V'` ）、
木である限りできるだけ多くの辺を持つものを言う。

全域木はあるグラフについて複数存在しうる。

最小全域木（Minimum Spanning Tree）とは、グラフの全域木の中で、
辺の重みの総和が最小のものをいう。

## 最短経路

### 最短経路木

> 次の図のように、辺のコストが非負である重み付きグラフ `G = (V, E)` について、
> 頂点 `s` から `G` のすべての頂点に対してパスがあるとき、
> `s` を根とし、 `s` から `G` のすべての頂点への最短経路を包含する `G` の全域木 `T` が存在します。
> **このような木を最短経路木（shortest path spanning tree）といいます。**

最短経路木は特殊な全域木という認識を持っておきたい。

---

※重み付きグラフでは、エッジがない場合の初期値を `-1` ではなく `INFTY` にすること！

## 最小全域木

螺旋本ではプリム法が最初に紹介されている。

優先度付きキューを使わない実装なため、制約が大きくなると役に立たなくなると思われる。

### プリム法

ダイクストラに似ている方。

いい加減頭に叩き込みたい。

グラフ `G = (V, E)` の頂点全体の集合を `V` 、MSTに属する頂点の集合を `T` とする。

1. `G` から任意の頂点 `r` を選び、それをMSTのルートとして、 `T` に追加する。
2. 次の処理を `T = V` となるまで繰り返す。
  - `T` に属する頂点と `V - T` に属する頂点をつなぐ辺の中で、重みが最小のものである辺 `(pu, u)` を選び、それをMSTの辺とし、 `u` を `T` に追加する。

~~※螺旋本のこのパートで紹介されている方法は逆にややこしく実践的ではない気がするので、あまり気にしないことにする。~~

ダイクストラの `O(|V|^2)` 解法を身につけるために、こちらもちゃんと納得しておく。

2の部分をどう実現するか？の理解が重要。実装レベルではっきりさせるのが重要。

擬似コード

```
// d[n]: d[v]にTに属する頂点とV-Tに属する頂点をつなぐ辺の中で、重みが最小の辺の重みを記録する
//        初期値は無限
//        ノードvはまだTに属していないノード、Tからつながるものでより小さい辺が見つかれば更新される
// color[n]: color[v]にvの訪問状態WHITE, GRAY, BLACKが記録される
//          WHITE: 完全に未探索
//          GRAY: V-Tに属しているが、一度チェック済み（Tからの辺が確認されている）
//          BLACK: Tに属している
//          ※GRAYはなくても問題ない（定義しているのはわかりやすさのため？）

prim():
  init()  // color[u] = WHITE, d[u] = INFTY
  d[0] = 0
  d[0] = -1

  while true:
    // Tに加えるノードuを選定する
    mincost = INFTY
    for i from 0 to n-1:
      if color[i] != BLACK && d[i] < mincost:
        mincost = d[i]
        u = i

    if mincost == INFTY:
      break

    // uをTに加える
    color[u] = BLACK

    // uからv \in (V-T)に対して伸びる辺が最小のものであれば更新する
    for v from 0 to n-1:
      if color[v] != BLACK && (uとvの間に辺がある):
        if M[u][v] < d[v]:
          d[v] = M[u][v]    // d[i]が更新されるのはここだけ！
          p[v] = u
          color[v] = GRAY
```

## 単一始点最短経路

1つ目の問題の螺旋本による解法では、 `O(|V|^2)` 解法が紹介されている。

最短経路木の話も絡むため、擬似コードについてもしっかり書き込む。

### ダイクストラのアルゴリズム（ `O(|V|^2)` ）

グラフ `G = (V, E)` の頂点全体の集合を `V`, 始点を `s`, 最短経路木に含まれる頂点の集合を `S` とする。
各計算ステップで、最短経路木の辺と頂点を選び `S` へ追加していく。

各頂点 `i` について、 `S` 内の頂点のみを経由した `s` から `i` への最短経路のコストを
`d[i]` 、最短経路木における `i` の親を `p[i]` とする。

1. 初期状態で `S` を空にする。
  - `s` に対して `d[s] = 0` と初期化する。
  - `s` 以外の `V` に属するすべての頂点 `i` に対して `d[i] = INFTY` と初期化する。
2. 以下の処理を `S = V` となるまで繰り返す。
  - `V-S` の中から、 `d[u]` が最小である頂点 `u` を選択する。
  - `u` を `S` に追加すると同時に、 `u` に隣接しかつ `V-S` に属するすべての頂点 `v` に対する値を以下のように更新する。
    - `if d[u]+w(u,v) < d[v] then d[v]=d[u]+w(u,v); p[v]=u;`

擬似コード

```
dijkstra(s):
  init()  // color[u] = WHITE, d[u] = INFTY
  d[s] = 0
  p[s] = -1

  while true:
    mincost = INFTY
    for i from 0 to n-1:
      if color[i] != BLACK && d[i] < mincost:
        mincost = d[i]
        u = i

    if mincost == INFTY:
      break

    color[u] = BLACK

    for v from 0 to n-1:
      if color[v] != BLACK && (uとvの間に辺がある):
        if d[u] + M[u][v] < d[v]:
          d[v] = d[u] + M[u][v]
          p[v] = u
          color[v] = GRAY
```

考察（？）

- 優先度付きキューを使うものと違い、ループ開始部分で、最短経路木に含まれないノードのうち `d[i]` が最小なものを「確実に」補足するため、ある意味ムダがなくて優先度付きキューを使うものよりも効率的に働く時がある（？）
  - 優先度付きキューを使う方は、不要な構造体をキューに入れたりポップしたりする手間が必要になる。
  - 基本的には、ノード数が少ない代わりにエッジが張り巡らされているような場合には、こちらの素朴なアルゴリズムが活きてくる（？）
  - 例のABC143のE問題で確認しておきたい。

### ダイクストラのアルゴリズム（ `O( (|V| + |E|) * log(|V|) )` ）

計算量もいい加減覚えたい。

`|V|` の数だけキューから頂点が取り出され、 `|E|` の数だけキューに挿入されるのでこのような計算量になる。

※キューから取り出した最小値が以前の最短値より大きければ無視するが、この部分が計算量増大を大きく抑えている。
※蟻本では `O(|E|log|V|)` となっていたが。。？

やっぱり少し解析が難しい。スキップが重要なことだけは抑える。

擬似コード

```
dijkstra(s):
  init()  // color[u] = WHITE, d[u] = INFTY
  d[s] = 0

  PQ.push(Node(s, 0))   // 優先度付きキューに始点を挿入

  while (PQが空でない):
    u = PQ.extractMin()

    // 優先度付きキューから取り出した時点でSに組み込まれる
    // BLACK -> BLACKの上書きもあるはずだが問題ない
    color[u] = BLACK

    // 最小値を取り出し、それが最短でなければ無視
    if d[u] < (uのコスト):
      continue

    // uに隣接する頂点vが存在する限り
    while (v = next(u)) != NIL:
      if color[v] != BLACK:
        if d[u] + M[u][v] < d[v]:
          d[v] = d[u] + M[u][v]
          color[v] = GRAY
          PQ.push(Node(v, d[v]))
```

