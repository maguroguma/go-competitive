snippet     pascalTriangle
abbr        C[n][r]
options     head
  var C [5001][5001]int
  func InitPascalTriangle(m int) {
    for i := 0; i <= 5000; i++ {
      for j := 0; j <= i; j++ {
        if j == 0 || j == i {
          C[i][j] = 1
        } else {
          C[i][j] = C[i-1][j-1] + C[i-1][j]
          C[i][j] %= m
        }
      }
    }
  }

snippet     pascalTriangleProbabilityVer
abbr        CP[n][r]
options     head
  var CP [5001][5001]float64

  func InitPascalTriangle() {
    CP[0][0] = 1.0
    for i := 1; i <= 5000; i++ {
      for j := 0; j <= i; j++ {
        if j == 0 {
          CP[i][j] = CP[i-1][j] / 2.0
        } else if j == i {
          CP[i][j] = CP[i-1][j-1] / 2.0
        } else {
          CP[i][j] = (CP[i-1][j-1] + CP[i-1][j]) / 2.0
        }
      }
    }
  }

snippet     combinationFactorial
abbr        func (cf *CombFactorial) C(n, r int64) int64
options     head
  // cf := NewCombFactorial(2000000) // maxNum == "maximum n" * 2 (for H(n,r))
  // res := cf.C(n, r) 	// 組み合わせ
  // res := cf.H(n, r) 	// 重複組合せ
  // res := cf.P(n, r) 	// 順列

  type CombFactorial struct {
    factorial, invFactorial []${1:int64}
    maxNum                  $1
  }

  func NewCombFactorial(maxNum $1) *CombFactorial {
    cf := new(CombFactorial)
    cf.maxNum = maxNum
    cf.factorial = make([]$1, maxNum+50)
    cf.invFactorial = make([]$1, maxNum+50)
    cf.initCF()

    return cf
  }
  func (c *CombFactorial) modInv(a $1) $1 {
    return c.modpow(a, MOD-2)
  }
  func (c *CombFactorial) modpow(a, e $1) $1 {
    if e == 0 {
      return 1
    }

    if e%2 == 0 {
      halfE := e / 2
      half := c.modpow(a, halfE)
      return half * half % MOD
    }

    return a * c.modpow(a, e-1) % MOD
  }
  func (c *CombFactorial) initCF() {
    var i $1

    for i = 0; i <= c.maxNum; i++ {
      if i == 0 {
        c.factorial[i] = 1
        c.invFactorial[i] = c.modInv(c.factorial[i])
        continue
      }

      num := i * c.factorial[i-1]
      num %= MOD
      c.factorial[i] = num
      c.invFactorial[i] = c.modInv(c.factorial[i])
    }
  }
  func (c *CombFactorial) C(n, r $1) $1 {
    var res $1

    res = 1
    res *= c.factorial[n]
    res %= MOD
    res *= c.invFactorial[r]
    res %= MOD
    res *= c.invFactorial[n-r]
    res %= MOD

    return res
  }
  func (c *CombFactorial) P(n, r $1) $1 {
    var res $1

    res = 1
    res *= c.factorial[n]
    res %= MOD
    res *= c.invFactorial[n-r]
    res %= MOD

    return res
  }
  func (c *CombFactorial) H(n, r $1) $1 {
    return c.C(n-1+r, r)
  }
