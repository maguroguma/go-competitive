# 3-2: 厳選！頻出テクニック(1)

---

## しゃくとり法

- スライスの連続区間の和がK以上となる区間の長さの最小値を答える問題。
- スライスの連続区間のうち、すべての要素が含まれている区間で最小のものの長さを答える問題。

単調性＋区間が問われたら想起したい。

---

## 反転・flip

（おそらく応用の効く）重要な考察は以下の2点。

1. 同じマスを2回以上選択する必要はない
2. 選択したマスの集合を考えたときに、その反転順序は無関係

これらはいずれも、 **あるマスに対して反転操作が施される回数** を考えれば自明に感じられる。
（結局、そのマスの状態は、そのマスの初期値および反転操作の偶奇性のみで決定されるため。）

また、最小の操作回数が聞かれることが多いと思われるが、上の2つの性質を考えると自然と最小回数の操作を考えることになる。
（1の性質を念頭に置くことで、自然と最小回数の操作を考えることになるので、気にする必要がなくなる。）

そこから派生するその他の注意点としては、

1. 一度の操作で複数のパネルが反転する場合、中心として考えるマス目をうまく選択する
  - 例えばパネル列に対して複数の連続するパネルの反転を考えるなら、反転するパネル列の一番左を考えるのが定石（？）
2. 中心となるマスを決めたら、操作を施すマス目の集合を考える
  - これによって全探索ベースの手法が考察できる（そこから計算量を落としていくのは一つの典型（？））

### 実装面での注意

蟻本の例題はどちらも面白いのでやっておいたほうがいい。

やってみて思った感想。

- パネルの状態は2値で表されるので、最初に0,1に符号化してしまう
  - こうすると操作回数の偶奇性と併せて計算が用意になる（コードがシンプルになる）
  - 最終的なほしい状態を `0` とするのが定石か（？）
- 操作が複雑になってくると、「あるパネルの状態を調べる関数」をモジュールとして切り出しておいたほうがよい。
  - 2次元パネル行列になってくると必要性が増してくるかも
- メモリは贅沢に使う気持ちで実装したほうがいいかもしれない
  - 例題の「作業用・最適解保存用」行列を分けて用意しておくのは賢いと思った

---

## 弾性衝突

序章の蟻問題と同じ考え方。

自由落下の公式をもう覚えていないため、計算に骨が折れるが、とりあえずは考え方だけ理解しておく。

これも例題のモジュールの切り方が参考になる。

---

## 半分全列挙

> このように、全パターンを列挙することができないようなサイズの問題でも、
> 半分ならば全列挙を行うことができるような場合があります。
> このような場合、それぞれ半分ずつ全列挙されたものを組み合わせるという手法が有効なことがよくあります。

2分探索、特に昇順ソート済み配列に対するupperBoundとlowerBound関数が必要になることが多い、のかもしれない。

### 巨大ナップサックの例題

2つのフィールドをもつ構造体（いわゆるpair）について、1つ目について昇順、2つ目については1つ目が同じ値ならばその中で昇順、というような場合に、
1つ目のフィールドについて昇順が保証されているため、それに従属して2つ目も昇順となるように「不要な」要素を取り除くやり方は、他にも応用がききそうだと思った。

（説明が難しい。。）

---

## 座標圧縮

コードと説明だけだとちょっとよくわからなかった。。

[このスライド](https://www.slideshare.net/hcpc_hokudai/za-atsu20170328)がかなり丁寧でわかりやすい。

また、C++のuniqueやeraseといったvectorのメソッドがよくわからなかったが、
それらについては[Qiitaのこちらの記事](https://qiita.com/ysk24ok/items/30ae72f4f1060b088588)_が簡素でわかりやすかった。

### まずは1次元から

1次元のABC036のC問題から考えるのがよい。

大小関係を保ったまま、0以上の値（座標）でできる限り小さく圧縮する方法。

**ソートすればよい！！**

- 座圧するには **ソートと再割り当てが基本** で、計算量は `O(NlogN)`
- 座圧後の座標幅は `O(N)`
  - 要素数がそのまま座標値に効いてくる

### 問題の2次元

**各端点の座標を使って座圧すればよい！！**

- そのまま端点だけを使ってしまうと、本来置いておくべき隙間まで埋められてしまう部分があり、題意にそぐわない座圧をしてしまうことになる。
- 1次元と同じく、1つの軸については座標幅は `O(N)` となるため、領域サイズは `O(N^2)` となり、これならば全探索できるようになる！

### 例題の実装

C++の使用されているメソッドについて、該当するものがGolangでちょっと思いつかなかったので、
定数倍の範囲で非効率となってしまうが、mapを使う方向で実装してみた。

**おそらく、今回の問題のようにもともとの領域が十分に大きくない場合は、思ったように圧縮されない。**

