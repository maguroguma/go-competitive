# ABC116感想

- A問題は珍しく入力を一つ使わなくても解ける問題。
  - Goは使わない変数があるとCEするので、 `_` で受け取らなければいけないのを思い出す。
- B問題はちょっと解釈するのに時間がかかってしまったが、落ち着いて解くほうが大事なのでOK。
  - [コラッツの問題](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%A9%E3%83%83%E3%83%84%E3%81%AE%E5%95%8F%E9%A1%8C)なるものらしい。
    - 初項によらず収束する（？）のは確かに不思議で面白い。
      - 余談：コラッツ問題の概要を知っていると半分以下の時間でACできそうな気がする。
- C問題はかなり時間がかかってしまった。
  - Dが難しくて正解者が少なかったため、もったいなかった。
  - 水色になるまではCの安定速解きが最重要なのを再認識。
  - 自分はシミュレーションでやったが、シミュレーションを書くときはアルゴリズムを日本語で整理しきってから書くと良いのかもしれない（？）
    - **こういった問題を早く解くためにはどうすべきだったかを反省すること。**
  - ~~PDFにあるようなスマートな解法も理解すること。~~
    - PDFは証明をきっちりやってくれているもの（多分）。
  - 解説放送のすぬけさんのやり方は面白いし参考になりそうだが、自分の脳にはあまりなじまなかった。
- D問題は実装も大変な貪欲法。
  - 模範解答のやり方だと、priority queueが必要だったりする。
    - 解説ブログなどを散策すると、累積和などを使って解く方法もある模様。
  - 「自分で自然な想起をするにはどこがポイントになるか？」はちょっとむずかしい（貪欲法なのでそういうものかもしれないが）。
    - 種類数を固定してそのときの満足ポイントの最大値を（何らかの方法で効率的に）求め、最後に全種類数に渡ってチェックし、最大のものを答えとして採用する。
      - [ARMERIAさんのブログ解説](https://betrue12.hateblo.jp/entry/2019/01/24/210857)の方法。個人的には解説PDFの手法よりもしっくり来る。
      - しかし、この方法は計算量の見積もりが難しいように思える（ソートも多用する必要がある（ように見える）ため、結構怪しい気がしてしまう）
        - 実装力が十分にあっても本番ではなかなか手を動かし始めづらい解法に思える。
      - **k種類確保した後の選択に関しては、全部の種類の寿司をまとめずに、それぞれの種類に関して2番手以降を「比較しながら」みていけば、なんとか実装できそう。**
  - なんとなくだが、貪欲法で解くタイプの問題は、コードを書きながら考えると明後日の方向へ向かいやすい気がする。
  - 解法がわかってもとにかく実装がつらい。
    - 結局の所、priority queueを使う実装方法はよくわからない。。
  - [moheiさんのコード](https://atcoder.jp/contests/abc116/submissions/4068133)が、考え方もコードも一番簡潔に感じられた。
    - 最も貪欲法っぽいコードに見える。
    - わかりやすいと入っても、管理すべき変数がかなり多く、本番で1発で通すのは至難に思われるので、もっと簡潔なコードがあれば知りたいところ。

---

## 自分がやったC問題の実装

コンテスト中に慌てて通したコードは余計なものがあって分かりづらかったため、後日整理したやり方。

```go
maxHight := Max(H...)
ans := 0
for i := 0; i < maxHight; i++ {

  for j := 0; j < n; j++ {
    if H[j] > 0 {
      H[j]--

      if (j+1 < n && H[j+1] == 0) || j+1 == n {
        ans++
      }
    }
  }

}
```

`ans` のインクリメントするタイミングが難しくて本番では時間がかかってしまった。

水をやり始めたタイミング＝非ゼロな高さに出会ったらインクリメントするのが自然だったのでそうしたかったが、
走査する過程で直前の花を枯らせてしまい、直前がもともと高さゼロだったのか、もしくは本来1以上の高さが連続していたが直前にゼロまで枯らせてしまったのか、
判断できなくなり困ってしまった。

なので、高さがゼロ

---

## 懐古DPさんのC問題の解き方・実装

twitterでおみかけしたもの。とてもスマートなやりかた。
こういう方法にはなにか名前とかあったりするんだろうか？

**直前の花の高さと比較して、自分の方が高かったらその差分を加算するだけ。**
確かに数えたいブロックの数が正しく数えられていることになる。

```go
ans := 0
for i := 0; i < n; i++ {
  if i == 0 {
    ans += H[i]
    continue
  }

  ans += Max(H[i]-H[i-1], 0)
}
```

