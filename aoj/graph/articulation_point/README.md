# 関節点

## 定義

連結グラフ `G` において、頂点 `u` とそこから出ているすべてのエッジを削除して得られる部分グラフが、
非連結になるとき、頂点 `u` をグラフ `G` の関節点（Articulation Point）または切断点と呼ぶ。

## 関節点の列挙アルゴリズム

※意外とややこしい（と思う）。

一回のDFSで効率的に検出できる。

### アルゴリズムにおけるデータ定義

DFS木, DFS tree: DFSによって生成される木のこと。以下では `T` で表す。

`preNum[u]`: `G`の任意の頂点を始点としてDFSを行い、各頂点 `u` の訪問（発見）の順番を `preNum[u]` に記録する。
preorderでの発見順なので `preNum` とする。

`parent[u]`: DFS木における `u` の親を `parent[u]` に記録する。

**`lowest[u]`**: 最重要。各頂点 `u` に対して、以下のうちの最小値として `lowest[u]` を計算する。

1. `preNum[u]`
2. `G` の `BackEdge(u, v)` が存在する場合の `preNum[v]`
  - `BackEdge(u, v)` とは、頂点 `u` から `T` に属する頂点 `v` に向かう `T` に属さない `G` のエッジ。
    - 親とつなぐエッジは `T` に属するため、BackEdgeではない。
  - 言い換えると、DFSで到達済みのノードに至る辺のこと（であっているはず）
3. `T` に属する頂点 `u` のすべての子 `x` についての `lowest[x]`
  - BackEdgeが `u` になくても、 `u` の子 `x` がBackEdgeを持つのであれば、そこから可能な限り `lowest` を更新する。

※ `lowest` の自己解釈は、「DFS木に組み込まれるノードで、到達可能な祖先（上の方）」というイメージ。

※3の手順は、DFSのpostorderの処理によって、うまく子以下すべてを考慮した上で更新ができるようになっている。

### アルゴリズム

`T` のルート `r` が2つ以上の子供を持つとき（必要十分条件）、 `r` は関節点。

各頂点 `u` において、 `u` の親 `parent[u]` を `p` とすると、
`preNum[p] <= lowest[u]` ならば（必要十分条件）、
`p` は関節点（ `p` がルートの場合は前述の条件を適用する）。

※2つ目は、頂点 `u`, `T` における `u` の子孫から頂点 `p` の祖先へのエッジが無いことを示す。

※自己解釈としては、 `lowest[u]` というのは、頂点 `u` から到達できるDFS木の祖先ノードIDといえる。
そのため、この祖先ノードIDが親 `p` の行きがけの到達順序以上の場合、 `p` がなくなってしまうと、
`u` から `p` よりDFS木の上方のノードに到達できないと言えるので、 `p` が関節点であると主張できる。

