# Who Says a Pun?

LCS(Longest Common **Substring**) の問題。
部分列の方とは考え方がかなり違うので、知らないとちょっとつらい。

とはいえ、部分列の方よりも遷移は単純だと思う。

`dp[i][j]: S[i], T[j]がそれぞれの共通の部分文字列の何文字目か（共通部分文字列に含まれないのなら0）`

このように状態を定義すると、現在注目中の文字が等しいときの遷移のみを気にするだけで良い。

```go
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			if S[i] == S[j] {
				ChMax(&dp[i+1][j+1], dp[i][j]+1)
			}
		}
	}
```

本問題の解き方としては、与えられた文字列は1つだけだが、2つ同じ文字列が与えられたつもりで、
DPテーブルを埋めていく。

そして、最後の解の探索時に `j-i >= dp[i][j]` という条件を満たすものだけを集める。
`j >= i` と仮定すると、 `dp[i][j]` が共通部分文字列の長さを表していることから、
**`i, j` が終点の長さ `dp[i][j]` の文字列は、同じ元の文字列に含まれていながら、共通部分を持たない**
と主張できる。

よって、条件を満たすものの中から、最大のものを見つけてくれば良い。

参考: [Longest Common Substring](https://qiita.com/_rdtr/items/b80cecac36451dbaee60)

※substringの例題がないのは、DPじゃなくても他の優れた文字列アルゴリズムで解けてしまうからだろうか？
（実際この問題はZ-Algorithmやローリングハッシュを使って解くことが想定解法になっている。）
