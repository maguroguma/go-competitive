# ABC129 感想

1時間弱の1ペナ4完でパフォ1290ほど。
Eを解かないとレートは上がらない厳しい戦い。

今回は基礎的な実装が疎かになった影響がモロに出てしまった。

- A問題はありうるパターンを全部手書きすればよい。
- B問題はスライスを使ってforループ使わずにきれいに書きたかったが、何故かバグった。
  - コンテスト後に境目に気をつける形で書いたらちゃんと書けた。練習不足。
- C問題は典型的なDP。壊れている段差では遷移を止めてやれば良い。
  - 壊れている段差の探索に2分探索を書いてしかもバグらせてしまうという大失態。
    - **条件の境界となる場所が求まるだけなので、keyの存在判定はちゃんと最後にif文でチェックしないとダメ！**
    - ここで気づけてよかったと思っておこう。
  - 実際には壊れている段差のチェックは辞書を使うのが楽。
  - **実装テクニック: 離散的な値の存在チェックは配列がベスト！スパースで上限・下限が大きすぎるときは辞書！**
    - 今回は100000までの数値だったので、配列を使っておけばとてもスムーズに書けたはず。
- D問題は累積和的に解いたが、かなり重たい実装になってしまった気がするので、解説をチェックしたい。
  - **典型: 壁・障害物のある2次元グリッドで各マスの上下左右に進めるマス目を前処理する**
    - なんか以前にもこのような問題を解いたはずだが、わすれてしまった。。
      - 思い出したらまとめておきたい。
- E問題は桁DP的な解き方と組み合わせで素直に解く方法療法があるっぽいので、どちらともちゃんと復習したい。
  - 桁DPの手法を理解する前に、XXORやIntegerotSなどで使ったような手法を応用して解いた。
    - 実際にはこのやり方でやった人が多かったっぽい。
  - **典型: ビット桁DPならば上から値を固定する形で進める。1だったなら0にすると以降をすべて自由に動かせて、0ならばそのまま進む。考えている数は排他的になっていることを要認識！**
    - 本番では排他的になっているところが見えなくてダメだった。
  - **典型: 極端に大きな指数の計算は `modpow` で `O(log(桁数))` で計算可能！**
    - これもちゃんと認識していないと無駄に時間を食うことになりかねない。

## D問題: 2次元グリッドの経路に関する累積和（？）

なんと命名すればよいか微妙だが、しばしば以下のようなコードを書くことがあるので、
スニペットを貼っておく。

累積的に計算する方法は未だに馴染みきっていない気がするので、反省したい。

```go
	for i := 0; i < h; i++ {
		for j := 0; j < w; j++ {
			if S[i][j] == '#' {
				L[i][j] = 0
				continue
			}

			if j == 0 {
				L[i][j] = 1
			} else {
        // ここ！
				L[i][j] = L[i][j-1] + 1
			}
		}
	}
```

今回のコードはどうあがいても長くなる気がするが。。

## E問題: 桁DPで解き直した

今回も `1->1, 0->1, 0->0` に注意して書けた。

桁DPで特にしても本質的に理解しなければいけない部分（すなわち和を確定させながら場合の数を考える部分）は変わらないが、
桁DPに自信が持てれば、この部分の発想を自然にできたかもしれないので、やはり重要な考え方だと思う。

桁DP自体は、考えている数値で係数を変えるところがポイントだったと思う。

