# 木構造

## 根付き木

> 根と呼ばれる他と区別された1つの接点を持つ木を根付き木と呼びます。

> 根付き木には親子関係があります。

> 同一の親を持つ接点を兄弟（sibling）と呼びます。

> 図のように、根は親を持たない唯一の接点です。
> 子を持たない接点は外部接点（external node）または葉（left）と呼ばれます。
> 葉でない接点を内部接点（internal node）と呼びます。

> 根付き木の接点 `x` の **子の数を `x` の次数（degree）と呼びます。**
> 子を持たない場合、次数は0になります。

※勘違いをしていた。。

> **根 `r` から接点 `x` までの経路の長さを `x` の深さ（depth）**と呼びます。
> また、 **接点 `x` から葉までの経路の長さの最大値を接点 `x` の高さ（height）と呼びます。**
> 根の高さが最も高くなり、それを **木の高さ** と呼びます。

※このあたりもちょっと忘れていた気がする。

### 実装

下のような構造体を作るとよい。

```go
type Node struct {
  parent, leftChild, rightSibling int
}
```

## 二分木

> 1つの根を持ちすべての接点についてその子の数が2 **以下** である木を根付き木と言います。

> 二分木では、接点が持つ子の数が2つ以下となりますが、左の子と右の子は区別されます。

> 子に順序性がある木を順序木と呼びます。

※順序木はちょっとよくわからない。

> 二分木は再帰的に定義することができ、以下のいずれかの条件を満たす木です。

- `T` は接点を全く持たない。
- `T` は共通要素をもたない次の3つの頂点集合から構成される：
  - 根
  - 左部分木と呼ばれる二分木
  - 右部分木と呼ばれる二分木

### 実装

> 接点の数に変化がない二分木は、例えば次のような構造体の配列として実装することができます。

```go
type Node struct {
  parent, left, right int
}
```

> この実装では、次の図のように接点が子を持たない場合は `left` あるいは `right` に `NIL` を設定します。
> `NIL` には `-1` などの接点番号として使用しない値を設定しておきます。
> **これらは番兵としての役割を果たします。**

## 木の復元（PreOrderとInOrderの情報からの復元）

PreOrderとInOrderの情報を行き来することで、根から順番に左部分木と右部分木（の根）がわかるため、
再帰的に復元できるというもの。
面白い。

各再帰関数の呼び出しで、Order配列の線形探索が必要になるため、計算量は `O(N^2)` となる。

※ `reconstruction` 再帰関数は `l, r` を `[l, r)` の半開区間で定義していることに注意。

※変数 `pos` の扱い（解釈？）がちょっとむずかしい気がするが、
二分木において左と右を比べたとき **左のほうが順序が先** という原則を認識しておくと、スッキリする気がする。

