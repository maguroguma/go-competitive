# 3-3: さまざまなデータ構造を操ろう

---

## セグメント木

### セグメント木の概念

- 区間を扱うのが得意なデータ構造
- 完全二分木で、各節点は区間を管理する
  - 根は区間全体を管理する
  - 各節点の子は親の区間を二等分した2つの区間の一方を管理する
- **n個の要素があるとき、区間に対する操作を `O(logn)` で行えることが特徴**
- **各節点に「どのようなデータをもたせるか」によって、いろいろな機能をもつセグメント木を作ることができる**

#### 自分用メモ

- `O(logn)` なのは木の高さ分だけの処理で済むから

### セグメント木によるRMQの仕組み

次の2つの処理を `O(logn)` で実現することを目指す。

- `s, t` が与えられたとき、 `[s, t]` のAの要素の最小値を求める
- `i, x` が与えられたとき、 `A[i]` の値を `x` に変更する

#### 配列による実装

実装に関して、要点を整理したのでまとめておく。
RMQ以外の場合はその都度学んでいく。

完全二分木に対する操作にも馴染むことになるため、よく理解しておきたい。

- 要素数nが2べきの数である場合、セグ木全体のノード数は `2n-1` になるため、配列長もそれだけ必要になる。
- セグ木上の `k` 番目の要素に該当する葉ノードへの移動方法は `k += (n-1)`
  - これは、葉ノード以外の根を含めた中間ノードの数が `n/2 + n/4 + n/8 + ... + n/n = n-1` であるため！
- セグ木上の `k` 番目のノードから親ノードへの移動は `(k-1)/2` でよい。
  - 確かめれば正しいことはわかるものの、理由を説明するのは難しい（自分はわからなかった）ので、とりあえずそういうものだと思っておく。
- セグ木上の `k` 番目のノードの2つの子ノードへの移動は、左の子ノードは `2k+1` 右の子ノードは `2k+2` でよい。
  - 親と同じくそういうものだと思っておく。
  - 忘れてしまったら、高さ3ぐらいの小さなセグ木を書いてみて、実際に0-basedで番号を割り振ってみて調べてもいい気がする。
- query関数で登場する区間はすべて半開区間である点に注意！
  - 大本の最小値を知りたいクエリ区間は `[a, b)` だし、 `k` 番目の左端と右端によって示される区間も `[l, r)` のような形になる。
  - ここらへんは間違えやすそうなところなので、経験を積んで自分なりにベストプラクティスを見つけたい。

これらが整理できていると、RMQのupdateに関しては自然と理解できる。
queryの方も関数のシグニチャ（方針）がわかれば自然とわかるはず。

#### RMQセグメント木のverify

[AOJのこの問題](https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_A)を素直にやるのがいいと思う。

#### RSQセグメント木のverify

RSQ: Range Sum Query

基本はRMQと同じ。

[AOJのこの問題](https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_B)を素直にやるのがいいと思う。

#### tsutajさんのブログ記事

[このブログ記事](http://tsutaj.hatenablog.com/entry/2017/03/29/204841)は自分も考えたような内容が丁寧にトレースされておりとてもよかった。

