# 再帰・分割統治法

> 再帰のテクニックを用いると、ある問題を2つ以上の小さい問題に分割して、
> 再帰関数によりそれぞれの部分問題の解を求め、それらの結果を統合することにより、
> もとの問題の解を求めることができる場合があります。
> このようなプログラミング手法を **分割統治法(Divide and Conquer)** と呼び、以下の手順に基づきアルゴリズムが実装されます。

```
findMaximum(A, l, r)
  m = (l + r) / 2   // Divide
  if l == r-1       // 要素が一つ
    return A[l]
  else
    u = findMaximum(A, l, m)  // 前半の部分問題をSolve
    v = findMaximum(A, m, r)  // 後半の部分問題をSolve
    x = max(u, v)
  return x
```

## コッホ曲線

反時計周りの回転行列はちゃんと思い出して記憶し直しておいたほうが良さそう。

```
x' = cos*x + (-sin)*y
y' = sin*x + cos*y
```

この問題は数B程度の幾何を思い出すのには良い問題かもしれない。

## マージソート

> マージソートは、すでにマージ済みの2つの配列をマージするアルゴリズム `merge` が基礎になっています。
> それぞれ `n1, n2` 個の整数が格納された配列 `L, R` を配列 `A` にマージすることを考えます。
> `L, R` はそれぞれ昇順に整列されているものとし、 `L, R` のすべての要素をそれらが昇順になるように `A` にコピーします。

> ここで重要なことは、 `L, R` を連結したあとに通常のソートアルゴリズムを適用するのではなく、
> それぞれソート済みということを利用し、計算効率が `O(n1 + n2)` となるようなマージのアルゴリズムにすることです。

※ `L, R` それぞれを一方向にのみ進み続けられるため、この計算量になる。

※番兵を含めることで実装が簡略化される。

※高さがだいたい指数オーダーで、各高さで最大でもとの配列の要素数分の比較が行われるため、全体で `NlogN` となる。

> マージソートは離れた要素同士を比較しますが、直接交換することはありません。
> **前半と後半のソート済み配列をマージする処理で、対象となる2つの要素が同じ場合は常に前半の部分配列の要素を優先させれば、同じ値の要素の順番が入れ替わることはないので、マージソートは安定なソートアルゴリズムです。**

> マージソートは高速で安定なアルゴリズムですが、入力データを保持する配列以外に、一時的なメモリ領域が必要になる特徴を持ちます。

## 反転数

蟻本ではBITを使って求めているが、マージソートの計算過程で求めることもできる。

