# E8くんの100問セット

Last Change: 2020-08-28 01:22:52.

[Qiitaのこれ](https://qiita.com/e869120/items/eb50fdaece12be418faa#2-3-%E5%88%86%E9%87%8E%E5%88%A5%E5%88%9D%E4%B8%AD%E7%B4%9A%E8%80%85%E3%81%8C%E8%A7%A3%E3%81%8F%E3%81%B9%E3%81%8D%E9%81%8E%E5%8E%BB%E5%95%8F%E7%B2%BE%E9%81%B8-100-%E5%95%8F)
を解いていく。

## 001

制約の記載が不足している気がするが、普通にやれば通る。

## 002

約数列挙のライブラリの検証にでも。

## 003

今となっては難しいABC-Bのような気がする。

## 004

初めて解いたが、素直な全探索で良い。

## 005

ちょっとむずかしいが、ちゃんと模範解答通りだったので一安心。

## 006

この問題のように、「何について全探索するか？」というのを考えて工夫するのは大事。
当時参加していたときもちゃんと解けたが、当時よりもシンプルなコードが書けていたのは良い。

## 007: ★

方針建てるのもそうだが、バグらせたりして、かなり時間がかかってしまった。

3000個の格子点が与えられるので、その中から得られる正方形の内、最大のものを答える問題。

2点さえ決まれば、回転座標を利用してそこから正方形が作れるかどうかは判定できる。
。。と思ったが、実際には2点というよりは「あるベクトルが決まると確定する」という構造になっている（はず）。
まず、そこで全探索範囲をミスらないようにする必要がある。

こういった幾何の問題では、「自分が今どのような量を求めているのか？」というのを特に忘れないようにしたい。
さもなくば、迷子になってしまうことがある。

## 008: ★

これはかなり難しい気がする。
全探索というよりは、貪欲法のようにみえる。

正しく証明しようと思うと、絶対値の和の最小化を考える必要がある。
（スライドを読んでもこれの証明がよくわからず。。）

## 009

007に似ているが、こちらはだいぶ簡単だと思う。

## 010

ここからビット全探索。

クエリ形式なので、出てきた計算結果はメモしておく必要がある。

※この問題で、ktateishさんのbit全探索抽象化関数を拝借してみたが、非常に便利だった。

## 011

めんどうなだけで整理すると簡単。

## 012

抽象化していると、少し関数式に迷うぐらいで、簡単。

## 013

片方の軸のみビット全探索して、もう片方の軸は貪欲に考える、というのは、
ABCのE問題でもあった（チョコレートを最適に分割するやつ）。

ただし、実装はこちらのほうが圧倒的に簡単。

## 014

「ビット全探索である」と言われると簡単に思えてしまう問題な気がする。
前情報がなくても、極端な制約をみてちゃんときづけること！

## 015

順列全探索というカテゴリ。

浮動小数点が絡むのでめんどくさいが、やるだけ。

## 016

順列を辞書順に列挙するのをデフォルトにしておくと良い。

## 017: ★

手をつけるまでめちゃくちゃめんどくさく感じるが、計算量的に贅沢をすると結構シンプルになる。

構造体をキーとしたハッシュマップを使うと良い。

**※順列全列挙は `n=8` という制約のときに敏感になりたい。**
（`10! >= 3.5M` なので、 `n=10` ぐらいになるとむしろビット全探索のほうが有力になる。）

## 018

ここから二分探索。

この問題は「異なる数字の数」なので、二分探索でやろうとはあまりならない気がする。
しかし、めぐる式二分探索のような、抽象化した関数の練習には良い。

## 019: ★

二分探索という前情報がないと結構難しいかもしれない。
基本中の基本だが、二分探索は近傍のインデックスを求める手段だというのを、常に忘れずに。

円環上の問題は少しやっていて怖いが、この問題は一発で通せたので、それほどでもないけど。
とはいえ、紙の上での考察がないとちょっとつらい。

## 023

半分全列挙。

`n=40` でビット全探索＋半分全列挙みたいなのが主流だと思っていたが、こういうのもあるので注意したい。

## 024: ★

ここからDFS（深さ優先探索）。

この問題は基本中の基本だが、意外と普通の競プロの問題よりも正しく実装するのが大変。
ポインタ引数を用いるよりも、競プロ的にはグローバル変数に頼ってしまうほうが簡単かも。

「有向グラフのDFSは意外と大変」というのはちゃんと覚えておきたい。

## 025: ★

蟻本でもある、2次元グリッドの連結成分をDFSで求めるもの。

union findも重要な手法だが、DFSも問題に合わせて素早く、正しく実装できるのが安心。

## 026

累積和＋DFSみたいな問題で、いわゆる教育的という感触がある。

簡単だが、ふと読んだPDFにかかれている、以下のevimaさんのアドバイスは有用かもしれない。

> このような木に関する問題では、木の代わりに `1 − 2 − 3 − . . . − N` という直線的なグラフを考えると助け
> になることがあり、今回はその好例です。

## 027: ★★

めっちゃ難しい気がする、主に計算量解析が。

企業コンであった、いちごのケーキを切り分ける問題っぽい再帰を行う。

復習したほうがよく、そのときは解説をちゃんと読んだほうがいいが、なぜこれで間に合うのかがよくわからない。。

## 028

ここからBFS（幅優先探索）。

この問題のように、最短距離の基本はBFSであると心得る。

## 029

グリッドをBFSする。

グリッドを隣接リストのグラフに変換するライブラリや、
隣接リストグラフのBFSによる単一始点最短経路ライブラリのverifyに最適な問題。

## 030

これも029と同様に、verifyに便利。

たかだか10回BFS全探索をするだけなので、ある意味愚直にやれば良い。

## 031: ★

少し実装が重いという前情報があったが、割と整理してきれいに書けたと思う。

グリッドのBFSの亜種だが、テーブル構造が特殊なので、グラフ化しようとせずに素直にBFSを組んだほうが早そう。
（グラフを作るのも悪くなさそうだけど。）

グリッドのBFSは、キューに突っ込んだ時点でチェック済みになることに注意！
ダイクストラの感覚でやってはいけない。
（あちらはキューに突っ込んだ後も更新の可能性があるから、キューから取り出したときにフラグ更新する。）

## 032: ★（もうやらなくていい）

迷路の組み方が特殊だが、めんどくさいのでもうやらなくて大丈夫。

※グリッドを隣接リストに変換する手法のありがたさがわかる問題。

## 033

今回が3回目だが、過去2回WAを出していたのに対して、今回はちゃんと一発で通せた。

ややこしい数え上げなどせずに、ちゃんと経路復元して素直に1つずつ丁寧に数えるのが安全。

## 034

ここからしばらくはDP。

フィボナッチ数も立派なDPの問題（数え上げDPに該当する？）。

一応、分類はナップザックDPらしい。

## 035

もっとも基本的なナップザックDP。

## 036: ★

個数制限なしのナップザック問題。

基本問題とはいうものの、今再復習しても結構難しいと思う。
DAGを正しくイメージして、無駄をなくせないか？という思考をする上での基礎としたい。

## 037: ★

036と設定や求める量が異なるだけで、状態の考え方は似ており、また遷移は全く同じ。

## 038: ★

LCSを簡単に思える日は来るのだろうか。。

というか、LCSはナップザックDPの分類らしい。
遷移において、片方のidxの差が1のものはすべてナップザックDPなんだろうか？

## 039

先の基本問題よりは簡単だと思うが、面白い。

JOIの問題は大変なものも多いが、問題文が面白いと思う。

## 040

ABCであった、AGCTの文字列を避けるDP？みたいな問題だと思った。

とはいえ、個人的にはこちらのほうがだいぶ簡単だと思う。

## 041

これも素直に状態定義を考えれば、正しい解法に達する事ができる。

※どうも「各日の服の候補のうち、 `C[j]` が最大もしくは最小のものの2通りのみを試す」という方法も正しいらしい。
当然、証明無しでやるのは危険。

## 042

簡単だけど、なぜか添字がごっちゃになる気がする。

## 043

簡単。

## 044: ★★

初めてこのシリーズでわからない問題が出てきた。

けんちょんさんの記事をみて気づいたが、所詮は「個数制限なしのナップザック問題」に過ぎなかった。

考える必要のある正四面体数の数はかなり小さいことに注意すれば気付ける（というかcube rootなのはすぐ気づいたのに。。）。

この問題はメモリ制約が厳しいので、DP配列のメモリを節約する必要があるので、その練習にもいいかもしれない。

## 045

問題設定は複雑に見えるが、素直にナップザックDPをやるだけでよい。

初期値の条件を見逃したせいで、めちゃくちゃWAに悩まされた。
油断せず問題文はしっかり読もう。

ここでナップザックDPは終わり。

## 046: ★

ここからは「区間DP」と呼ばれるものになる。

一番の基本形は「連鎖行列積」と呼ばれる、行列の積において整数の掛け算の回数を最小化する問題。
基本なのに結構難しい。。

まず、 `A[n][m] * A[m][l]` の行列の積の掛け算の回数は `n*m*l` となるのは、もはや知識としてしまう。

区間DPでは `dp[i][j] := i番目からj番目までの行列の積で回数最小のものを記憶` とする。
これは掛け算のパターンをすべて試せばわかり、区間 `(i, j)` が決まると、その間の `k` を全探索すれば良い。

よって、この区間DPは計算量が `O(N^3)` となる。

## 047: ★★★

ここまでで一番難しく、答えをみてしまったが、面白い。

区間DPとしてもいい問題だろうけど、それ以上に円環を扱う問題の対策を学べる問題としていいと思った。

模範解答のコードを読んでみたり、おまけの方法でやってみるのも学びがあるはず。
時間をおいてから復習したい。

**円環のインデックスをそのまま扱うのは、すぬけさんレベルでもめんどくさいらしい（？）。**
**まずは直線に直せないか？という考察を行いたい。**

## 048: ★★★

これもやはり難しい。

`O(N^3)` の区間DPだが、直感的に遷移がすべて網羅できているのかどうか？というのが不安に感じられてしまう気がする。

**「区間の除去」みたいな問題は区間DPの典型的な設定であるとのこと。**

- [けんちょんさんの解説](https://drken1215.hatenablog.com/entry/2020/03/10/160500)
- [kamiさん？のブログ](https://algo-logic.info/range-dp/)

## 049: ★

ここからはbitDP。

巡回セールスマン問題は基本中の基本だが、なぜか閉路の長さを問われて困惑してしまった。
雑に考えると、始点の選び方をすべて試す必要があり、bitDP部分と併せて考慮すると、
計算量が `O(N^3)` になってしまうように感じてしまった。

しかし、よくよく考えると、ある最短の閉路が存在する場合、それはどこを始点にとっても形成することができる。
よって、始点は例えば `0` の場合など、一つだけ考えればよい。

