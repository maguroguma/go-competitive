# CODE FESTIVAL 2016 final 過去問感想

Last Change: 2020-02-24 20:21:40.

- B問題は部分和の初めて見る問題。
  - 細部までは見抜けなかったが、一応模範解答と同じコンセプトで解いていると思われる。
  - 自分の解法では、$(1/2)n(n+1) - A = n$ という方程式を解き、選ばない問題のスコアの和を考えた。
    - こちらはスコアが大きい方から取れるだけ取っていく、ということができるので楽。
    - 証明してないが、なんとなく大きいものを貪欲に選んでいけば、最終的には `A` が作れそうな感じがしたので。。
    - 必ずしも出力が昇順でなくてもよい、というのも微妙にヒントになっている気がする。
  - **模範解答の考え方も重要なので、別に復習しておく。**
  - 部分点は動的計画法で解ける制約。
    - 部分点でDPを積極的にやれるほどまだ強くはないのが残念。。
- C問題は一見難しそうだったが、言語の数の和の制約からUFを見抜いて解けた。
  - このたぐいの制約は積極的に使っていきたい（以前は使わなくても解けるものがあったが）。
  - 解答スライドの説明とは若干違う見方をしている気がするが、自分が実装した手法のほうが簡単にみえる。
    - ざっくりというと、言語ごとに直接会話ができる（連結な）人同士を結びつけていく、というのを全言語に横断してやっていく。
    - 最後にどの人でもよいので、属する集合のサイズを確認して終わり。

## D問題（@2020-02-24）

700点の割に簡単そう。。と思ったのは貪欲だから。
実際自分の方針は正しかったが、数え上げの方法がバグっていたらしく、WAを連発してしまい、解説スライドを見た。

正しい貪欲の方針は「MODのペアについて、数が少ない方の要素はすべて使い切る」というもの。

数が少ない方の要素数を `n` とすると、
**`n` 個さえ残しておきさえすれば、先に数が大きい方でペアを作っておけば良い**
という考え方ができる。

この実装方針のためには、各MODごとに「同じ数同士で作れるペアの数」というのを前計算しておけばよい。
以下の数式で、最終的に加算すべき同じ数字のペアの個数が算出できる。

`Min((lnum-minNum)/2, ペア数)`

※第一項目は `lnum >= lpair*2 + minNum` という満たすべき不等式から導出できる。
当然、組めるペア数を超えるものは作れないので `Min` でバウンドしたものを加算する。

**※個人的に証明も含めてかなり重要な貪欲解法の問題。**
忘れた頃に解き直したい。

### 証明の概略

MODの組で、個数が少ない方の集合を `T`, 多い方を `S` とする。

- ある最大マッチングにおいてTの要素xが余っている場合。。
  - Sのほうが大きいので、「Sの要素でかつTの要素とマッチングされていない要素y」が存在する
  - yがSの別の要素とマッチングされている場合は解消する
  - **x, y をマッチングさせることで、xをSの要素とマッチングさせるような最大マッチングを構成できる！**
- ある最大マッチングにおいてTの要素同士のマッチングが存在している場合。。
  - （多分、以下も同様の感じで進む）

**「なんらかの最大マッチングを想定したとき、ペア数を変えずにすべてのTの要素をSの要素とマッチングさせられる」ということをざっくり示すことができれば良い！**

※解説スライドの「そもそもこの場合は最大マッチングでないが」という文言はちょっと気になった。
