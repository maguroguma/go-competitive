# 最長共通部分列問題（LCS問題）

Longest-Common Subsequence problem.

かなりの期間わからないまま放置してきたが、かなり基本的なものであるため、勉強する。

## 参考URL

- [典型的なDPのパターンを整理（ナップサックDP編）](https://qiita.com/drken/items/a5e6fe22863b7992efdb#%E5%95%8F%E9%A1%8C-8%E6%9C%80%E9%95%B7%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86%E5%88%97-lcs-%E5%95%8F%E9%A1%8C)
- [動的計画法で得た最適解を「復元」する一般的な方法](https://qiita.com/drken/items/0c7bab0384438f285f93)

## 参考問題

- [LCS（EDPCのF問題）](https://atcoder.jp/contests/dp/tasks/dp_f)
- [わたのはら（いろはちゃんコンテストDay2のA問題）](https://atcoder.jp/contests/iroha2019-day2/tasks/iroha2019_day2_a)
  - 5000文字同士の文字列（制約はよく見ること）

---

## はじめに

言葉がこんがらがるので整理しておく。

- subsequence: 部分列。今回対象としているもの。連続している必要はない。
- substring: 部分 **文字** 列。こちらは切り出したものであるため、 **連続している必要がある** 。

## 用途

Wikipediaより。

> 計算機科学に置ける古典的問題であり、diffなどのファイル比較プログラムの基礎をなし、バイオインフォマティクスにも応用されている。

---

## 競技プログラミングにおけるLCS系問題

### 純粋なLCS

#### 第一段階

まずは与えられた文字列のLCSの **長さ** を回答する方法。

要約: `(i+1, j+1)` に対して `(i, j), (i+1, j), (i, j+1)` の3方向の遷移を考える。

個人的には後ろ2つの遷移が理解しづらい気がする。
「片方だけ1文字進めたときにも何かしら変化が起こるのでは？」という考えがよぎるため。

（以下は自己解釈であまり自信がない。）
実際、LCSの作り方としては進めた1文字を取ることはできるかもしれないが、
**少なくともLCSの「長さ」は変化しようがないため、特に疑問に思う必要はないはず。**

※注意点！

この遷移だと、`i==0, j==0` のときなどは、いきなり `dp[1][1]` についての遷移を考え始めている。
これは、LCSを求める問題であれば `dp[0][j], dp[i][0]` はすべて0であるため特に問題にならないが、
[ABC130のE問題](https://atcoder.jp/contests/abc130/tasks/abc130_e)のような応用問題では通じないために注意が必要！
（この問題では、`dp[0][j], dp[i][0]` はすべて1に初期化する必要がある。）

#### 第二段階

最長のLCSをひとつ出力する方法。

求めたLCSの長さから「復元」を行う必要がある。

いくつか方針はあるらしいが、「DPテーブルの値を見ながら、
今いるノード `(i, j)` がどのノードから更新されてきたのかを特定する」方法によって
解いてみる。

### レーベンシュタイン距離（diffコマンド）



