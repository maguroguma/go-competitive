# AtCoderのupsolveした問題たち

Last Change: 2020-12-06 23:28:23.

「コンテストに出て解けなかった問題の復習」というのはひときわ学習効果が高いと思うので、
@2020-11-01からではあるが、このディレクトリ内にまとめていく。

---

## [ARC104 C.Fair Elevator](https://atcoder.jp/contests/arc104/tasks/arc104_c)

※解法の概要は理解したが、実装が非常に大変そうなので、upsolveはあとに回している。

## [ABC179 F.Simplified Reversi](https://atcoder.jp/contests/abc179/tasks/abc179_f)

一応自力で解き直した。  
純粋に区間更新だけが可能な遅延セグ木を2本作ることでシミュレーションを効率化した感じ。  
こういった遅延セグ木の代わりになるもっと簡易なデータ構造ってないものだろうか。。

解説放送では、「点chmin更新、区間min取得」のセグ木でできることを説明している。

※「区間更新・点取得」→「点更新・区間取得」の変換は重要な気もするけど、
脳死で遅延セグ木使えるほうがコンテスト的には大事だと思うので、一旦は忘れておく。。

## [ABC181 F.Silver Woods](https://atcoder.jp/contests/abc181/tasks/abc181_f)

最小包含円の問題を思い出すような、易しめの幾何の問題。

半径を決め打って判定する問題を二分探索するのはわかるが、具体的な方法は回答PDFを見た。  
全ての点と点の間の距離を計算し、この距離が `2*r >= dist` ならば通れることがわかる。  
同様なことは点と直線に関しても言える。  

ここで、点と直線を頂点とみなして `n+2` 個の頂点からなるグラフを考える。  
また `2*r < dist` を満たす点と点、および点と直線、直線と直線の間にエッジを張る。  
最終的に、「直線ノードと直線ノードが連結ならば通り抜けられない」というふうに言い換えることができる。  
回答PDFには「右手法をイメージすれば良い」とあるが、まさに「エッジがはられている間は通り抜けられない」ことからも、
直線と直線が連結でなければ、なんらかの抜け道がある、と判定できる。

とても賢く、きれいな問題。

## [ARC106 D.Powers](https://atcoder.jp/contests/arc106/tasks/arc106_d)

シグマの扱いがうまくなりそう、プラス、二項係数の理解が深まりそうな問題。  
求められる考え方や式変形はかなり典型っぽい考え方に見えるので、復習の際は以下をやってみるといい気がする。

- 回答PDFの式変形を（理解しながらゆっくり手で）写経する。
- 解説放送を聞き直す。
  - 典型っぽい考え方のポイントを教えてくれている。
    - e.g.: シグマの順番をforループの順番を入れ替えるように入れ替えても良い、展開してそれぞれの項の和を考える、など。

**※二項係数は手計算だとめんどくさいイメージがあるが、「コンピュータにとっては処理しやすいきれいなもの」というイメージを持っておくといい気がする。**

![](./arc106d.jpg)

実際に実装してみたら、改めてMOD計算周りで注意すべき点が見えた。

- `modpow, invmod` はかならず前計算しておく。
  - 特に後者は `logN` レベル以上に聞いてくるので厳守すること。
- 階乗計算も安全に行うのであれば逐一やったほうが良いが、ミスを避けるためにも組み合わせライブラリを使うのもあり。
  - 適当に大きすぎる値を取らないこと。1Mぐらいで取るとプラス400msecは覚悟する必要がある。

※[ccppjsrbさんはmodintを自作して使っているらしい](https://atcoder.jp/contests/arc106/submissions/17669427)。。

## [ABC183 F.Confluence](https://atcoder.jp/contests/abc183/tasks/abc183_f)

マージテクと呼ばれるものを活用して計算量を抑える。  
実例でいうと、UnionFindのunion by sizeのアルゴリズムに該当するもの。

結論から言うと「Union Findのアルゴリズムをどれだけ深く理解しているか？」が問われた問題だったように思う。

![](./abc183f.jpg)

> しかし、各生徒が属している集団の大きさは、移動が行われるごとに2倍以上になるため、
> 各生徒について移動が行われる回数は高々 `O(logN)` 回です。

小グループのleaderの辞書を大グループのleaderの辞書に併合することを「生徒の移動」と考えることができる。  
各生徒一人ひとりについて見ると、異なるグループの移動は対数オーダーで押さえられることがわかる。

※UninoFindのアルゴリズムを暗記してかけるようになるぐらいなじませたほうがいいかもしれない。。  
※ACLの命名規則は参考になるのかもしれない（rootよりはleaderという捉え方のほうが大事。）

## [ABC184 C.Super Ryuma](https://atcoder.jp/contests/abc184/tasks/abc184_c)

ハイパー難しい。  
ただ45度回転の問題としてはかなりいい題材の一つかもしれない。  
45度回転の復習の際にはまた取り組みたい。

45度回転はまだまだまだまだ慣れが必要だが、現状でも最低限以下は押さえておきたいかもしれない。

- 座標系: `(x, y) => (x+y, x-y) = (x', y')`
  - 行列の回転を素直に考えると `(x, y) => (x-y, x+y)` とすべきっぽい？
- 2点間のマンハッタン距離: `|x1-x2| + |y1-y2| => max(|x1'-x2'|, |y1'-y2'|)`
  - ななめの菱形から、 `x', y'` 軸それぞれに平行な正方形を考えるイメージになる

あとはグリッド一般的に以下の性質は別個に押さえておきたい。

- 斜め移動だけではパリティを変えられない
  - 市松模様、二部グラフ
  - 白からは白にしか、黒からは黒にしか行けない

### evimaさんの解法

[evimaさんのツイート](https://twitter.com/evima0/status/1331479659964350465)で、動画で解説をしてくれている。

この解法では45度回転といった難しいことは考えておらず、以下がポイントとなっている。

問題を「正規化」している。  
具体的には、片方が原点、もう片方が第一象限に来るように問題を変換している。  
片方を原点に寄せるのは、単に平行移動してやれば良い。  
こうすると、もう片方が必ずしも第一象限に来るとは限らないが、x,y座標どちらについても、負の座標であった場合は、
鏡写しにするイメージで反対側に持ってくる、すなわち符号反転してしまっても一般性は失われない。

このように正規化して考えると、市松模様といったものも考える必要がなく、また1,2手で進められる範囲のイメージもだいぶ易しくなる。

## [ABC184 D.increment of coins](https://atcoder.jp/contests/abc184/tasks/abc184_d)

期待値DP。  
条件付き期待値や条件付き確率を考えなくてよいあたりは、EDPCのSushiよりは優しい。

## [ABC184 E.Third Avenue](https://atcoder.jp/contests/abc184/tasks/abc184_e)

一工夫必要な最短経路問題。  
ワープについて愚直に辺を貼ってはいけないので、その点に対して工夫が必要。

- ワープは一回しか使わないように注意しつつBFSを実装する。
- ワープを超頂点として辺の数を増やしすぎないように工夫してからダイクストラもしくは01BFSに帰着させる。

後者のやり方は練習として別途実装したい。

### 超頂点を加えるやり方

思ったよりもグラフの拡張部分の実装は楽だった。  
ただ、悲しいことにダイクストラではTLEを回避できなかった。  
一方で、グラフはそのままに01BFSにかけてやったところ、無事AC出来た。

01BFSのライブラリはあまり使い慣れていないが、隣接リストのグラフさえ正しく作れてしまえばあとは関数に放り投げるだけなので、
使えるときは恐れずに活用していきたい。

## [ARC109 C.Large RPS Tournament](https://atcoder.jp/contests/arc109/tasks/arc109_c)

結構難しいDPだと思うが、みんな解けていて驚く。  
ただ、DPだと意識しなくても解ける開放があるので、そのせいもあったのかもしれない。

`dp[i][j] := 始点i(mod n), 長さ2^jのトーナメントの勝者の手（グー or チョキ or パー）`

実装はメモ化再帰が楽だと思う。  
遷移で `2^k mod n` を計算する必要があり、何かしらの方法で前計算すれば、全体の計算量は `O(n * k)` になると思う。  
制約が小さいのが微妙にいやらしい。

以下の点を意識するのがポイントになるかもしれない。

- とどの詰まり、「周期性」というのを強く意識すること
  - まず問題の題材的に、与えられた文字列が無限回catされるようなものを扱っているので、そもそも周期的である。
  - 「周期を巧く扱えばどうにかして解ける」というのを強く意識する必要があったかもしれない。
- 周期 `n` ということはつまり、状態が `n` 個しかない、という見方ができる（？）
- `2^k` 人のトーナメントというのが、そもそもきれいな再帰構造を持っている。

## [ARC107 B.Quadruple](https://atcoder.jp/contests/arc107/tasks/arc107_b)

本番でも解けた問題ではあるが、ものすごく時間がかかったし場合の数の考察も甘かったので復習する。

この問題は、以下の問題が解けてしまえばほぼ終りとなる（あとは全探索するだけになる）。

> `1 <= x, y <= n` をとる `x, y` について `x + y = k` となる異なるペア `(x, y)` の個数を求めよ。

`n = 6` とすればちょうど「区別できる6面サイコロを2つ振ったときの和が `k` となるサイコロの出方」と等しくなる。  
ここから具体的に考えると、色々と整理ができる（図も参照する）。

![](./arc107b.jpg)

- 取りうる範囲が `[2, 2 * n]` であることはすぐわかる。
- 取りうる範囲が `n` のパリティによらず偶数から偶数の間であるため、値の種類は必ず奇数となる。
- それぞれの値についての頻度は、図の行列から分かる通り `2, 3, .., n, n+1, n, .., 1` となる。
- これの一般化は容易であり、和の値を `x` とすると `min(abs(x-2)+1, abs(x-2*n)+1)` となる。

本番でもこれぐらい手で実験してから落ち着いて解くべきだった。。

