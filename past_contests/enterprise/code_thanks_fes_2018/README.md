# CODE THANKS FESTIVAL 2018 過去問感想

- C問題は若干数え上げっぽい、2点間の距離の総和を求める問題。
  - AGCの「Minimum Sum」や新ABCの盤面上のコマ間の距離の総和を求める問題の弱いやつ、という印象。
  - 自分は数える距離の登場回数を考えたが、模範解答では、数式における数列の各項の登場回数を考えている。
- D問題は文字列・辞書順に関する300点問題。
  - 指示された操作を前からシミュレーションをする形で良い。
- E問題は時間はかかったが、最後まで自力で詰めることができた。
  - **小さな問題（今回は黒板に書ける最大の整数を3ぐらい、枚数もそれぐらいに小さくたもの）を考えることでDPのイメージを作ることができた。**
    - **典型チック: 具体的な小さな問題を考える、小さな問題の再利用（つまりはDP）**
  - 模範解答とは違う解き方をしている気がする。。
    - というか模範解答の意味がよくわからない。。
  - 自分の解法の概要:
    - `dp[i][j] (1<=i<=t, 0<=j<=600)`: `i` までの数字を黒板に書いたときの、最終状態（のようなもの）の通り数。
      - このようなDPテーブルを考える。
    - 2分木を葉から考えていくイメージ。葉の数字は使う数字で、2つを子として親（この数字に1足したもの）を作る。
    - 基本的に、数字の union 操作を限界まですることを考え、限界まで行った状態を「最終状態」と考える。
    - 1だけを使った場合がわかりやすいが、結局の所、黒板に残る数字は、**「黒板に書いた1の個数を2進数表記したとき、`i` 桁目（1-based）が立っていれば、数字 `i` が存在する。」** というような様相になる。
      - 例えば、1を10個書いたときは `10 -> 1010` であるため、最終状態は「2, 4」である。
      - 1に加えて2も黒板に書いていくにあたって、1だけを書いた場合の最終状態をすべて列挙し、それぞれの通り数をメモしておけば良い。
    - 2以上のときも同様にやりたいが、`T` が最大で300であるため、2進数で軽く300桁を超えることになってしまう。
    - そこで、**再利用する際に最終状態を1つ右ビットシフトすることを考える。**
      - 最下位ビットが立っている場合、このビットはより大きな数字を使ってはどうあがいても消せないため、遷移を考える必要はない。
    - それまでの状態を1つ右ビットシフトさせ、これに対して注目している数字を0個から指定された個数の範囲で足し合わせた状態のDPテーブルに、1つまえの状態のDPテーブルの値を加算する。
      - コード中の `dp[i][state+j] += dp[i-1][k]` の部分。
    - 最後に、求めたDPテーブルを使って、累計の通り数を算出する。これは2パートに分ける必要がある。
      - `dp[t][0~600]` のうちビットが1つだけ立っているもののDPテーブルの値（つまりは2べきの値）。
      - `dp[1~t][1]` の合計。
        - これは、DPテーブルの計算のための遷移部分で、最下位ビットが立っているものは遷移から除外しているために必要。
        - 排他的になっているため、単純に加算していくだけで良い。
- F問題は考察だけ先に進めていたが、いくつか不足している分があるように思えて、途中でやめてしまった。
  - 解答を読んだら基本的には合っていそうなので、あきらめずに取り組みたい。
  - 頂点 `v` を選んだときに、その以下の子はすべて選べないようにする必要がある。
    - フラグ管理が必要。 `v` からのDFSで、頂点を選択するたびにやれば良さそう。
  - 頂点 `v` を選んでもよいかの条件が詰めきれてなさそう。
    - 当初はそれを選んで手数が足りるのかどうかでチェックしていたが、逆に余らせてしまうケースを考えられていなかった気がする。
  - 無限に時間をなくしてしまいそうなので、[idsigmaさんのブロ記事](http://sigma1113.hatenablog.com/entry/2019/01/30/005145)を参考にする。
  - **典型チック: 残り手数のピタリでの消化 -> 可能な手数の上限と下限を考える。**
  - **小技っぽいが、根の深さを1とすることで、コインを置く手数をまとめてしまって見通しを良くしている。**
    - このテクは汎用性がありそうなので覚えておきたい。
  - **Go のスライスの参照渡しについては復習しておくこと！！！**
    - 自動的に参照渡しするんじゃなかったっけ？？？

---

## F問題（idsigmaさんの解法）

> 使える頂点の数はクリアしたとして，手数の問題を考える。
> 残り手数をピッタリ消費する，という条件は扱いにくいが，このような場合は **可能な手数の上限と下限を考えるとうまくいくことがある。**

ここは典型ポイントっぽいので覚えておきたい。

> そして，**この上限と下限の間の手数の消費は必ず可能である。**
> 手数の下限の状態から，手数の上限の状態までコインを順番に動かすことを考えれば，このことがわかる。
> 以上より，K−dvがこの上限と下限の間にあれば，コインを頂点vに置くことが可能となる。

なるほどー。
