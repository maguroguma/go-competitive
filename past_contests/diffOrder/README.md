# difficulty順に埋める

Last Change: 2020-07-25 13:21:21.

@2020-06-29より、埋めていないところから順に埋めていく。
おそらくは復習が必要な問題が並ぶはずなので、最初から集めておく。

## [ABC161-F ★](https://atcoder.jp/contests/abc161/tasks/abc161_f) @2020-06-29

こどふぉならmath, number theoryタグがついてdiff 1600ぐらいになりそうな問題。
でもわからずに解説AC。

剰余の推移に目をつけたのは良かったが、逆から考えようとした時点で間違いだった。

ていうか誤読してた、死にたい。

## [ABC030-D](https://atcoder.jp/contests/abc030/tasks/abc030_d) @2020-06-30

[ABC167-D](https://atcoder.jp/contests/abc167/tasks/abc167_d)とほぼ同じな気がする。

バカでかい `k` の対処は桁DPなどでよくある剰余の扱いをすればよいが、違いはそこだけだと思う。

これもダブリングをするとライブラリ貼るだけとかにできるのかもしれないが、
ライブラリチェックはよりシンプルな問題の方だけで試せば良い気がする。

## [AGC044-A ★](https://atcoder.jp/contests/agc044/tasks/agc044_a) @2020-06-30

難しい。答えを効いても計算量見積もりが非常に難しい。
すぬけさんの解説放送でのざっくりとした見積もりが一番わかり易い気がする。

とりあえずは「ハッシュマップを使ったメモ化再帰」というのがこの問題で一番手にしておきたい経験値だと思う。

## [ABC025-C ★★](https://atcoder.jp/contests/abc025/tasks/abc025_c) @2020-07-01

答えを見たが面白かった。ゲーム木の基本問題として覚えておきたい。

ゲーム木の考え方（再帰部分）もそうだが、
「ゲームにおいて最大化と最小化を考える2プレイヤーがいるとき、総和が一定であることに注目すると見通しが良くなる」
という部分は応用の幅が広そうであるため、ぜひ覚えておきたい。

## [ABC013-D](https://atcoder.jp/contests/abc013/tasks/abc013_4) @2020-07-01

自力。ダブリングの練習ができた。

ダブリングのコードは[けんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2020/06/20/190700)
がわかりやすかったので、変数名なども含めて写経した感じになった。

## [ARC023-C](https://atcoder.jp/contests/arc023/tasks/arc023_3) @2020-07-02

自力。

逆元が一般的でなかった時代の過去のもの。
注意点としては、制約が最近では見ない感じで、もろもろを前計算する自前の組み合わせライブラリではうまく行かず、
コンビネーションを愚直に計算しないと駄目なタイプだった。

## [ABC011-D ★](https://atcoder.jp/contests/abc011/tasks/abc011_4) @2020-07-02

解説AC。

場合の数なら簡単だが、確率を求めろとなると場合の数を考えると失敗してしまう。

パスカルの三角形を応用すると、 `C(n, r), r = 0, 1, .., n` までのすべての組み合わせの確率が直接求まる。
この事実をうまく利用すると、所望の確率が計算できる。

ポイントは、一度場合の数の考え方をリセットして忘れて、 `C(n, r)` に閉じた積事象の確率で考えること。

`O(N^2)` で任意の確率が求まる可能性があることについては覚えておきたい（これから出題される可能性は低そうだが）。

## [ABC023-D](https://atcoder.jp/contests/abc023/tasks/abc023_d) @2020-07-03

自力。

最大値の最小化といえば二分探索がまっさきに思いつくので、そこを狙って考えれば簡単だと思う。

判定関数の中でソート処理が含まれるので計算量にはlogが2つつくことになるが、
制限時間が5秒なので大抵の言語で余裕だと思う。
Goだと1100msecぐらいだった。

## [ABC014-D](https://atcoder.jp/contests/abc014/tasks/abc014_4) @2020-07-04

自力。

木のLCAを求めて、与えられたノード2つの根からの深さとLCAの根からの深さを用いて計算してやる。
LCAの利用問題としては最易の部類だと思う（ので、verify用問題として良さそう）。

※LCAはフルスクラッチで書ける必要はないが、アルゴリズムの動作原理や内部で保持しているデータ構造（ `depth` ）については理解しておくべきだと思う。

## [ABC162-F ★★](https://atcoder.jp/contests/abc162/tasks/abc162_f) @2020-07-04

解説放送AC。

解説PDFだけだと理解がきつい。
解説放送ではDPの組み方まで教えてくれたのでわかりやすかった。

制約が厳しいことから状況を整理して、最終的にやるべきDPを見出したい。

## [ABC171-F ★★](https://atcoder.jp/contests/abc171/tasks/abc171_f) @2020-07-05

解説放送AC。

これもPDFだけだと理解がきつい。

独立？な数え上げをうまくやる方法として「最終的なものが部分列として含まなければ行けない」という点から出発している（多分）。
発想がとても賢い。。

最終的には、組み合わせライブラリを用いるシンプルな数え上げになる。

- 操作手順を考えると重複が出てきてわけがわからない。
- **挿入後に出来上がる文字列が「どういう性質を持つか？」から考える。**
- ある文字列が部分列を含むか？の判定はシンプルに前からみる貪欲法で良い。

## [ABC154-F ★★](https://atcoder.jp/contests/abc154/tasks/abc154_f) @2020-07-05

解説（放送）AC。

まず、2次元累積和的な発想が求められる。
これにより、原点中心の「量」が高速に求められればOKというシンプルな問題になる。

※実際に小さい範囲でマス目を書いて、通り数を埋める実験をやるべき！

※すぬけさんの解説放送の方法はパスカルの三角形の理解が深まるので、これはこれで面白い。
（というより「組み合わせ」という量の性質が色々見つかって面白い。）

**※今までパスカルの三角形は「貰うDP」っぽく考えていたが、すぬけさんの解説のように「配るDP」の視点も持てると、色々と応用幅が出そうな気がした。**

## [ABC165-F](https://atcoder.jp/contests/abc165/tasks/abc165_f) @2020-07-05

久しぶりに自力で解けるABC-Fが出てきた。

「DPの巻き戻し」と呼ばれるテクニックを使うらしい（復元とは全くの別物っぽい？）。

何やらstackを使うと良いらしいとあるが、自分はLISのデータ構造をスライスのスライスとして持って、
最後尾の該当するものを都度削除するという方法をとったらうまくいった。

※同じ値の要素が存在するLISは少し注意が必要！（1回WAしてしまったので）

## [ABC159-F ★★](https://atcoder.jp/contests/abc159/tasks/abc159_f) @2020-07-05

解説AC。

耳DPが難しい。。
絶対に復習が必要となる問題。

※解説放送を見ればわかるが、部分和問題の数え上げ問題は、多項式の係数と深い関わりがある。
割り算だったり順序を入れ替えたり、とかの正当性がすっきりわかるので、数え上げ手段としては強力（っぽい）。
実装も多項式バージョンを紹介しているっぽいので、気になったときにチェックして写経してみるといいかもしれない。

※いつも頼りになる[けんちょんさんの解説ブログ](https://drken1215.hatenablog.com/entry/2020/03/22/224200)

## [ABC173-E ★](https://atcoder.jp/contests/abc173/tasks/abc173_e) @2020-07-06

コンテスト中に解けなかった問題。注意力要素も強めな気がする。

解説放送で勉強する。

- 適当にやると場合分けがやばいので、丁寧にやりましょう。
- 0は一旦無視する。
- 「積を正にできるか⇔負を偶数個選べるか」←これが結構難しい。
  - 「正が1つでもあるかどうか」という視点は重要（最後の1つで帳尻合わせできる）
    - 実際、「負の数をk個選んだらどうなるか」を考えると、帳尻合わせが簡単に出来る（正は1つかならず残るので）。

## [ABC173-F ★★](https://atcoder.jp/contests/abc173/tasks/abc173_f) @2020-07-06

解説放送AC。簡単とか言われてたが、PDFを読んだ感じ初めて出会う考察だったように見える。

- 連結成分数を言い換える
  - `頂点数 - 辺数`
    - **これは「木の頂点数と辺数の関係を森の各木に対して適用してやる」ことで知らなくても発想できる！**
  - サイクルが起き得ない木グラフだからこそできる言い換え
- 辺数を数えるときは「横から見るものを縦から見る」やつで数える
  - 「主客転倒」とか「寄与ゲー」とかも言われるらしい（個人的に前者の言い回しが好き）

## [ARC014-D](https://atcoder.jp/contests/arc014/tasks/arc014_4) @2020-07-07

自力。易しめではあるものの、ノーミスで通せたのは嬉しい。

マージされる行間に注目すると良い。
マージされるものが増えていくと、その分 `x+y+1` を考えるべき個数が減っていく
（ちょうど↑の問題で、森に閉路とならないように辺を足すと連結成分が1つずつ減っていくように）。
その代わりにマージされた間の長さを加算すれば良いことになる。

これらの計算は行間のdiffを集めた配列を照準ソートして、
二分探索によってマージする個数が、prefix sumによって加算すべき値（寄与させる値）がわかる。

端っこの処理に注意。

## [ABC131-F ★★](https://atcoder.jp/contests/abc131/tasks/abc131_f) @2020-07-07

解説放送AC。PDFだけでは考察の流れ（気持ち）がわからなかった。

- 2次元の点を軸に射影するのは典型？[多分そう。](https://drken1215.hatenablog.com/entry/2019/06/23/004700)
  - 点を辺だと考える。2部グラフ上の点。
  - **完全二部グラフになるまで辺を追加する。**

**典型: 格子点を二部グラフとして考える。**

「二部グラフの奇数長のパス」というのも既視感があるので、発想の種として覚えておきたい。

実装は割と簡単かも（ちょっと考えたものが解説のすぬけさんのものとほぼ同等だったのは自分を誉めたい）。
連結成分でちょっと複雑なことをしたいときは、アドホックにDFSを書いたほうが融通がききそう。
（ABCの序盤ではunion findで雑にやるのも検討したい。）

## [ABC142-F ★★](https://atcoder.jp/contests/abc142/tasks/abc142_f)

解説放送AC。

なんとなくやりたいことはわかっても実装方法がよくわからない問題だった。
ので、最初から解説を参照した。

閉路ができたら必ずOKなものが存在する。
閉路があって条件を満たさない場合、その中に余計な辺があることになるが、
それを利用してより小さい閉路ができる。
よって、再帰的に調べていけば、いずれ条件を満たす閉路が見つかる。

↑多分、この考察が一番配点の大きい部分だと思う。
実装は割と適当でもいい、はずだがよくわからなかった。

また、言い換えるとBFSで最小（極小）サイズのサイクルを見つける、というのでよい。

BFS, DFS両方の実装をやってみたい。
が、BFSのほうが大分素直に見えるし、BFSにもっと慣れたいこともあるので、まずはここを強く覚えるのが良いかもしれない。

。。この問題などを見ると、ABC-Fは意外とシンプルに考えて良いものが多いのかもしれない。

**典型: BFS, DFSで有向グラフの閉路を取得する実装。**

※DFSの実装は[毎度おなじみのけんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2019/09/29/012000)が大いに参考になりそう。

## [ARC031-C ★★](https://atcoder.jp/contests/arc031/tasks/arc031_3) @2020-07-10

解説AC。簡単だと思ったが、多分どこかに間違いがあり、サンプルを除いて全然テストをパスしていなかった。

転倒数っぽいからBITを使う発想はすぐに出てきたが、転倒数の発想のママでは解けなかった。
てっきり累積和的なものを使って、最大のものをどこに置くかを全探索するものだと思ったが。。

正解は、その時点で最も小さいものを左右の端どちらかに寄せる必要があるが、どちらでも問題ないので近い方に寄せる貪欲を繰り返す、というものだった。
「小さいものから処理していく」というのは典型発想だったので、これも考えたかった。

この手法は、BITを使うことによって実装できるが、BITの扱い自体もあまり慣れていないので、いい練習問題として覚えておきたい。

**典型: 小さいものから処理していく。**

※転倒数を考えて全探索する方法もあまり間違いっぽくはない気がするので、どこかで解き直してみても良いかもしれない。

## [ARC051-C ★](https://atcoder.jp/contests/arc051/tasks/arc051_c) @2020-07-10

解説AC。というか、公式PDFを読んでもよくわからなかったので、色々なブログ解説を読んだ。
が、それでも最初はよくわからなかった。

よーく考えたら簡単な話だった。

「最小値にAをかけたものが、直前の状態の最大値以上になったら、以降は周期性を伴って変化する」というのは簡単な話だった。
最初、なぜそうなるのか理解できなかったが、具体的に昇順に並べた数列に対して、例えば2でもかけたものを書いてみると良い。

`A[n] <= A[1]*2` となったら、当然次は `A[1]*2 <= A[2]*2` となる。
これが繰り返されるのだから、周期性に疑問を抱く必要はない。

よって、最大値を超えるまではシミュレーションして、それ以降は周期性を利用して、二分累乗法によって計算を進めれば良い。
最初のシミュレーションについて注意が必要そうに見えるかが、結果は `int64` に収まるのと、
最大値を超えるまでに必要な掛け算の数はせいぜい30回もあれば十分なのはすぐわかる。
よって、そんなに悩む必要はない。

## [CODE FESTIVAL 2014 予選A C ★★](https://atcoder.jp/contests/code-festival-2014-quala/tasks/code_festival_qualA_d) @2020-07-11

解説AC。実装でコーナーに気づけず、地獄を見た。

桁DP的な考え方で数を捉える必要がある。
すなわち、貪欲的に左の桁をあわせたいわけだが、どこかでずらさざるを得ない時が来る。
これ以降は、大きくしてしまったなら選べる選択肢の中で最小を目指し続けるし、
小さくなってしまったら選べる選択肢の中で最大を目指し続ける必要がある。

よって、元の数字を左からいくつコピーするか、次の桁はどの数字にするか（ずらすか）、以降の桁はどの数字を連続させるか、
を全探索すれば良い。

おそらく、leading zeroをちゃんと扱わないと最小値を見逃してしまうテストケースが2つ存在する（具体的にどのようなものかは調べていないが）。
[この方の記事](https://qiita.com/ophhdn/items/339133a31b9e33c8c264)で気づけた。
「なんで戦闘のものだけ除けば十分なのだろう？」と思ったが、2つ0が続くようなものは最適にはなりえないため（多分）。
。。一回整数に変換してからまたOK判定するほうが賢かったかもしれない。。

その他、計算量は大分余裕があるので、イミュータブルなコーディングを心がけるのも大事。

※bitDPと桁DPをあわせたようなDPでも解けるようなので、いつか練習してみても良いかもしれない。

## [Indeedなう予選A D ★★](https://atcoder.jp/contests/indeednow-quala/tasks/indeednow_2015_quala_4) @2020-07-11

解説AC。実装が大変だが面白かった。

半分全列挙の考え方。
すなわち、 `3^24` は探索できないけど、 `3^12` ならOKなことを利用する。

初期状態から12階層、ゴール状態から12階層探索する。
盤面をハッシュ化することでハッシュマップに載せられるため、初期状態あるいはゴール状態からその盤面に至る最短手数を求めておく。
最後に、初期状態から到達可能な盤面とゴール状態から到達可能な盤面で一致するものを調べ、
最短手数を更新していけば良い。

**複雑なものでも、一致判定ではハッシュ化、あるいはソートをすぐさま検討できるようにしたい。**

※DFSの場合は途中で更新が起きうる場合があることに注意！その意味ではBFSのほうが高速な気がする。

※Aスターアルゴリズムでも解けるっぽい。kenkooooさんがブログを上げていた。

## [ABC167-F ★](https://atcoder.jp/contests/abc167/tasks/abc167_f) @2020-07-11

解説（放送）AC。

貪欲を詰めていくのが難しいと思う。
とはいえ、特別なアルゴリズムは用いない。

すぬけさん曰く、「アドホックな問題」。

- **カッコ列は折れ線グラフで考えると良い。**
  - **正しいカッコ列であるための条件は「0で終わる、0未満にならない」となる。**
- 断片を2つの値で表す。
  - ここはいろいろな見方ができそう。
  - 最下点と最終的な増加量を調べる。
    - 一度下がって一度上がる、シンプルなV字のものに統一できる。
- 増加量の正負でわけると、理想的な高さまで上がり下がりする、という考え方のもとでは、並べ方をシンプルにできる。
  - 上がるときは、最下点が大きいものからつなげるのが良い。
    - くっつけやすいものからくっつけていることになるので、それが無理ならどうあがいても無理。
  - 下がるときは難しい。逆から考えると同じ話になっていることに着目しないといけない。

## [ABC152-F ★★★](https://atcoder.jp/contests/abc152/tasks/abc152_f) @2020-07-11

解説（放送）AC。これも包除原理だった。

余事象っぽく考えれば良いのでは？と思ったが、あまりにもシンプルに考えすぎた。

包除原理を真面目に計算するタイプの問題に初めて出会えたので良かった。
**包除原理は、余事象を考慮するときに一緒に考えておくと良さそう。**

- 包除原理は、一般的には2のべき乗の計算量になる。

※すぬけさんの放送でやっていた実装では、パスを求めるのにDFSを行って、
「ゴールを引数に入れてそこに到達したらそこから巻き戻してパスを逆順にスライスに突っ込む」
というのが賢かった（ゴールとは違う終点にたどり着いたら `false` を返すことで無視できる）。
パスのスライスは、グローバルにおいてDFSを大元で呼ぶ前に初期化すれば良い。
シグネチャは `func dfs(cid, gid, pid int) bool` という感じ。

※包除原理の辺の数を数えるところは一貫してビット演算に閉じると、ビットマスクのOR演算で収まったり、大分高速になりそう。

※LCAを使った「木上の累積和」というのは結局謎のままだった。

## [CODE FESTIVAL 2014 Easy D ★★](https://atcoder.jp/contests/code-festival-2014-morning-easy/tasks/code_festival_morning_easy_d) @2020-07-12

非公式の解説ブログを読んでAC。

貪欲の考え方は合っていたが、実装に嘘が含まれていた。

多分、priority queueをうまく使うしかない。

**典型: 貪欲法にはpriority queueが相性が良い。**

- [mayokoさんのブログ](http://mayokoex.hatenablog.com/entry/2015/10/08/210337)
- [kmjpさんのブログ](https://kmjp.hatenablog.jp/entry/2014/11/10/1030)

多分、どちらも同じことをやっていると思われるが、mayokoさんのブログのほうがわかりやすかった。

まず、「枕を小さい順に見るとき、その枕に適合する人の中で、最も右端が小さい人に割り当てるのが最適」といえる。
これは、残った以降の枕は今見ているものよりも高いので、より割り当てる人が多く存在させることができ有利だから、
というので直感的な証明になる（。。と思う）。

自分は最初、区間スケジューリングの要領でソート後は線形な探索をしてしまったが、
ここで捨てては行けないものを捨ててしまっていた。
すなわち、今見ている枕に適合しないものを捨ててしまって、後で再びみることがないようなコードになっていたが、
たとえば、 `(25, 41)` という人は `12` の枕には適合しないが、あとから来る `35` には適合する。
一方で、自分が書いた嘘コードでは、 `12` に適合しない時点で捨ててしまっている。

そこで、小さい順に枕を検査する部分は変えずに、「今見ている枕については左端の条件が全て満たされているような人集合」
を保存しながらすすめる方法を考える。

このためには、まず人スライスを左端で昇順ソートすれば良い。
一方、人を対象とするpriority queueを用意し、こちらは右端の小さいものが優先的に並ぶようにする。

アルゴリズムは、今観ている枕よりも左端が小さい人をすべてqueueに詰めていく。
詰めるフェーズが終わったら、queueから右端が小さいものを順に取り出し、
適合するものが見つかったら（それが最も選べる人集合の中で最適なので）それを選んで次の枕に進む。

## [ARC075-E](https://atcoder.jp/contests/arc075/tasks/arc075_c) @2020-07-12

自力、というかもはや超有名問題。

変数分離をすると、よくあるzero sum rangesのテクニックが使える数え上げ問題になる。

累積和を使ったりした後は、「すでに見たものの中で、現在注目している値以下のものの個数は？」というのを
都度数え上げる問題になる。
模範解答でもそうだったが（evimaさんいわく「最もかんたんと思われる手法」）、
座標圧縮してからBITによる各要素の個数管理を用いるものを利用して、実装した。

多分treapなどのordered setでもできると思うが、普段の使用頻度が小さいものを練習してみた。

## [ARC026-C](https://atcoder.jp/contests/arc026/tasks/arc026_3) @2020-07-12

自力。以前にも似たようなものを解いたことがあったためできた。とはいえ時間かかりすぎ。。

まずは、貪欲的な発想の元、左端の昇順ソートを行う（もれなく廊下を照らす必要があるため）。

`dp[i] := iまで照らされている場合の費用の最小値` とすれば、RMQのセグメントツリーと合わせて解ける。
更新は `dp[l] ~ dp[r-1]` までの最小値がわかれば、それプラス現在観ている蛍光灯のコストとの和をみて、
更新すべきかどうかの判断ができる。

## [ARC029-C](https://atcoder.jp/contests/arc029/tasks/arc029_3) @2020-07-14

自力。こどふぉでほぼ同じ問題を解いたことが合った。

交易所を作る、というのを架空の都市との間に同じコストでエッジを張る、という操作とみなすと、
エッジ数のオーダーが変わらない範囲でエッジ数が増えた上での、単なる最小全域木を求める問題になる。

## [ABC170-F ★★★★](https://atcoder.jp/contests/abc170/tasks/abc170_f) @2020-07-14

解説放送AC。

グラフ拡張＋順序が定義できる構造体をpriority queueに詰めるダイクストラで解ける（TLギリギリだったが）。

`dp[i][j][d] := (i, j) における方向 d を向いている時の状態` とし、状態を「水かき回数、残りの推進力」で表す。
すぬけさんの実装による `(i, j, d) => id` という変換やその逆操作を行う関数など、非常に勉強になった。

順序が定義できる構造体のダイクストラや、3次元の複雑なグリッドグラフの変換など、練習できる要素が多い。

## [ABC151-F ★](https://atcoder.jp/contests/abc151/tasks/abc151_f) @2020-07-14

最初から解説放送を観た。

最小包含円。

**「円は3つの点によって定まる（外接円）」**
他に点は乗っていることもあるが、気にしなくて良い。
また、2つの点が直径をなすときにも円は定まる。
これらの2つのパターンをすべて試す（すべての点が入っているかどうか判定する）。

真面目にやると計算量が大変（らしい）。具体的にはどうやって実装するか？

三分探索を行う。
関数の傾きが単調増加・減少するものについて極値が求まる？
幅が `2/3` ずつ徐々に縮まっていくイメージ。
（関数が微分できる場合は二分探索の問題に帰着させられる場合もある。）

。。正直よくわからず。解説PDFの方法がわかりやすいと思ったし、実装方法もほぼ説明されていたので、そちらでやってみた。

「N個の点が与えられる。それぞれの点を中心とし、半径が `r` の円にいずれにも含まれる点が存在するための **`r` の最小値** を求めよ。」
という問題と同値になる。
こう考えると、二分探索が適用できるようになる。

半径 `r` を決めたとき、ある2点を中心とした半径 `r` の2円の交点（2つ）は、最小包含円の中心候補となる。
（多分あってるはず。直感的には、選んだ2点を円の周上に持つ「ギリギリの円」を作ることになる。）
よって、ある決め打った `r` に対してこのような交点をすべて列挙し、
また、それらを1つずつ検査する、すなわち「中心を決めたときにすべての点が半径 `r` より内に存在するか」を判定すれば良い。
そのような中心が1つでも存在すれば `true` でありより小さな半径を調べる、そうでなければより大きな半径を調べる、とすればよい。

このとき必要となるツールは以下ぐらいの初歩的なもので、ABCレベルの幾何問題であれば常に取り出せるようにして置けると良い。

- ベクトルの加減算
- 単位ベクトルの計算
- 回転行列（ベクトルの回転）
- 中点座標の計算

※解説放送では三分探索の説明を詳しくしているので、いつか練習問題として解き直してみても良いかもしれない。

## [ABC166-F](https://atcoder.jp/contests/abc166/tasks/abc166_f) @2020-07-14

解説放送で思考の流れを学びたかった。

- 0を2箇所以上作らなければ絶対に詰まない。
- 全体にたくさん石があれば、実験とかかんたんにすればなんとなく詰まなそうというのがわかる。
- 「厳しい状況」というのを考えてみる。
- 全体の和を中心にして考えてみる。
  - （結局はここを真面目に考えるかどうかに集約される気がする。。）
- **「小さいケース（※今回の場合は、総和が小さいケース）」を考えてみる**

※実はDFSでも枝刈りが早い段階でできるらしく、一本道に毛が生えたような分岐しか起きないので、案外大丈夫、らしい。
いずれ実装してみたい。

※すぬけさんのクロージャを使う実装がとてもキレイ。

## [ARC032-C ★★★](https://atcoder.jp/contests/arc032/tasks/arc032_3) @2020-07-14

解説AC。

「こういうDPもあるのか」という感じで非常に勉強になる。
一方でもう少しシンプルに書きたい気もするが、あまりいいアイデアが浮かばない。

- `dp[i] := (時刻i以降で最大可能仕事数, 最大を達成する場合の次に取るべき仕事ID)`
  - つまり、ダイクストラで時々あるような、順序が定義できる構造体（タプル）を値とするDPテーブルを定義する。
- `dp[i] <= dp[i+1]` のような遷移になるため、後ろから埋めていく。
  - あまり慣れていないので、いい練習問題としてキープしておきたい。

## [ARC045-C ★★](https://atcoder.jp/contests/arc045/tasks/arc045_c) @2020-07-15

解説AC。これは解けないとだめだった。

LCAとかでよく考える「根からのコストのXOR」というのを考えておくと、2点間のそれらのXORが2点間のコストのXORに等しくなる。
なぜなら、LCAから根までの部分は二重にXORが取られることで打ち消されるから。

。。ここまではわかったが具体的な数え上げの方法がわからなかったが、実はzero sum rangesのアレで良かった。

すなわち、 `a ^ b == x` のとき `a` を固定すると `x ^ a` の個数がわかれば、 `a` とXORを取って `x` が出来上がるペアの個数がわかる。
よって、今まで見てきたもので個数を調べれば良い、ということになる。

**典型: zero sum rangesの数え上げは、左から配列をなめるだけでなくとも良い。木のDFSの順序上でも可能。**

※練習のため、 `C(n, 2)` で最後に数え上げをまとめる方法を取ってみたが、コーナーケースの処理が難しかった。
「もれなく、重複なく」の数え上げの原則を考えると、組み合わせを使うよりは逐次加算するほうが良い方法だと感じた。

## [ARC009-C](https://atcoder.jp/contests/arc009/tasks/arc009_3) @2020-07-15

自力。ABC172-Eを解いた後だと自力で考えられた。

[完全順列、撹乱順列](https://ja.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E9%A0%86%E5%88%97)というものの通り数が本番で、
これはモンモール数とか呼ばれるらしい。
ABC172-Eと同じく、包除原理の応用によって `O(k)` で求められる。

`N` が法外に大きいため、掛け算の前に単項に対してMODを取らないと駄目なケースがあり、1WAしてしまった。

## [ARC053-C ★](https://atcoder.jp/contests/arc053/tasks/arc053_c) @2020-07-16

ABC167-Fと酷似している。
自力。。でやりたかったが嘘解法に陥ってしまったため、解説ACした。

結果がマイナスになるものは最高点が小さいものから並べるのが最適、というのはすぐわかった。
後半もフィーリングで「最高点が大きいものから並べてしまったほうが良さそう」と考えてやってみたら、
サンプルが通ったので提出した。
が、半分くらいWAの明らかな嘘解法だった。

後半ついては「降下量が大きいものから並べるのが最適」となる。
ABC167-Fと同じく、反転して考えたら対称的な問題になるため、このように考えれば良い（けど、定性的に？一瞬では納得しづらい気がする。。）。

## [ARC008-C](https://atcoder.jp/contests/arc008/tasks/arc008_3) @2020-07-16

自力。だが、色々勘違いして2WAしてしまった。

普通に人と人との間のたこ焼きの行き渡るのに必要な時間を計算し、それを辺コストとするダイクストラを考えれば良さそうと思った。。
1秒ごとにしか投げられない、という部分がなにか混乱させるが、結局中心の自分は1秒起きに `n-1` 個のたこ焼きを投げることになり、
すなわち中心の自分がボトルネックになる。
よって、自分が1秒に1回というルールさえ守れば、この部分は気にしなくて良い。

1秒間に1回の部分はシミュレーションでよく、「できるだけ遠くの人に向かって投げるように」分配するのが最適。
投げ方はシミュレーションすれば良い。

。。油断すると「最後に自分に向けて投げる」ような形となり、不必要な更新が行われる可能性があるので、この点は注意。

## [ARC025-C](https://atcoder.jp/contests/arc025/tasks/arc025_3) @2020-07-16

自力一発！

目的地を始点とし、目的地を全探索することをベースに考える。
目的地を始点とすると、ダイクストラで各点への最短路の長さが求まる。
さらに、亀のスタート地点を目的地以外で全探索する。
あとは、亀の移動にかかる時間よりも、うさぎの移動にかかる時間が大きいようなうさぎのスタート地点の数がわかれば良い。
ここはソートしてしまえば二分探索で求められそうとわかる。

面倒な点として、目的地・亀・うさぎはすべて異なっている必要があるため、そこで違反しないように数え上げのときは注意する。
自分は、二分探索部分で面倒を起こしたくなかったので、二分探索はなるべくシンプルにして、数えてはいけないものを後から引く方針でやった。

## [ARC039-C ★★★](https://atcoder.jp/contests/arc039/tasks/arc039_c) @2020-07-17

解説AC。なんとなくこんな感じだろうな〜という予想はついたが、詳細部分はおそらく解説を見ないとわからなかった。

座標をハッシュマップで管理するのは予想通り。
重要なのは、「訪問したときに4近傍についても座標を生成してしまう」こと、
また、「訪問した箇所の4近傍は、訪問したところのポインタを参考に、移動方向のポインタの張替えを行う」こと。
このポインタの張替えは、訪問時に遅延評価的に行ってやれば良い。

実装で色々混乱してしまった。
大事なのは「訪問時には4方向について正しい遷移先が設定されている」と思い込むこと。

※Goで `map[Coord][4]Coord` のような `memo` を定義したが `memo[c0][0] = c1` のような代入はできない。
必ず `C := memo[c0]; C[0] = c1;` のように、ワンクッションおいてやる必要がある。

**※このような4近傍の情報を持つデータ構造はDancingLinksと呼ばれるらしい。**

## [Code Formula 2014 予選B D ★★★](https://atcoder.jp/contests/code-formula-2014-qualb/tasks/code_formula_2014_qualB_d) @2020-07-18

解説AC。できそうでできない。

[公式解説](https://www.slideshare.net/chokudai/code-formula2014-qualb)では、アドホックっぽい賢い解法だった。

[kmjpさんの解説](https://kmjp.hatenablog.jp/entry/2014/08/28/1000)では、DPを利用した解法だった。
こちらのほうが応用が効きそうだったので考えてみたが、ほぼ写経になってしまった。

メモ化再帰で解いている。
`dfs(d, c) := dは現在の注目桁（小さい桁から）, cはd桁で使用可能なコインの枚数` として、
十分大きな桁では1通りとなるようにしている。

。。実際に写経してみても難しく感じる。
とはいえ、DPとしては結構重要な問題だと思う。

## [Code Formula 2014 本選 D ★](https://atcoder.jp/contests/code-formula-2014-final/tasks/code_formula_2014_final_d)

苦しんだけどなんとか自力。

[ARC032-C](https://atcoder.jp/contests/arc032/tasks/arc032_3)に似ていた。
区間スケジューリングをDPで考えるような問題で、上のARCの問題とは別の部分をしっかりと考える必要がある。

種類ごとに連続視聴するパターンで、最適なもののみを列挙して後ろからDPというのをやった。

多分[この方の手法](https://torus711.hatenablog.com/entry/20141009/1412868963)と同じことをやっているはず。
最初、種類ごとを始点ソートしてしまい、最適な連続視聴を考慮できていなかった。
こういう勘違いを減らしたい。。

## [ARC010-C](https://atcoder.jp/contests/arc010/tasks/arc010_3) @2020-07-23

時間がかかってしまったが自力。

`dp[i][S][j] := i番目までで、今までに積んだ色の集合Sで、一番最後に積んだ色、の最大スコア` を記憶しておけば良い。
計算量は大体 `5000 * 2^10 * 10` なのでOKと判断。
実際にsubmitしたら35msecとかなり高速だった。

初期化忘れを最後までなかなか見つけられず、余計に時間をかけてしまった。
`dp[0][0][m] = 0` のように、存在しない `m` 番目（0-based）の色を使ったことで、きれいな実装にできたと思う。

状態数を工夫して減らしていくのが楽しい問題だった。
**20とか（50でもいいかも）極端に小さな数が登場したら、かならずビットマスク・冪集合を検討したい。**

## [ARC098-E ★★★](https://atcoder.jp/contests/arc098/tasks/arc098_c) @2020-07-23

解説AC。ただ、かなり出だしの考察が良かったので、もう少し粘るべきだった。

「小さいものからとっていくとすると、1回目で値 `a` を取ると決めると、 `a` 未満のものは選んではならなくなる。
そのような区間しか選べない場合は、中断せざるを得ない。」というようなことは考えた。

実際にはもう少し具体的にする必要があり、 `a` 以上の値の連続部分列に関しては、その長さを `m` とすると
小さい方から `m-k+1` 個は抽出できることが（よくよく図を書いたりするとかんたんに）わかる。

そこで、 `a` を決め打ったときにこのような抽出できる要素を全体から集めて、
さらにそれを昇順ソートしたときに下から `q-1` 番目を選べば、それがその時の最大値となる。

。。結構実装力が問われる問題だと思う。
区間のこのような捉え方はかなり重要だと思うので、すぐにコードに落とせるような力があると、発想力の後押しにもなると思う。

**典型: 長さ `m` の区間から長さ `k` の連続区間の選び方は `m-k+1` 通りある。**

※この問題は、例えばtourist氏の実装を参考にするなどして勉強したほうが良い。

## [天下一プログラマーコンテスト2013予選A-C ★★](https://atcoder.jp/contests/tenka1-2013-quala/tasks/tenka1_2013_qualA_c)

@2020-07-24に着手。未AC。

3を中心に考える方針はよかったが、細部の詰めが全然だった。
実験が鍵だと思う。

- [公式解説](https://tenka1.klab.jp/2013/explain/a_c.html)
- [kmjpさんのブログ解説](https://kmjp.hatenablog.jp/entry/2013/08/04/0930)
  - DFSの枝刈りでまずは部分点を取るべき。

## [天下一プログラマーコンテスト2014予選A-C ★★★★](https://atcoder.jp/contests/tenka1-2014-quala/tasks/tenka1_2014_qualA_c) @2020-07-24

渾身の回答がガッツリ嘘解法だったので、解説AC。

- [公式解説](https://tenka1.klab.jp/2014/explain/quala_c.html)
- [kmjpさんのブログ解説](https://kmjp.hatenablog.jp/entry/2014/08/11/0900)
- [kimiyukiさんのブログ解説](https://kimiyuki.net/writeup/algo/atcoder/tenka1-2014-quala/)

kmjpさんのブログを参考にさせていただいた。

制約的にbit演算に関連した手法はもちろん想起したが、手持ちの手段が乏しくて先に進めなかった。

まず、あるパターン集合がなんらかの1つの文字列にマッチできるかどうかは、集合サイズを `n'` とすると、
`C(n', 2)` で調べられる。
これについては何回も計算するのは無駄なので、前計算して結果だけ持っておけば良い。

集合同士のまとめ上げはどうすればよいかというと、これはすべてのビットマスクの和の最適値を計算してやれば良い。
つまり、 `2^n * 2^n` をやってしまえばよい。
TLが大きめなのもあるが、 `268435456 >= 2 * 10^8` でも割と余裕で計算できてしまう（定数倍が極めて小さいからと思われる）。

**bitDPは `n` が小さいのが大きな特徴だが、その `n` が例えば18か14かなだけで取れる手段が大きく変わってくるので、**
**冷静に計算量の把握を都度行いたい！**

※↓の問題もほぼ同じbitDPの考え方が必要で、↓の制約ではもっと効率の良いことをやる必要がある！
具体的には `3^n` になるが、こちらは600msec -> 100msecとかなり高速になる。

## [天下一プログラマーコンテスト2012予選B-C ★★★★](https://atcoder.jp/contests/tenka1-2012-qualB/tasks/tenka1_2012_7) @2020-07-25

こちらも区間スケジューリングを使った適当な嘘解法しかわからなかった。

- [kusanoさんの本問題の解説ブログ](https://kusano-prog.hatenablog.com/entry/20120818/1345260509)
- [けんちょんさんのbit記事](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#7-%E4%B8%8E%E3%81%88%E3%82%89%E3%82%8C%E3%81%9F%E9%83%A8%E5%88%86%E9%9B%86%E5%90%88%E3%81%AE%E9%83%A8%E5%88%86%E9%9B%86%E5%90%88%E3%82%92%E5%88%97%E6%8C%99)
- [kimiyukiさんの「bit演算による集合の列挙」](https://kimiyuki.net/blog/2017/07/16/enumerate-sets-with-bit-manipulation/)

最初、kusanoさんのブログを読んでもわからずに放置していたが、一つ前の問題を解いて肝の部分がわかったので、
色々調べつつ取り組んでみた。

今回は `n=15` で、先程のkmjpさんの実装では `4^15 = 1073741824 > 10^9` となり厳しい（※あとで実験してみたら1900msecでギリギリ通ってしまった）。
そこで、無駄を削り「ある求めたいbit集合に対して、すべての分割を考慮して最適値を調べる」というのをやらないといけない。

調べると色々出てきて、かつてスルーしていたけんちょんさんのQiita記事を参照した。

この部分の計算量は `\sum_{i=0}^{n} 2^i * C(n, i) = 3^n` となるらしい（wolfram alphaを利用）。
ただし、実装がなぜそうなるか全く理解できていないので、少し調べたり考えたりしたい。

