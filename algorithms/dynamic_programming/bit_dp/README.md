# bit DP

ABC041 Dで初めてエンカウントした。
解説を読んでも具体的な部分がよくわからなかったので、[htkbさんの解説記事](https://htkb-procon.hateblo.jp/entry/2017/06/05/222359)を読んで理解した。

おなじみ、[けんちょんさんのbitに関する記事](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#bit-dp)についても参考にしていく。

## 本気で攻略（2019/06/25）

最初は解説を読みつつ、なれるべくいろんな問題で自力で状態と遷移を考えよう。

練習用の[はまやんはまやんさんのまとめ記事](https://www.hamayanhamayan.com/entry/2017/07/16/130151)。

### Goのビット反転

キャレット `^` を使う。

これを覚えておくと、任意桁のビットだけ0にする操作などもできるので、bitDPに限らず覚えておきたい。

### 自己流のフレームワーク

5, 6問yukicoderでbitDPの問題を解いたところ、大体のパターンが自分の中でできてきたので、
フレームワーク的なものを書いておく。

（それほど変わったことはしていないと思う。）

#### すでに考慮したものの集合のうち、最後に並んだものを記憶しなくて良いタイプ

このタイプは1次元のDPテーブルでよく、走査は 1. bit集合を全探索 2. 考慮している集合に新たに追加する「対象」を全探索、の2重ループで良いので、 `O(n x 2^n)` で済む。

```go
dp[0] = 1   // 数え上げならこのような初期化

// すべての「遷移前の」bit集合
for S := 0; S < (1<<uint(n)); S++ {
  // すべての「最後に並べる対象」
  for j := 0; j < n; j++ {
    // 遷移前のbit集合に、最後に並べようとしている対象がまだ含まれていない場合のみ、
    // 遷移を考える
    if NthBit(S, j) == 0 {
      {{ dp[S | (1<<uint(j))] <- dp[S] }}
    }
  }
}
```

遷移の部分は、個人的にこのように遷移後集合に対して、まだ立っていない `j` 番目のビットを立てる形で遷移を考えるのがやりやすい。

これミニマムな遷移の形であり、問題文によっては遷移を考慮する条件がさらに必要だったりする。
そこは適宜問題に応じてアレンジしていく。

#### すでに〜のうち、最後に並んだものを記憶する必要があるタイプ

このタイプは↑の2重ループに加えて、さらにすでに並べた集合ごとの最後の「対象」について `n` まで全探索する必要があるため、計算量の積にさらに `n` が加わることになる。

`n` が 20を超えだすと2秒の制限だと怪しくなるっぽいので、できる限り↑のパターンに持っていけるようにする。

**遷移前のbit集合から情報を得ようとすると、うまく↑のパターンに持ち込めるケースが有る。**

```go
dp[0][0] = 1   // 数え上げならこのような初期化

// すべての「遷移前の」bit集合
for S := 0; S < (1<<uint(n)); S++ {
  // すべての「最後に並べる対象」
  for j := 0; j < n; j++ {
    // すべての「遷移前のbit集合のうち、最後に並んだ対象」
    for k := 0; k < n; k++ {
      // 遷移前のbit集合に、j がまだ含まれていない場合かつ、
      // 遷移前のbit集合に、k がすでに含まれている場合のみ、
      // 遷移を考える
      if NthBit(S, j) == 0 && NthBit(S, k) == 1 {
        {{ dp[S | (1<<uint(j))][j] <- dp[S][k] }}
      }
    }
  }
}
```

