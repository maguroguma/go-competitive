# Trie

## 参考文献

- [wikipedia](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%82%A4_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0))
  - 結構わかりやすい。
  - 当然だが、競技プログラミングに限らない重要な視点も含んでいるので、読んでみると良い。
- [アルゴリズムロジック](https://algo-logic.info/trie-tree/)
  - 実装レベルの解説は一番易しかったため、コードはこちらで写経させていただいた。
  - ただし、必要最低限のみなので、細かい疑問は別途自分で解消する必要がある。
- [沙耶花さんのブログ](https://sayakaamemiya.hatenablog.com/entry/2020/08/10/225926)
  - 様々な難易度の例題を紹介してくれており、ありがたい。
  - ポインタでの実装があるととても嬉しかった（高望み）。
- [ei1333さんのライブラリ集](https://ei1333.github.io/luzhiled/snippets/structure/trie.html)
  - 例によって、競技向けに抽象化されているため、後々参照したい。

## 問題例

- [yukicoder No.430 文字列検索](https://yukicoder.me/problems/no/430)
  - 練習にはなるかもしれないが、制約がとても小さいので、普通にGo標準のmapを使っても通ってしまいそう。
- [AGC047-B First Second](https://atcoder.jp/contests/agc047/tasks/agc047_b)
  - 最低限のTrieのインターフェースだと、多分ACできない。
    - （おそらくは）文字列検索のtraverse時に追加処理を行うようなメソッドを準備しないと駄目。

## 学習

### wikipediaより

#### 概要

トライ、デジタル木、プレフィックス木などの名称。
順序付き木の一種。

あるノードの配下の全ノードは、自信に対応する文字列に共通するプレフィックスがあり、
rootには空の文字列が対応している。
**値は一般に全ノードに対応して存在するわけではなく、末端ノードや一部の中間ノードだけがキーに対応した値を格納している。**

キーが文字列である連想配列の実装構造としても使われる。

#### 利点と欠点（二分探索木との比較）

利点

- 多数の短い文字列を格納する場合にはトライの方がメモリを節約できる

欠点

- トライは状況によっては極めて巨大になる。 **例えば、少数の非常に長い文字列を格納するトライなどである。**
  - この場合はパトリシア木が適している。
- データを文字列として表すのは常に簡単とは言えない。例えば、複雑なデータ構造や浮動小数点数などをキーとする場合、工夫が必要となる。

※整数を単にビットの列と見れば、文字列と何ら変わらない。

