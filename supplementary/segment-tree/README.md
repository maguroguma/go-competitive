# セグメントツリー

Haskellの学習をしていてMonoidについての理解が多少深まったため、補習を行っておく。


<!-- vim-markdown-toc GitLab -->

* [参考](#参考)
* [通常バージョン（点加算、点更新など）](#通常点加算点更新)
  * [暗記事項](#暗記事項)
  * [暗記事項をより柔軟に考えられるように](#暗記事項柔軟考)
    * [初期化](#初期化)
    * [値の（点）更新](#値点更新)
    * [（区間の）値の取得](#区間値取得)
* [遅延評価付き（区間加算、区間更新など）](#遅延評価付区間加算区間更新)
  * [基本まとめ](#基本)
    * [初期化](#初期化-1)
    * [遅延評価関数 `eval`](#遅延評価関数-eval)
    * [区間加算・更新](#区間加算更新)
      * [評価関数が呼ばれる場所](#評価関数呼場所)
    * [区間の合成結果の取得](#区間合成結果取得)

<!-- vim-markdown-toc -->

## 参考

- [tsutajさんの通常セグメントツリーの書き方解説](http://tsutaj.hatenablog.com/entry/2017/03/29/204841)
- [tsutajさんの遅延評価セグメントツリーの書き方解説](http://tsutaj.hatenablog.com/entry/2017/03/30/224339)

---

## 通常バージョン（点加算、点更新など）

### 暗記事項

あまり深く考えずに覚えてしまったほうがいいようなこと。
導出までできたらいいけど、できてもしょうがないし忘れやすいものも多いので、とりあえず暗記ゴリ押しする。

1. セグメントツリーの各ノードは0-based
2. 葉ノード（大本の要素）の数は、元のサイズ以上になる最小の2べきの数とし、これを `N` とする
3. 木全体のノード数は `2*N-1`
4. 大本の配列の `k` 番目にアクセスしたい場合は `k + (N-1)`
5. 親→子への移動は左、右それぞれ `2*k+1, 2*k+2`
6. 子→親への移動は `(k-1)/2` （切り捨て）

1はすべての基本となることなので、絶対に覚えておくこと。

2はこのほうが例外処理が不要だから。

3は、各木の高さにおけるノードの数のビット列をイメージすると、自然とわかる。
4も3から自然と導かれる。

5, 6は導出したいがよくわからない。そういうものと思っておく。

### 暗記事項をより柔軟に考えられるように

- `N` はセグメントツリー配列の最下段のノードの数と考える。
  - 元の配列すべてを最下段で包み込みたいから、最小の2べきの数というのは合理的。
  - 最下段以外の合計が `N-1` なのは暗記してしまいたい（導出も簡単だが）。
- 親子間の移動も完全に暗記推奨。
  - 親から子: `k -> 2*k+1, 2*k+2`
  - 子から親: `k -> (k-1)/2 （あまり切り捨て）`
- 最下段の要素へのジャンプも完全に暗記推奨。
  - `k -> k + (N-1)`

#### 初期化

0. すべてのノードをモノイドの単位元で初期化。
1. 最下段を元の配列で上書き。
2. 最下段の次の段のノードで右から左→次の段で右から左→...というふうに子を合成し上書き。

#### 値の（点）更新

最下段の点更新から、上方向へと更新を繰り返す。
以下の擬似コードでは、セグメントツリーの頂上でストップする。

```
// k: 元の配列の0-basedなidx
k += N-1
for k > 0:
  k = (k-1)/2
  node[k] = node[2k+1] <> node[2k+2]
```

#### （区間の）値の取得

右が開いている半開区間で実装されているのは、累積和と似たような理由？（あまり深く考えないようにする。）

クエリ: 元の配列に関して区間 `[a, b)` の合成結果（min, max, sum, gcd, lcmなど）が知りたい

以下の3つが必要（メソッドの引数となる）。

メソッドのシグニチャ: `func get(a, b, k, l, r int) Monoid`

1. クエリの区間 `[a, b)`
2. 現在居るノードのセグメントツリー上のidx `k`
3. 現在居るノードの表す区間 `[k, l)`

再帰関数であり、関数内のアルゴリズムは、以下の3パターン。

1. クエリ区間が現在のノードの区間と交わらない → 単位元を返す。
2. クエリ区間が現在のノードの区間を完全被覆する → 現在のノードの合成結果 `node[k]` を返す。
3. クエリ区間が現在のノードの区間と一部交差する → **左、右に分割して処理を任せる、それぞれの合成結果を合成し、返す。**

1, 2は再帰関数の終了条件と言える。
終了条件以外の場合は、次々と問題が小さくなって子へと降りていく。

```
// a, bは元のクエリの区間なので不変で有ることに注意
lm := get(a, b, 2k+1, l, (l+r)/2)
rm := get(a, b, 2k+2, (l+r)/2, r)
return lm <> rm
```

※3の部分の処理が厄介なイメージがあるが、再帰関数に任せてしまえるので、
実際には1, 2で最終的に処理されていると考えられるため、多少気は楽になる。

※細かいコーディングに関しては覚えようとしないほうが良さそう
（難しいわけではないが、等号の有無など結構複雑なので、ここはスニペット化したい）。

---

## 遅延評価付き（区間加算、区間更新など）

tsutajさんのブログに沿って、要点を整理していく。

独自用語として、以下を定義。

- 値配列: 通常のセグメントツリーにもある、子の合成結果を持っておく配列。
- 遅延配列: 遅延評価用の配列。
  - ここではあまりモノイドについては意識しなくていい。
  - もしかしたら、セグメントツリーのノードが管理する要素の個数分に関するモノイドの合成結果、という見方ができるかも？
    - 区間加算の場合は `x * (要素数)` が遅延配列に入るし、区間更新の場合は `Min(x, x, ..)` が入っている、と解釈する必要がある気がする。
    - 区間加算と区間更新しか知らないため、確信は持てない。

### 基本まとめ

1. 遅延配列は、区間に一様に与えられた値を記憶している。
2. 遅延配列に中身が入っているノードにアクセスしたとき、自分と自分の子に対して値の伝搬が起こる。
3. 親ノードは、値配列が確定した状態の子ノードを参照することで更新される。

特に2について、評価関数 `eval` は再帰関数ではない点を強く意識する。
これは、 **「自ノード」と「子ノード」まで値配列が正しく反映できていれば、その時点では十分だから**。

※必要なときに必要な部分だけ遅延評価すれば良いから、効率的な処理を実現できている。

#### 初期化

遅延配列の初期化はモノイドの単位元で行う。

それ以外は通常のセグメントツリーと同じ。

#### 遅延評価関数 `eval`

必要な情報、すなわちメソッドの引数

- 自分のノードのセグメントツリー上のidx: `k`
- 自分のノードの範囲: `l, r`
  - 例に違わず、半開区間 `[l, r)` を示す。

関数の役目、やること

- 自ノードの値配列に値を伝搬させる
- 子ノードの遅延配列に値を伝搬させる
- 自ノードの遅延配列を空にする

※実装は暗記せずにスニペット化してしまう。

#### 区間加算・更新

通常のセグメントツリーとは異なり、こちらは加算や更新も区間に対して行うため、
**セグメントツリーの上から下へ** と処理が進んでいく。

##### 評価関数が呼ばれる場所

考え込むと難しく思えてきてしまうが、基本的には更新の値配列への反映漏れがないことが確認できれば良い。

すなわち、 `k` 番目のノードにアクセスしたら必ず評価関数を呼ぶようにすれば良い。

細かい部分はやはりスニペット化するのが一番。

#### 区間の合成結果の取得

こちらも評価関数を呼ぶタイミングが重要となる。

やはり大部分はスニペット化すべし。

