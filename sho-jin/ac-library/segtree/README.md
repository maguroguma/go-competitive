# Segtree

Last Change: 2020-10-04 20:31:37.

## 参考

- [GoでAtCoder Library](https://qiita.com/EmptyBox_0/items/2f8e3cf7bd44e0f789d5#segtree)
  - とりあえず拝借してこれをベースにしている。
- [セグメント木上の二分探索（beetさんのブログ）](https://beet-aizu.hatenablog.com/entry/2019/06/26/122933)
- [ちょっと変わったセグメント木の使い方](https://ei1333.hateblo.jp/entry/2017/12/14/000000)
  - セグメント木上の二分探索をpractice contestで始めて使ったため、軽く参照した。

## 二分探索のメソッド

慣れないとわかりにくいので備忘録を残す。
`func (seg *Segtree) MaxRight(l int, cmp Compare) int` しか使っていないので、
とりあえずそちらのみ記録を残す。

`type Compare func(v S) bool` という型の関数オブジェクトを渡すことになるが、
この関数オブジェクトの引数 `v S` には、セグメント木を下りながら `prod` されて出来上がった「集約された値」
が入ることになる。
そのような集約値に対する条件を記述してやれば良い。

練習問題ではrange max queryのためのセグ木を定義しており、
クエリで求められているのは、「左端を固定したときの、条件を満たす右端の「最小値」」であり、
一見して `MaxRight` にそぐわない。

このようなときは（おそらく）条件を上手く読み替える必要がある。
真偽値の単調性を図示すると、 **固定した左端から `[true, true, ..., true, false, ..., false, false]`**
のようになっていれば良い。

「左端から右方向へ集約範囲を伸ばすとMax値は単調に大きくなる」
→「このMax値がクエリで指定された値以上になるポイントのインデックスが知りたい」
**→「Max値が指定の値未満であるギリギリのインデックスを調べる」**

注意として、返ってくる `r` の値は **境目の `false` となるインデックス** であることに注意。
**そのため、引数指定の左端からセグ木の右端まですべて `true` の場合は、セグ木のデータ長である `n` が返ってくる。**

※このあたりの解釈は公式のドキュメントがわかりやすいので、迷ったら参照したほうが良い。
（伸ばしていく方向に `false` が続く、ぐらいのイメージが有るといいかも。）

※ `comp(e()) == true` という制約は特徴的なので、頭に入れておきたいかもしれない。

