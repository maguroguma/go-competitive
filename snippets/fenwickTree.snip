snippet     fenwickTree
abbr        type BinaryIndexedTree struct
options     head
  // Public methods
  // bit := NewBIT(200000 + 5)
  // s := bit.Sum(i) 						// Sum of [1, i] (1-based)
  // bit.Add(i, x) 							// Add x to i (1-based)
  // idx := bit.LowerBound(w) 	// minimum idx such that bit.Sum(idx) >= w

  type BinaryIndexedTree struct {
    bit     []int
    n       int
    minPow2 int
  }

  // n(>=1) is number of elements of original data
  func NewBIT(n int) *BinaryIndexedTree {
    newBit := new(BinaryIndexedTree)

    newBit.bit = make([]int, n+1)
    newBit.n = n

    newBit.minPow2 = 1
    for {
      if (newBit.minPow2 << 1) > n {
        break
      }
      newBit.minPow2 <<= 1
    }

    return newBit
  }

  // Sum of [1, i](1-based)
  func (b *BinaryIndexedTree) Sum(i int) int {
    s := 0

    for i > 0 {
      s += b.bit[i]
      i -= i & (-i)
    }

    return s
  }

  // Add x to i(1-based)
  func (b *BinaryIndexedTree) Add(i, x int) {
    for i <= b.n {
      b.bit[i] += x
      i += i & (-i)
    }
  }

  // LowerBound returns minimum i such that bit.Sum(i) >= w.
  func (b *BinaryIndexedTree) LowerBound(w int) int {
    if w <= 0 {
      return 0
    }

    x := 0
    for k := b.minPow2; k > 0; k /= 2 {
      if x+k <= b.n && b.bit[x+k] < w {
        w -= b.bit[x+k]
        x += k
      }
    }

    return x + 1
  }

snippet     FenwickTreeSet
abbr        type FenwickTreeSet struct
options     head
  // Public methods
  // ft := NewFenwickTreeSet(200000 + 5)
  // c := ft.Count(b.n)
  // ft.Insert(val, 1)
  // ft.Delete(val, 1)
  // ans := ft.Kth(k)

  type FenwickTreeSet struct {
    dat     []int
    n       int
    minPow2 int
  }

  // n(>=1) is maximum integer for the set.
  func NewFenwickTreeSet(n int) *FenwickTreeSet {
    newBit := new(FenwickTreeSet)

    newBit.dat = make([]int, n+1)
    newBit.n = n

    newBit.minPow2 = 1
    for {
      if (newBit.minPow2 << 1) > n {
        break
      }
      newBit.minPow2 <<= 1
    }

    return newBit
  }

  // Count returns number of elements less or equal than e in the set.
  // b.Count(b.n) returns total number of elements in the set.
  // O(logN)
  func (ft *FenwickTreeSet) Count(e int) int {
    s := 0

    for e > 0 {
      s += ft.dat[e]
      e -= e & (-e)
    }

    return s
  }

  // Insert e(1<=e<=n) for num(>= 1) times.
  func (ft *FenwickTreeSet) Insert(e, num int) {
    for e <= ft.n {
      ft.dat[e] += num
      e += e & (-e)
    }
  }

  // Delete e(1<=e<=n) for num(>= 1) times.
  func (ft *FenwickTreeSet) Delete(e, num int) {
    num *= -1
    for e <= ft.n {
      ft.dat[e] += num
      e += e & (-e)
    }
  }

  // Kth returns kth(>=0) element in the set
  func (ft *FenwickTreeSet) Kth(kth int) int {
    if kth <= 0 {
      return 0
    }

    x := 0
    for k := ft.minPow2; k > 0; k /= 2 {
      if x+k <= ft.n && ft.dat[x+k] < kth {
        kth -= ft.dat[x+k]
        x += k
      }
    }

    return x + 1
  }
