# C++における `lower_bound, upper_bound` 相当の二分探索

- 左側のindexをleft、右側のindexをrightとしたとき、 `right - left == 1` でかつrightより右側は真、leftより左側は偽となるようなleft, rightを見つける二分探索
- 初期値を配列の範囲外に設定すること、左端と右端の差が1になるまで続けることに注意
- 配列がソートされていることから真偽値についてもインデックスに対して単調性を有しており、条件判定の部分が別の関数に分けられているところがわかりやすい
    - **`mid == false` だったならば、偽であってほしい左端を `mid` で上書きし、`mid == true` だったならば、真であってほしい右端を `mid` で上書きする。**
    - 本来の二分探索と異なり `+1, -1` の移動がないため途中で無限ループになってしまいそうに見えるが、左端と右端の差が1より大きいときは必ず動く
- ~~`lower_bound` に対して `upper_bound` に実装し直す場合、 **真と偽の境界を反転させる必要がある** 点に注意~~
  - **C++の実装と異なる実装を当初行っていたこともあり、↑の考え方は一旦忘れる。**

## (2019/01/20修正)

- C++の実装に正しく修正した（はず）なので、当面は昇順ソートに対する利用に慣れる。

## 2019/02/25学び直し

[:pray:](https://qiita.com/drken/items/97e37dd6143e33a64c8c)

C++の `lower_bound()` は、

- 配列のindexのうち、key以上となる **最小** のindexを返す

結果的に、

- 配列の中に値keyがなくても、keyが配列の中で **何番目に小さいか** が分かる
- **配列の中に値keyが複数あったとき、そのうちの最小のindexをとってくることができる**
- 発展テクニックとして `upper_bound()` も併用すれば、 **配列の中に値keyをもつものが何個あるかも分かる**

## 2019/02/26真めぐる式二分探索のテストを書く

最初はよくわからなかったが、 `isOK` 関数のセッティング次第で動作を一般化できるのがわかりやすいと思った。
`ng, ok` の初期化や動かし方は統一し、もとの二分探索で右側がright（正しい、true）となるように書いたが、自分にとってはこれが一番脳に馴染んでいるように感じる。

**常に `ok` を返す、という認識さえもっておけば、変に混乱したりはしないはず。**
**（差が1になるまでしか動かず `ok` しか返さないのであれば、 `ok` は-1になることはなく、`0 ~ len(s)` が返り値の候補となる。）**

## ABC119のD問題

昇順スライスに対する等しい値の存在しないケースにおける二分探索のテストに良いかもしれない。

https://atcoder.jp/contests/abc119/tasks/abc119_d