# 参加しなかったコンテストの解き直し

Last Change: 2021-04-03 00:05:35.

基本的には自力で解けたものを書く。

---

## [ARC112 A.B=C](https://atcoder.jp/contests/arc112/tasks/arc112_a)

難しい。かなり時間がかかった。

まず `a = b + c` と変形すると `2*l <= b + c <= 2*r` という関係式は導出できる。
一方で `l <= a <= r` であることから `2*l <= b + c <= r` となり `r - 2*l = dmax` の幅が気になってくる。
取りうる「幅」は `[0, dmax]` であり、幅を `d` としたとき、そのときのtripletの数は `d+1` 通りとなる。

よってあとは累積和を事前計算しておけば、各テストケースに対して `O(1)` で回答できる。

※公式解説では等差数列の和の公式を提示していた。

## [ARC113 A.A * B * C](https://atcoder.jp/contests/arc113/tasks/arc113_a)

※ARC113はコンテスト中に問題を読んでいないので、upsolveではない。

式変形すると `A * B <= Floor(K/C)` となり、各 `C` について `(A, B)` のペアを数えれば良くなる。
`A * B <= X` を満たすものの個数は、 `X` 以下のすべての整数 `Y` についての約数の個数に等しくなるため、
累積和を用いると `O(K * sqrt(K))` で解ける。

。。なんか解説を見ると調和級数を使って解く方法が出てきた。
未知の知識をここで得たい。

## [ARC113 B.A^B^C](https://atcoder.jp/contests/arc113/tasks/arc113_b)

`A` に関しては `mod 10` をとってから考えれば良い。
`0, 1, .., 9` すべてについて実験してみると、周期4で調べれば十分になる。

指数についてはサボらずに考えると、上記から結局 `mod 4` がわかれば良さそうに見えるので、
二分累乗法によって求める。

これでOKと思って提出したら1回WAしてしまった。
よくよく考えると、あまり0のときは4乗とみなす必要があるので、そのように調整してやれば良い。

**今回のように、「1からスタートする周期のときは、余り0のときに注意」というのは教訓だと思うので、ぜひ今後意識したい。**

## [ARC113 C.String Invasion](https://atcoder.jp/contests/arc113/tasks/arc113_c)

これは整理するとかなり簡単だった。
公式解説を読むと、解法の証明はとても大変そうだが、実装はそれほど難しくなかった。

## [ARC114 A.Not coprime](https://atcoder.jp/contests/arc114/tasks/arc114_a)

確信のない解法を選ぶと危ない、というのを改めて感じた。

対象となる素数は15個程度しかないことを踏まえてビット全探索を選ぶのが模範解答どおりだった。
それでも、実際にかけ合わせた値を計算する段階でオーバーフローを気にしたりする必要があり、
容赦のない問題だと感じた。

というか、やはりBigIntをすばやく取り出せるようにしておくべきなのだろうか？

## [ARC114 B.Special Subsets](https://atcoder.jp/contests/arc114/tasks/arc114_b)

ちょっと難しくて1WAしてしまった。

確かに解説どおり、連結成分数を数えれば良かった。
しかしながら、自分の閉路検出の実装方法もなかなか賢かったと思う（再帰関数に始点のIDを持たせて、それをbool値代わりにする）。

## [ARC115 A.Two Choices](https://atcoder.jp/contests/arc115/tasks/arc115_a)

ARCとはいえ300点にしてはむずい。。

ロジカルに詰めていくと、2者の比較に置いてはXORを使えば良いことがわかる。
高速化部分を考えると400点でもいい気がするが、これに関しては数え上げのテクニックを使えば良い。

## [ARC115 B.Plus Matrix](https://atcoder.jp/contests/arc115/tasks/arc115_b)

これもなんか掴みどころがない構築だった。

全体の総和を考えると必要条件が出てくるので、
それを踏まえた上で `B` の数列を先に決め打つような感じで `A` が存在するかどうかを考えた。

模範解答では、 `A` の最小値を `0` とするとロジカルに構築できる、らしい。
