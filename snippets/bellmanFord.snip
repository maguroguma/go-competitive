snippet     bellmanFord
abbr        dist[e.to] = dist[e.from] + e.cost
options     head
  // 頂点fromから頂点toへのコストcostの辺
  type Edge struct {
    from, to, cost int
  }

  const INF = 1 << 60

  var es []Edge       // 辺
  var dist [3000]int  // 最短距離
  var v, e int        // vは頂点数, eは辺数

  // s番目の頂点から各頂点への最短距離を求める
  func shortestPath(s int) {
    // 初期化
    for i := 0; i < v; i++ {
      dist[i] = INF
    }
    dist[s] = 0

    for {
      isUpdate := false

      for i := 0; i < e; i++ {
        e := es[i]
        if dist[e.from] != INF && dist[e.to] > dist[e.from]+e.cost {
          dist[e.to] = dist[e.from] + e.cost
          isUpdate = true
        }
      }

      // 更新がなかったらループを抜ける
      if !isUpdate {
        break
      }
    }
  }

snippet     scoreAttackBellmanFord
abbr        isRoop[n-1]
options     head
  // 頂点fromから頂点toへのコストcostの辺
  type Edge struct {
    from, to, cost int
  }

  const INF = 1 << 60

  var es []Edge         // 辺
  var dist [3000]int    // 最短距離
  var isRoop [3000]bool // 閉路チェック
  var v, e int          // vは頂点数, eは辺数

  // s番目の頂点から各頂点への最短距離を求める
  func shortestPath(s int) {
    // 初期化
    for i := 0; i < v; i++ {
      dist[i] = INF
    }
    dist[s] = 0

    // まずは普通に更新
    for c := 0; c < v; c++ {
      isUpdate := false

      for i := 0; i < e; i++ {
        e := es[i]
        if dist[e.from] != INF && dist[e.to] > dist[e.from]+e.cost {
          dist[e.to] = dist[e.from] + e.cost
          isUpdate = true
        }
      }

      // 更新がなかったらループを抜ける
      if !isUpdate {
        break
      }
    }

    // 閉路チェック
    for c := 0; c < v; c++ {
      for _, e := range es {
        // 起こらないはずの更新が起こる
        if dist[e.from] != INF_BIT60 && dist[e.to] > dist[e.from]+e.cost {
          dist[e.to] = dist[e.from] + e.cost
          isRoop[e.to] = true
        }

        if isRoop[e.from] {
          isRoop[e.to] = true
        }
      }
    }
  }

