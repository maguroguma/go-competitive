# 閉区間のマージ

- 1次元上の線分のマージ。Codeforcesでそれなりに使うことになりそう。
- 目的によっては、いもす法でも代替可能な気がする。

以下は、Educational Codeforces Round 77のD問題で書いたコード。

```go
segments := []Trap{}
l, r := 0, -1
for i := 0; i < len(L); i++ {
  t := L[i]
  if t.d <= m {
    continue
  }

  if r == -1 {
    l, r = t.l, t.r
    continue
  }

  if r >= t.l-1 {
    // マージして継続
    // r = t.r
    ChMax(&r, t.r)
  } else {
    // マージせず中断して追加
    segments = append(segments, Trap{l: l, r: r})
    l, r = t.l, t.r
  }
}
if r != -1 {
  segments = append(segments, Trap{l: l, r: r})
}
```

## アルゴリズム

アルゴリズムは非常に直感的かつ単純だけど、油断するとバグらせやすいので注意する。

1. 区間の左端をキーとしてソートする。
2. 最初の区間でポインタ `l, r` を初期化する。この区間が併合元となる。
3. 次の区間に関して、
  - 次の区間の左端が `r` 以下の場合は、併合元の区間と交差しているため、併合する。さらに、併合元の区間の右端を、大きい方で更新する。
  - 次の区間の左端が `r` より大きい場合は、併合元の区間と交差していないため、次の区間を併合元に更新する。

※併合の更新には注意する。

※ループ処理する場合、ループを抜けた後の後処理を忘れないようにする。

