# 日本情報オリンピック過去問

Last Change: 2020-09-12 18:51:20.

難しかったものや癖のあるものだけメモしていく。

## [E. 品質検査 ★](https://atcoder.jp/contests/joi2007yo/tasks/joi2007yo_e)

なんとなく難しかったが、翌々考えたら解答PDFのにある通り、ほとんどの場合が不明としてしまって良い。

これは、「不明なものはすべて異常としてしまう」や「1つだけ正常にして後はすべて異常としてしまう」が
trueとなりえることを考えるとわかる。

「極端な状況を考える」というのは重要かもしれない。
最近は見ない類の問題だが、論理として重要なので覚えておきたい。

## [B. 最長の階段](https://atcoder.jp/contests/joi2007ho/tasks/joi2007ho_b)

くる式Union Find活用法によってきれいな実装ができる。

## [B. factorial ★](https://atcoder.jp/contests/joisc2007/tasks/joisc2007_factor)

個人的に苦手というか、多分ABCで出たら茶から緑ぐらいなんだけど自分は遅くて悲しい思いをする、というタイプ。

[らてさんと同じ解き方](https://lattemalta.hatenablog.jp/entry/2015/09/16/032833)をしていると思うが、
多分二分探索は不要な解法がある気がする。
とはいえ、このような素数の数え方（？）は過去のABCでも見た気がするので、もっとスムーズにできるようにしたい。

**`n!` の中に含まれる素因数 `2` の個数は、 `n/2 + n/4 + n/8 + ...` で数えられる。**

## [C. mall](https://atcoder.jp/contests/joisc2007/tasks/joisc2007_mall)

2次元累積和をやるだけ。

なんで急にTL6secとかになったんだろう。。？

## [D. building](https://atcoder.jp/contests/joisc2007/tasks/joisc2007_buildi)

LISを求めるだけ。
しかも制約的に `O(N^2)` の愚直なDPが通る。

## [G. Fiber ★](https://atcoder.jp/contests/joisc2007/tasks/joisc2007_fiber)

Union Findで連結成分の数を求めて、それを `x` とすると、答えは `x-1` になる。

簡単ではあるが、木グラフのように `(森の数) - 1` みたいなことをやる難しめの問題もあったので、
一応見逃しやすい典型として覚えておきたい。

## [B. 共通部分文字列 ★★](https://atcoder.jp/contests/joi2008ho/tasks/joi2008ho_b)

この問題はよく覚えておいたほうがいのかもしれない。

ABC141-EのようなDPを練習のつもりでやってみたが、メモリ制約が厳しいため `int16` を用いる必要がある。

あるいは、ローリングハッシュでも解けると思われる。

一方で、解説PDFの手法はかなり特殊。
役に立つかはわからないが、一度なぞってみると良いかもしれない。

## [A. IOIOI ★★](https://atcoder.jp/contests/joi2009ho/tasks/joi2009ho_a)

これも解くだけなら適当にローリングハッシュを使えば良い。
KMP法などの練習にもいいらしいので、それの練習としてみたい。

## [D. カード並べ](https://atcoder.jp/contests/joi2010yo/tasks/joi2010yo_d)

`P(n, k)` の文字列型のpermutationパターンを全列挙するライブラリを使えば良い。

## [A. JOIポスター ★](https://atcoder.jp/contests/joisc2010/tasks/joisc2010_poster)

かなり時間がかかってしまった。

再帰で解けるらしいが、ちょっとよくわからない。。
再帰の解き方もわかっておくべきな気がするが。。

自分がやった方法は、どのフラクタルに所属するものか調べてから、そのフラクタルの左上・右上・左下のどこに所属しているのか、
を1つ1つチェックしていくというやり方。
多分計算量は `O(2^n * n)` のはず。

## [A. contest](https://atcoder.jp/contests/joisc2010/tasks/joisc2010_contest)

言われたとおりにシミュレーションするだけ。
計算はまとめて後でやるだけでよく、ただひたすらにめんどくさいだけ。

## [C. 最高のピザ](https://atcoder.jp/contests/joi2012yo/tasks/joi2012yo_c)

難易度5の中でもかなり簡単。

カロリーの高いトッピングを貪欲に選べばよく、全種類数探索するためには累積和を使えば良い。

TL10secなので、累積和使わなくても多分大丈夫。

## [A. JJOOII](https://atcoder.jp/contests/joi2012ho/tasks/joi2012ho1)

雑にやりすぎて1WAしてしまった。

一瞬迷ってしまったが、ランレングス圧縮すると見通しが良くなる。
真ん中のOを基準にして考察を進めると良い。

解説が豊富ですごい。

## [B. たのしいカードゲーム](https://atcoder.jp/contests/joi2012ho/tasks/joi2012ho2)

答えを二分探索した。
各探索では `O(a * b)` なので、全体で `O(a * b * log(Max(a, b)))` でいける。

解答PDFを観ると、「Bの上から何枚除去するか？」を全探索するだけでよいことがわかり、
logがつかないより効率的な解法が想定解法となっていた。

## [A. ストーブ](https://atcoder.jp/contests/joi2018ho/tasks/joi2018ho_a)

こどふぉでありそうな感じだと思った。
セグメントをマージするスニペットのverify問題としていいかもしれない。

区間をマージしてその間を最適に埋めるような問題。
微妙にややこしくて早解きが難しい。

## [A. 勇者ビ太郎](https://atcoder.jp/contests/joi2019ho/tasks/joi2019ho_a)

累積和を行方向と列方向で求められれば良い。
区間の終端は固定なので、もっと賢くできるかもしれない。

適当にメモリを取ると256MBだけどMLEしてしまう。
累積和部分については `int16` とすることで十分余裕ができた。

## [B. いちご](https://atcoder.jp/contests/joi2020yo2/tasks/joi2020_yo2_b)

エレガントな解法もあるっぽいが、素直に貪欲法に落として、それをシミュレーションするのが良いと思う。

個人的に苦手な実装で、サンプル通すのに結構時間がかかってしまった。

## [C. 桁和 ★](https://atcoder.jp/contests/joi2020yo2/tasks/joi2020_yo2_c)

かなり変なDPのようでDPでもないなにかをしてしまった気がする。

解説PDFにあるように、大きいものから「最終的にNに到達できるか？」というのをチェックすれば良い。
より具体的には、例えばある `x` とその桁和 `d(x)` があるとして `dp[x+d(x)]` の真偽で `x` の真偽も表される。

この手の問題は苦手なので、もっとスムーズに、正しく解けるようにならないと行けない。

