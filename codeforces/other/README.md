# Codeforcesの1200~1800の問題

Last Change: 2020-06-22 00:15:22.

math, number theoryタグも結構解いたので、その他の苦手も克服する。

## [1366C ★](https://codeforces.com/problemset/problem/1366/C) @2020-06-18

1500。考察は簡単だが、実装で迷走したので模範解答を読んだ。

マンハッタン距離でグループ分けしたり、forループも素直にまわすのみだったり、模範コードがかなり勉強になる。
グループ分けという発想は特に汎用的だと思うので、意識して身につけたい。

```go
	// 普通の二重ループでスキャン、グループごとに1/0の数をカウントする
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			cnts[i+j][A[i][j]]++
		}
	}
```

## [1366B ★](https://codeforces.com/blog/entry/78735) @2020-06-18

1300。自力。

セグメントの交差判定は模範解答のものを覚えたほうが良いかもしれない。

「左端の大きい方と、右端の小さい方を比較して、区間が残れば良い。」

```python
for _ in range(int(input())):
    n, x, m = map(int, input().split())
    l, r = x, x
    for _ in range(m):
        L, R = map(int, input().split())
        if max(l, L) <= min(r, R):
            l = min(l, L)
            r = max(r, R)

    print(r - l + 1)
```

## [1363C](https://codeforces.com/problemset/problem/1363/C) @2020-06-18

1600。ゲーム系では簡単な方だと思うが、解説AC。

終わりの状態をイメージする系だが、DPで全探索するとかではないので、自信を持って詰めるのが難しいと感じた。

## [1363B](https://codeforces.com/problemset/problem/1363/B) @2020-06-18

1400。自力。

AtCoderの企業コンテストで似たようなのがあった気がする。

`00..011..1` or `11..100..0` と比較する全探索をするという大方針は模範解答どおりだったが、
自分のACコードだと `10^8` ぐらい計算が必要なはずで、本番ではとても提出できないものになった。

ちゃんとコスト計算の部分も効率化する必要があり、これは累積和っぽいやり方でできる。

## [1355B](https://codeforces.com/problemset/problem/1355/B) @2020-06-18

1200。自力。

ソートして貪欲にグループを作っていけば良い。
あまりは次のグループに持ち越す。

DPでもできるっぽい？

## [1354B ★](https://codeforces.com/problemset/problem/1354/B) @2020-06-18

1200。自力。

模範解答はエレガントという感じだったが、自分は尺取法でやった。
蟻本の種類数で考える尺取法は時々思い出しておきたい。

```go
	// しゃくとり法により解を求める
	r := 0
	num := 0
	ans := 1 << 60
	count := make(map[int]int) // 事柄->出現数の対応
	for l := 0; l < n; l++ {
		for r < p && (num < n) {
			// sum += A[r]
			// r++
			if count[A[r]] == 0 {
				// 新しい事柄が出現
				num++
			}
			count[A[r]]++
			r++
		}

		// ans += (r - l)
		if num == n {
			ChMin(&ans, r-l)
		}

		if r == l {
			r++
		} else {
			// sum -= A[l]
			if count[A[l]] == 1 {
				// ある事柄の出現数が0になった
				num--
			}
			count[A[l]]--
		}
	}
```

## [1351C](https://codeforces.com/problemset/problem/1351/C) @2020-06-19

1400。自力。

ちょっと戸惑ったが、移動前と移動後の座標を単純にベクトル和を取るだけで、セグメントをハッシュ化できる。
ハッシュマップで通過判定を管理すればよい。

## [1353D ★★](https://codeforces.com/problemset/problem/1353/D) @2020-06-19

1600。わからなくてtutorialを読んだ。

基本は実装で立ち向かうことになるが、愚直にやるとすぐ `O(N^2)` になってしまうので、priority queueを使う。
キューに突っ込むものを構造体にし、比較関数で操作すべきセグメントが取得できるように `comparator` を定義してやれば良い。

改めてpriority queueのパワーを感じられる良い問題だと思った。

## [1343C](https://codeforces.com/problemset/problem/1343/C) @2020-06-19

1200。自力。

ランレングス圧縮でやった。
実装はそんなに楽ではないと思う（工夫しないとバグりやすそう）。

## [1343D ★](https://codeforces.com/problemset/problem/1343/D) @2020-06-19

1700。わからず。

ペアに関して「変更なし、1個だけ変更、2個とも変更」までに至ったのは良いが、そこからの全探索パートの効率化がわからず。
それぞれについて個別に条件を考えて数え上げに正しく落とし込むのが大事。
それが明確にできれば「いもす法などが必要」とか必要なデータ構造とアルゴリズムが想起できると思う。

## [1341B](https://codeforces.com/problemset/problem/1341/B) @2020-06-20

1300。自力。

問題設定を読み解くのがめんどいのと、単に累積和で全探索するだけだけど、気をつけるポイントは多い。
早くコーディングできることが重要。

## [1340B ★★](https://codeforces.com/problemset/problem/1340/B) @2020-06-20

1700。詰めきれず解説AC。

`dp [2000][2000]string` がすぐに思い浮かんだので実装したが、そもそもバグを除去するのが大変だった。
結局別に `dpf [2000][2000]bool` という情報も作り判定してサンプルは通ったが、MLEしてしまった。

よくよく考えると `dp [2000][2000]string` 部分が大きすぎる。
情報としては `dpf` だけで十分で、ここから復元してやる必要がある。
ただし、上の桁から貪欲に大きくする必要があるため、DPする順序を下の桁から考えるなどは注意が必要。

## [1339B ★](https://codeforces.com/problemset/problem/1339/B) @2020-06-20

1200。だけど全くわからず解説を読んだ。

ソートして真ん中からジグザグして端に寄っていけばよい。
確かにtutorialにある通り、図示すればなんとか自力で解けた可能性はある。。

## [1340A](https://codeforces.com/problemset/problem/1340/A) @2020-06-20

1500。自力。

複雑に見えるが、一様なところからある場所が選ばれると、そこから選べなくなるまで後ろに連続して選ばざるを得なくなる。

チェックするための条件が自分は `P[i+1] - P[i] > 1` で十分だと思ったが、
模範解答はもっと面倒なことをやっているので、もしかしたら嘘解法なのかもしれない。

※模範解答では、しゃくとりっぽくイテレータが `P` を2周するような計算量になっているように見える。
とにかく、愚直に条件をチェックするなら計算量には注意が必要。

## [1335D](https://codeforces.com/problemset/problem/1335/D) @2020-06-20

1300。自力。difficultyの割に難しい。

9箇所いい感じに壊せばOKと思って、いい感じを最初に列挙してインクリメントしたが、
tutorialの通り「すべての1を2に変更すればOK」が簡潔だった。

頭が固い。

## [1336A ★★](https://codeforces.com/problemset/problem/1336/A) @2020-06-21

1600。貪欲要素で嘘解法に陥ったため解説を読んだが、そもそも解説の理解に時間を要した。

「tourismのノードの祖先にindustryのノードはない」というのは貪欲の交換で考える論法からすぐわかる。
これを踏まえると「 `n-k` 個のtourismを選ぶ」という風に考えて、各ノードをtourismに選んだときの利得が計算できる。
これを大きい順に `n-k` 個加算すればよい。

利得自体は `自分を含めた部分木のsize - 根を1とした自分の深さ` で計算できるが、これも理解が結構難しい。。
利得加算時とindustryの分布は異なるわけだが、深さを引いたりしている部分でしっかりと帳尻が取れることになる。
償却のイメージをしっかりと持てるようになりたい。

難しい問題だと思う。

## [1332C ★](https://codeforces.com/problemset/problem/1332/C) @2020-06-21

1500。実装は解説を参考にした。

union findを利用すれば実験はできるので、そこから法則を見つける。
すると、長さ `k` の回文が `n/k` 個つながる形になるので、それをもとにあとはすべてのグループに対して
すべての文字に変換した場合の全探索を行う。

実装は難しいが、模範解答のものは参考になる。

- 周期性の活用
- 重複を割る2で処理する
- データ構造

## [1333C ★★](https://codeforces.com/problemset/problem/1333/C) @2020-06-21

1700。早々と解説を読んだ。

まずは各要素を左端とした部分配列の個数を愚直に足し上げていく、素直な方法からスタートする必要があった。
すると、goodな部分配列は連続し、あるところで途切れるとそこからはすべてnot goodになるという性質が見つかる
（この時点で単調性が見えてくる）。
また、累積和を使うと「同じ値が登場したところがそのような箇所」であるといえる。

これは愚直にやると `O(N^2)` なので、単調性を利用して高速化することを考えると、しゃくとり法が設計できる。

しゃくとりの条件部分は、蟻本の例題のようにハッシュマップでカウントを保持するやり方で良いが、
safe conditionの部分やハッシュマップの初期設定は添字に注意して慎重に実装しないと、
サンプルすら通せなくなってしまうので注意。

**累積和上で尺取法するときは十分に気をつけること！**

※ちゃんと累積和 `P` 上で尺取法を考えると、自分にとってしっくりするコードが書けた。

## [1328C](https://codeforces.com/problemset/problem/1328/C) @2020-06-21

1200。自力。

問題設定は面白いが、複雑に見えてとても簡単。
大きいほうが出来上がったら、のこりは貪欲に小さい方に押し付けるのがお得。

## [1328B](https://codeforces.com/problemset/problem/1328/B) @2020-06-21

1300。自力だが、サンプル通すまでに時間がかかった上に、オーバーフロー周りのペナも2回踏んでしまった。
掛け算がでたら `int64` ！

等差数列の和を考えて、二分探索と組み合わせながらやった。
が、添字部分で頭がこんがらがり、えらい目に合った。

模範解答のコードは二分探索などせずシンプルだが、結局は添字の部分で同じような辛さがあると思った。

## [1327C](https://codeforces.com/problemset/problem/1327/C) @2020-06-22

1600。自力。

構築に分類されると思う。
この手の操作回数の上限が与えられるタイプは十分なことが多い。
なので、シンプルかつ愚直な方法を考案し、その回数が足りていることを証明できれば良い。

今回は `n*m - (n+m) + 3 > 0` となる（はず）。

