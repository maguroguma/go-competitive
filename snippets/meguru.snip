snippet     meguruBinarySearch
abbr        ng, ok := -1, len(A)
options     head
  ${1:isOK} := func(mid int) bool {
    if C(mid) {
      return true
    }
    return false
  }

  ng, ok := -1, len(${2:#:SliceName})
  for int(math.Abs(float64(ok - ng))) > 1 {
    mid := (ok + ng) / 2
    if $1(mid) {
      ok = mid
    } else {
      ng = mid
    }
  }

snippet     meguruFunction
abbr        func BinarySearch(initOK, initNG int, isOK func(mid int) bool) (ok int)
options     head
  func BinarySearch(initOK, initNG ${1:int}, isOK func(mid $1) bool) (ok $1) {
    ng := initNG
    ok = initOK
    for int(math.Abs(float64(ok-ng))) > 1 {
      mid := (ok + ng) / 2
      if isOK(mid) {
        ok = mid
      } else {
        ng = mid
      }
    }

    return ok
  }

snippet     upperAndLowerBound
abbr        func upperBound(A []int, a) int
options     head
  // Aは昇順ソート済み
  func upperBound(A []int, a int) int {
    // m は中央を意味する何らかの値
    isOK := func(m int) bool {
      if A[m] > a {
        return true
      }
      return false
    }

    ng, ok := -1, len(A)
    for int(math.Abs(float64(ok-ng))) > 1 {
      mid := (ok + ng) / 2
      if isOK(mid) {
        ok = mid
      } else {
        ng = mid
      }
    }

    return ok
  }

  // Aは昇順ソート済み
  func lowerBound(A []int, a int) int {
    // m は中央を意味する何らかの値
    isOK := func(m int) bool {
      if A[m] >= a {
        return true
      }
      return false
    }

    ng, ok := -1, len(A)
    for int(math.Abs(float64(ok-ng))) > 1 {
      mid := (ok + ng) / 2
      if isOK(mid) {
        ok = mid
      } else {
        ng = mid
      }
    }

    return ok
  }

