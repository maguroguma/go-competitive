# difficulty順に埋める

Last Change: 2020-07-04 17:14:11.

@2020-06-29より、埋めていないところから順に埋めていく。
おそらくは復習が必要な問題が並ぶはずなので、最初から集めておく。

## [ABC161-F ★](https://atcoder.jp/contests/abc161/tasks/abc161_f) @2020-06-29

こどふぉならmath, number theoryタグがついてdiff 1600ぐらいになりそうな問題。
でもわからずに解説AC。

剰余の推移に目をつけたのは良かったが、逆から考えようとした時点で間違いだった。

ていうか誤読してた、死にたい。

## [ABC030-D](https://atcoder.jp/contests/abc030/tasks/abc030_d) @2020-06-30

[ABC167-D](https://atcoder.jp/contests/abc167/tasks/abc167_d)とほぼ同じな気がする。

バカでかい `k` の対処は桁DPなどでよくある剰余の扱いをすればよいが、違いはそこだけだと思う。

これもダブリングをするとライブラリ貼るだけとかにできるのかもしれないが、
ライブラリチェックはよりシンプルな問題の方だけで試せば良い気がする。

## [AGC044-A ★](https://atcoder.jp/contests/agc044/tasks/agc044_a) @2020-06-30

難しい。答えを効いても計算量見積もりが非常に難しい。
すぬけさんの解説放送でのざっくりとした見積もりが一番わかり易い気がする。

とりあえずは「ハッシュマップを使ったメモ化再帰」というのがこの問題で一番手にしておきたい経験値だと思う。

## [ABC025-C ★★](https://atcoder.jp/contests/abc025/tasks/abc025_c) @2020-07-01

答えを見たが面白かった。ゲーム木の基本問題として覚えておきたい。

ゲーム木の考え方（再帰部分）もそうだが、
「ゲームにおいて最大化と最小化を考える2プレイヤーがいるとき、総和が一定であることに注目すると見通しが良くなる」
という部分は応用の幅が広そうであるため、ぜひ覚えておきたい。

## [ABC013-D](https://atcoder.jp/contests/abc013/tasks/abc013_4) @2020-07-01

自力。ダブリングの練習ができた。

ダブリングのコードは[けんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2020/06/20/190700)
がわかりやすかったので、変数名なども含めて写経した感じになった。

## [ARC023-C](https://atcoder.jp/contests/arc023/tasks/arc023_3) @2020-07-02

自力。

逆元が一般的でなかった時代の過去のもの。
注意点としては、制約が最近では見ない感じで、もろもろを前計算する自前の組み合わせライブラリではうまく行かず、
コンビネーションを愚直に計算しないと駄目なタイプだった。

## [ABC011-D ★](https://atcoder.jp/contests/abc011/tasks/abc011_4) @2020-07-02

解説AC。

場合の数なら簡単だが、確率を求めろとなると場合の数を考えると失敗してしまう。

パスカルの三角形を応用すると、 `C(n, r), r = 0, 1, .., n` までのすべての組み合わせの確率が直接求まる。
この事実をうまく利用すると、所望の確率が計算できる。

ポイントは、一度場合の数の考え方をリセットして忘れて、 `C(n, r)` に閉じた積事象の確率で考えること。

`O(N^2)` で任意の確率が求まる可能性があることについては覚えておきたい（これから出題される可能性は低そうだが）。

## [ABC023-D](https://atcoder.jp/contests/abc023/tasks/abc023_d) @2020-07-03

自力。

最大値の最小化といえば二分探索がまっさきに思いつくので、そこを狙って考えれば簡単だと思う。

判定関数の中でソート処理が含まれるので計算量にはlogが2つつくことになるが、
制限時間が5秒なので大抵の言語で余裕だと思う。
Goだと1100msecぐらいだった。

## [ABC014-D](https://atcoder.jp/contests/abc014/tasks/abc014_4) @2020-07-04

自力。

木のLCAを求めて、与えられたノード2つの根からの深さとLCAの根からの深さを用いて計算してやる。
LCAの利用問題としては最易の部類だと思う（ので、verify用問題として良さそう）。

※LCAは0から掛ける必要はないが、アルゴリズムの動作原理や内部で保持しているデータ構造（ `depth` ）については理解しておくべきだと思う。

