# 日本情報オリンピック過去問 難易度6まとめ

Last Change: 2020-10-30 00:03:42.

## [B. お菓子の分割 ★★★](https://atcoder.jp/contests/joi2010ho/tasks/joi2010ho_b)

わからなくて解説を読んだのにオリジナルの実装で非常に苦労した。

DPでやりたいなぁと思いつつ、遷移はおぼろげながらイメージが付いても状態の持ち方がわからず、解答を漁った。

[kutimotiさんのブログ](http://kutimoti.hatenablog.com/entry/2018/01/19/234001)が参考になったが、微妙に実装はオリジナルに変えた。

「1つ1つ区切られたお菓子を片方の人に配り続け、コストを支払うことでもう片方の人へ分配をチェンジできる」
と問題文を読み替えることが最重要。
そうすると、「以前どこで切ったのか？」というような情報を持たずに済む。

**「ステートレスに考える」**
とも捉えられそう、な気もするし、そういう言い方は不適切な気もする。

結局、自分の場合 `[M][M][Y][Y][M]...` のようにブロックを分けるように考えて、
`dp[i][j][M or Y] := i番目まで観たとき、自分がj個お菓子を獲得しているときの、コストの最小値`
として考えた。

ただし、初期化と遷移が微妙に難しい。
コストを考えるポイントはお菓子に相当するブロックではなく、ブロック間の「仕切り部分」であることから、慎重に進めなければならない。

## [B. IOI列車で行こう ★★★★★](https://atcoder.jp/contests/joi2013ho/tasks/joi2013ho2)

DPの発想すらできなかったので完敗だった。  
「とりあえず考えられる並びを全探索して、そこで出来上がる部分文字列で最大のものを取ろう」というのがベースの考え方。  
なので、弱い制約では愚直な全探索ができるし、中程度の制約では値がbool値の「（やや）自明なDP」が通るようになっている。

満点回答は `dp[i][j][flag] := Sからi文字分, Tからj文字分とって作る文字列の最大長、ただしフラグによって末尾が変わる`
というような状態を考えることで計算できる。  
これはLCSのような貰うDPを考えるのが簡単だが、なんか初期化方法がよくわからなくて無理やり配るDPを書いてしまった。

※あとで貰うDPでも解いてみたが、この場合はLCSとは違って、 `dp[0][0~m]` と `dp[0~n][0]` の初期化が最初に必要となることに注意する。

## [E. 魚の生息範囲 ★★★](https://atcoder.jp/contests/joi2013yo/tasks/joi2013yo_e)

3次元の座標圧縮。

この問題では、 `x-1, x, x+1` のように、一点あたり3つの座標を放り込むとなぜか（体積計算が）うまく行かなかった。  
また、そもそもこのような点の増やし方はメモリがめちゃくちゃ増えてしまうので、むやみやたらにやるのはやめたほうがいいと思われる。

※追記: 普通に最後のforループの上限を変更し忘れていたからだった。

## [C. バームクーヘン ★★★★](https://atcoder.jp/contests/joi2014ho/tasks/joi2014ho3)

二分探索だが、この形は始めてで面白かった。

**分割して出来た値の最小値の最大化を考えるとき、**
**「すべての分割してできたオブジェクトが `x` 以上かどうか？」という判定問題の二分探索を行うことで解ける**
、というのは初めて出会うタイプの問題だった。

この問題では、判定問題を解く中でも更に2回二分探索をする必要があり、全体の計算量はlogが2つつく形になる。

※尺取法を使ってlogを1つ削ったり、全体で尺取法しか使わずに定数オーダーで解くことも出来てしまうらしい。

## [C. JOI公園](https://atcoder.jp/contests/joi2015ho/tasks/joi2015ho_c)

難易度7の中でようやく自力で解けた。というか今の所これだけぶっちぎりで簡単だった。

とりあえずダイクストラ法すれば単一最短経路の距離はわかる。  
結果をIDを保持しながら昇順ソートすれば、広場1に近い順にスキャンできる。  
ここで、ベースの値を「舗装すべき全ての道路の長さの和」として、これを地下道を作ることで緩和していく方針で考える。  
ソート結果から `x` を0から離散的にすべて調べることが出来、また、ある広場を調べるときに、
その隣接リストをスキャンすれば、すでに相互接続されている広場が確認できる。  
この部分の計算量は `O(n + m)` になるので、実装上二重ループになっても全く問題ない。

## [M. ストラップ](https://atcoder.jp/contests/joisc2014/tasks/joisc2014_m)

これも自力で解けた。1WAしたけど。。

DPなのはすぐわかる。  
`dp[i][j] := i番目までみたときに残りの穴数がj個の場合の最大` とすれば良い。  
`j` が普通にやると `10^6` になってしまうが、ストラップの付け方から、穴の数は `n` 個アレば十分なので、 `j <= n` までで十分。

WAの原因は、穴の数で降順ソートしていなかったため。  
ソートしておかないと、途中でストラップの穴がなくなってしまう可能性がある。  
厳密には、ソートしなくても、穴が0個のストラップさえ後ろに回せば、それ以外の順序は問題ない。

## [E. 砂の城](https://atcoder.jp/contests/joi2015yo/tasks/joi2015yo_e)

ちょっと迷ったが、わかってしまえば簡単だった。

愚直に考えると、ドットの位置から強度分削っていきたい気持ちになる。  
一見すると計算量が爆発してしまうように見えるが、1ドットあたり1回しかその処理をしないように考えると、
普通に1ドットに付き周囲の8マスをデクリメント、とするだけでよい。

あとはQueueを使ってFIFOで処理していけば良い。

## [C. JOI国の買い物事情 ★★★](https://atcoder.jp/contests/joi2011ho/tasks/joi2011ho3)

道路の中点に街を増やした状態でダイクストラ法するだけかと思ったが、全然違った。

まず、道路の中点に街を置く方法は間違い。  
ショッピングモールから最も遠い街がそこになるとは限らない。  
[すぬけさんのブログ](https://snuke.hatenablog.com/entry/20110215/1297774787)にある通り、
すべての道路について `(dp[x] + dp[y] + e(x, y)) / 2` を計算してやれば、その道路に関しては最も遠い距離がわかる。

Goで四捨五入を初めてやった気がするが、やはり実数を使わなくて済むなら、偶奇性で場合分けして整数型に閉じるべき。

## [E. 尾根 ★★](https://atcoder.jp/contests/joi2017yo/tasks/joi2017yo_e)

ちょっと難しく考えてしまって迷走してしまった。

自分が最初考えた手法は、標高が小さいところ、特に周りに自分寄り高い標高しかないような場所は尾根にならず、
そこを起点として有向グラフを作る。  
低いところから高いところへと有向辺を張ると、閉路が出来ないためトポロジカルソートが出来、DPを考えられると思った。  
具体的には、起点を `dp[i] = 1` として、そこから値を加算していけば、雨がたまる地域の数が求まり、これが2以上となる地域の数が答え、とした。

しかしながら、これは雨が溜まる地域を重複して数えることがあるため、嘘となる。  
重複を省くことを考えなければならない。

ここは回答を観てしまったが、大事なのは雨が溜まる厳密な数ではなく、つまるところ「尾根かどうか？」が判定できれば良い。  
このためには、最終的に雨がたまる地域が「1つ以下か2つ以上か」ということさえわかれば十分となる。  
言い方を変えると、重複を省くために、雨がたまるエリアの情報はほしいが、「それは最大でも2個までで十分」といえる。  
よって、DPテーブルをスライスとして、遷移先のスライス長が1つ未満の場合のみ、遷移元のスライスとマージする、という処理を行えば良い。

。。一応通ったが1300msecぐらいかかったし、メモリ量も大きかったのであまりいい実装ではなかったかもしれない。  
でも、グラフで考えるとノード数は `10^6` だし、他のC++の回答とかも見渡すと400msecぐらいはかかっているので、どのような実装を選んでも大して変わらないかもしれない。

## [F. ヘビのJOI君 ★★★](https://atcoder.jp/contests/joi2017yo/tasks/joi2017yo_f)

いわゆる拡張ダイクストラ。苦労の末一応実装できたと思うが。。

自分のダイクストラライブラリに適用しようと、最初に完全なグラフを作ってしまうと、どうあがいてもMLEしてしまう。  
通してる人をざっと見渡すと、どうやら「グラフは素の状態で持っておいて、各状態ごとに最適値を管理し、遷移を逐次処理する」という方法をとっている。

ライブラリを弄ることでなんとか通せた。  
グラフ自体はもとの形のまま保持し、遷移を考えるところを調整した。  
すると時間は200msecほど、メモリは60MBほどでだいぶ余裕を持って通せた。

拡張ダイクストラで考えられる辺を予めすべて張る方法は非推奨かもしれない。  
メモリ1GBなら心配なさそうだが。。  
経験値がまだまだ足りないので、これから問題を経験していきたい。

## [D. 水ようかん ★★★](https://atcoder.jp/contests/joi2018yo/tasks/joi2018_yo_d)

なんか色々と迷走してしまったが、自明なDPから詰めていくのが面白い問題だと思う。

`dp[i][j][k] := i番目でカットするようなi番目までの切り方で、最小値j、最大値kを達成できるかどうか` をまずは考える。  
制約的にこれでは満点にならないので、次に以下のようにDPテーブルを修正する。  
`dp[i][j] := i番目でカットするようなi番目までの切り方で、最小値jのときに達成可能な「最大値の最小値」`

区間DPのような遷移を `dp[i] に対して i=0,1,..,i-1` まで片側で考えるようなイメージ。  
そこまでわかっていてもちょっと遷移が特殊で難しい。  
また、初期化の仕方もちょっと特殊だと思うので、また忘れた頃に解き直したい気がする。

## [E. 森林伐採 ★★](https://atcoder.jp/contests/joi2018yo/tasks/joi2018_yo_e)

なんとか自力AC。

これも拡張ダイクストラ。。かと思いきや、答えは普通のDPで考えていた。  
一応、グリッドとそこへ至る経路長の情報があれば、拡張ダイクストラできる。

## [B. 美術展](https://atcoder.jp/contests/joi2018ho/tasks/joi2018ho_b)

変数分離で割とすんなり解けた。

