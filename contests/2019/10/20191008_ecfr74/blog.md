Cで本当にしょうもないミスをしてしまった。。

Dについても近々追記するかと思います。

<!-- TOC -->

- [A. Prime Subtraction](#a-prime-subtraction)
  - [問題](#%e5%95%8f%e9%a1%8c)
  - [解答](#%e8%a7%a3%e7%ad%94)
- [B. Kill 'Em All](#b-kill-em-all)
  - [問題](#%e5%95%8f%e9%a1%8c-1)
  - [解答](#%e8%a7%a3%e7%ad%94-1)
- [C. Standard Free2play](#c-standard-free2play)
  - [問題](#%e5%95%8f%e9%a1%8c-2)
  - [解答](#%e8%a7%a3%e7%ad%94-2)
    - [別のコード](#%e5%88%a5%e3%81%ae%e3%82%b3%e3%83%bc%e3%83%89)
- [感想](#%e6%84%9f%e6%83%b3)

<!-- /TOC -->

<a id="markdown-a-prime-subtraction" name="a-prime-subtraction"></a>
## A. Prime Subtraction

[問題URL](https://codeforces.com/contest/1238/problem/A)

<a id="markdown-問題" name="問題"></a>
### 問題

2つの整数 `x, y` が与えられる。 `x > y` であることが保証されている。

好きな素数 `p` を選んで、その素数を何回でも `x` から引くことが出来る。

そのようにして、 `x` を `y` と等しくなるように出来るか答えよ。

`t` 個の独立したテストケースに対して答えよ。

制約: `1 <= t <= 1000, 1 <= y < x <= 10^18`

<a id="markdown-解答" name="解答"></a>
### 解答

`x` から適当な回数素数 `p` を引いて `y` にする、という部分をそのまま数式にすると、

`x - n*p = y <=> p = (x-y)/n`

`x-y` を適当な `x-y` の約数（1でもよい）で割った商を何かしらの素数にできるか？と考える。

`x-y` を素因数分解したときを考えると、適当な素数が残るような約数を選択できることがわかるので、 `x-y` が2以上であればOK。
1のときは、そのような `n = 1` とするしかないため、適当な素数が選べない。

```go
var t int

func main() {
	t = ReadInt()

	for i := 0; i < t; i++ {
		x, y := ReadInt64_2()

		if x-y >= 2 {
			fmt.Println("YES")
		} else {
			fmt.Println("NO")
		}
	}
}
```

<a id="markdown-b-kill-em-all" name="b-kill-em-all"></a>
## B. Kill 'Em All

[問題URL](https://codeforces.com/contest/1238/problem/B)

<a id="markdown-問題-1" name="問題-1"></a>
### 問題

※とても問題が長いので、適宜意訳。

Ivanはとあるゲームの最終ステージに苦労しており、全てのモンスターを倒すために手助けを必要としている。

ステージはとても長い廊下（無限に伸びる数直線でモデル化できる）からなっている。
廊下は `x = 0` で2つの部分に分けられる。

右側は、 `n` 体のモンスターが存在し、位置は座標 `X[i]` で表される。

左側は、罠で埋め尽くされており、モンスターが負の座標に位置までやってきた途端、罠によってモンスターは死ぬ。

Ivanの武器はフェニックスロッドによる爆破であり、選択した爆破位置 `c` によって、モンスターたちは以下のような反応をする。
モンスターの座標を `y` とする。

- `c = y` ならば、モンスターは爆殺される。
- `y < c` ならば、モンスターは左に `r` 押し出される（モンスターの位置は `y - r` となる）。
- `y > c` ならば、モンスターは右に `r` 押し出される（モンスターの位置は `y + r` となる）。

Ivanは、できるだけ少ない爆破回数でモンスターを全滅させたい。

`q` 個の各クエリについて、最小の必要爆破回数を答えよ。

制約:

- `1 <= q <= 10^5`
- `1 <= n, r <= 10^5`
- `1 <= X[i] <= 10^5`
- クエリに渡って `n` の合計は `10^5` を超えない。

<a id="markdown-解答-1" name="解答-1"></a>
### 解答

できる限り `X[i]` の大きいモンスターから爆殺していく貪欲法で良い。
これは以下の理由から正しいと言える。

> まず、モンスターを直接攻撃しない、という戦略は損しかしない。
> 問題の設定上、モンスターを爆風で右に吹き飛ばすのは無意味であり、
> モンスターを直接攻撃しないのであれば、無限遠の正の座標を爆破して、すべてのモンスターを左に寄せるほうがマシである。
>
> また、そのようにするならば、一番右に存在するモンスターを直接狙う方が明らかに得である。

実装は、爆破回数を覚えておくことで、都度チェックしているモンスターの現在位置が計算できるので、
一度罠にかかったらbreakすればよい（自分の解答では横着をしていてbreakしていない）。

```go
var q int

func main() {
	q = ReadInt()

	for i := 0; i < q; i++ {
		n, r := ReadInt2()
		X := ReadIntSlice(n)
		memo := make(map[int]int)
		for _, x := range X {
			memo[x] = 1
		}
		XX := []int{}
		for k := range memo {
			XX = append(XX, k)
		}

		sort.Sort(sort.IntSlice(XX))
		nn := len(XX)
		fmt.Println(XX)

		// m は中央を意味する何らかの値
		isOK := func(m int) bool {
			// 後ろのモンスターから爆殺
			cnt := 0
			for j := nn - 1; j >= 0; j-- {
				// j番目に殺すモンスターの座標
				xx := XX[j] - cnt*r

				if xx > 0 {
					// 爆殺する
					cnt++
				}
			}

			if cnt <= m {
				return true
			}
			return false
		}

		ng, ok := 0, len(X)
		for int(math.Abs(float64(ok-ng))) > 1 {
			mid := (ok + ng) / 2
			if isOK(mid) {
				ok = mid
			} else {
				ng = mid
			}
		}
		fmt.Println(ok)
	}
}
```

実際のところ、コンテスト中は貪欲法の正しさがあまりはっきりと認識できなかったため、二分探索のコードを書いて爆破回数の境界値を探ってしまいました
（ほとんど書き終わってから結局意味がないことに気づきました）。
とはいえ、計算量的には間に合うだろうと思って、書き直してバグを生むことのほうが懸念されたので、このまま提出しました（system test終了後、460msecとなっていました）。

問題文が長くて読むのが大変、かつコンテスト中は致命的な部分（爆風による吹き飛び方の部分）にタイポがあったため、かなりストレスでした。

<a id="markdown-c-standard-free2play" name="c-standard-free2play"></a>
## C. Standard Free2play

[問題URL](https://codeforces.com/contest/1238/problem/C)

<a id="markdown-問題-2" name="問題-2"></a>
### 問題

※適宜意訳

高さ `h` の崖を下るゲームがある。
`1 ~ h` の各整数位置 `x` に動く足場が存在する。

足場は、崖の中に隠れているか、崖から露出して飛び出しているかの2つの状態がある。
初期状態では `n` 個の位置 `P[1], ..., P[n]` の足場が露出して飛び出している状態である。
キャラクターの初期位置は `h` であるため、 `h` の足場は初期状態で飛び出ている。

キャラクターは、 `x` の足場に居るときにレバーを引くことができ、レバーを引くと `x, x-1` の2つの足場の状態が変化する。
キャラクターが立っている `x` の足場は崖に引っ込むため、キャラクターは落下することになる。

キャラクターはとても華奢であるため、安全に着地できるのは段差2以下の落下までである。
それ以上の落差で落下すると死亡してしまう。

状況によっては、安全に下に降りることができなくなってしまうが、いつでも購入可能な魔法のクリスタルを購入することで、
好きな足場1つの状態を変化させることができる。
クリスタルは使うと消滅する。

安全に地面 `0` に着地するために、必要なクリスタルの最小個数はいくつか答えよ。

制約:

- `1 <= q <= 100`
- `1 <= h <= 10^9, 1 <= n <= 2*10^5`
- `h = p[1] > p[2] > ... > p[n] >= 1`
- 各クエリに渡った `n` の合計は `2*10^5` を超えない。

<a id="markdown-解答-2" name="解答-2"></a>
### 解答

<!-- 基本的にはクリスタルを使わずに無事に下れるならば、レバーを引き続けて下降していけば良い。
一方で、クリスタルを使わないままレバーを都度引き続けるだけでは落下死してしまうという状況が存在する。
そういった場合は少なくとも一回はクリスタルを使う必要があり、また、一回のみの使用でレバーを引き続ければ下降できるようなフェーズが訪れる。 -->

今現在キャラクターが存在する足場は露出しており、その1つ下の足場が露出しているか、隠れているかの2つの場合がある。

1. 1つ下が露出している場合、キャラクターは落差2以上落下する
2. 1つ下が隠れている場合、キャラクターは落差1落下する（現在の足場が隠れると同時に、1つ下の足場が露出するため、1つ下に落下・着地する）

1のケースにあたった場合、2つ下の足場が露出していれば、無事に着地できるが、そうでない場合は3以上の落差で落下し死亡してしまう。
よってこれを回避するためにクリスタルを使う必要があるが、例えば、2つ下の足場をクリスタルによって露出させることで、落下死を防げる。

これを、足場を配列に見立てて素直にシミュレーションすることを考えたが、 `h` の範囲が大きいのと、
工夫をしたとしてもとても複雑でバグりやすいコードになりそうだったため、これは避けた。

結局の所、露出している足場が連続している部分に注目すればよいとわかる。

図のように、露出した足場の連続する部分の個数が、キャラクターが現在立っている足場を含めて奇数個ならば無事に降りれる。
そうでなければ、クリスタルで連続部の1つ下を、クリスタルで露出させる必要がある。



よって、例えばサンプルの3番目のクエリだと、以下の図のように、2箇所クリスタルで露出させる必要がある。



以上から、与えられた足場の列の連続部分に着目すれば、シミュレーションを簡略化でき、答えが求められる。
実装に際しては、いくつか注意すべき点がある。

- 最初の列だけは若干足場の数のカウントに注意する必要がある（立っている足場が途中経過によらずに `h` で確定しているため）
- 最後の列だけは、連続部が偶数個であっても、最後尾が1の場合はクリスタルは不要（キャラクタは2から0へ飛び降りることになるため）

```go
var q int

func main() {
	q = ReadInt()

	for i := 0; i < q; i++ {
		_, n := ReadInt2()
		P := ReadIntSlice(n)

		ans := 0
		num := 1 // 現在位置を1つとしてカウント
		j := 0
		for j < n-1 {
			if P[j]-P[j+1] == 1 {
				// 差が1なら、列の長さをインクリメント、jは1つ先へ
				num++
				j++
			} else {
				// 差が2以上なら、列の長さは打ち止め、かつそれまでの列の長さが偶数なら購入する
				if num%2 == 0 {
					ans++
				}
				// 列の最初をP[j+1]+1とする
				num = 2
				j++
			}
		}
		if num%2 == 0 {
			if P[n-1] >= 2 {
				ans++
			}
		}

		fmt.Println(ans)
	}
}
```

> キャラクタは2から0へ飛び降りることになるため

。。コンテスト中は、この部分に気づいていたにもかかわらず、なぜか `P[n-1] >= 2` の部分を `P[n-1] >= 3` と書いてしまい
pretestすら通すことができませんでした。

<a id="markdown-別のコード" name="別のコード"></a>
#### 別のコード

自分の頭のメモリ不足と言われたらどうしようもないですが、このようなシミュレーションのように、
「連続部の長さを数えながら、見ているセグメントの位置によっては微妙に処理内容を変える」というのは、結構脳に負担がかかります。
実際、コンテスト中も他の部分がバグっているのかと思い、初歩的な部分を見落としてしまいました。

リーダブルコードの149ページにも「一度に一つのタスクを適用する」というのがあるので、
それに倣って、

- 連続部の計算を別に事前に行っておく。
- 使用するクリスタルのカウントは別で集中して行う。

という方針でも書いてみました。

```go
var q int

func main() {
	q = ReadInt()

	for i := 0; i < q; i++ {
		_, n := ReadInt2()
		P := ReadIntSlice(n)

		ans := 0
		tmp := []int{0}
		for j := 0; j < n-1; j++ {
			if P[j]-P[j+1] >= 2 {
				tmp = append(tmp, j+1)
			}
		}
		tmp = append(tmp, n)
		rows := [][]int{}
		for j := 0; j < len(tmp)-1; j++ {
			idx1, idx2 := tmp[j], tmp[j+1]
			rows = append(rows, P[idx1:idx2])
		}

		if len(rows) == 1 {
			R := rows[0]
			if len(R)%2 == 0 && R[len(R)-1] >= 2 {
				fmt.Println(1)
			} else {
				fmt.Println(0)
			}
			continue
		}
		for k, R := range rows {
			if k == 0 {
				if len(R)%2 == 0 {
					ans++
				}
			} else if k == len(rows)-1 {
				l := len(R) + 1
				if l%2 == 0 && R[len(R)-1] >= 2 {
					ans++
				}
			} else {
				l := len(R) + 1
				if l%2 == 0 {
					ans++
				}
			}
		}

		fmt.Println(ans)
	}
}
```

。。今度は連続部が1つのみの場合について例外的に扱う必要が出てきてしまいました。

このあたりの強い人達がやっているベストプラクティスが知りたいところです。

---

<a id="markdown-感想" name="感想"></a>
## 感想

Cなんかは特別なアルゴリズムを使っているわけではないので、純粋な実装力不足が目立つあたり落ち込みますね。。

C++の優れたコードをちゃんと読んで自分のコードにも適用したいので、C++もちょこちょこ勉強してスムーズに読めるぐらいはしておいたほうが良さそうです。
