# EDPC過去問感想

正月は他にやりたい勉強があったので、本コンテストはオフラインで1問1問ゆっくり身長に取り組んだ。

非常に参考になる方々の解説↓。

[けんちょんさんA〜E問題](https://qiita.com/drken/items/dc53c683d6de8aeacf5a)
[はまやんはまやんさん](https://www.hamayanhamayan.com/entry/2019/01/12/163853)

[けんちょんさんF〜J問題](https://qiita.com/drken/items/03c7db44ccd27820ea0d)

---

## A問題

- 1次元のメモ配列で解けるタイプ。
- 遷移も状態もシンプルなのでDPの学習し始めに良いと思った。
  - ナップサックDPよりも考えやすい気がする。
- いわゆる（？）「貰うDP」の形でコードを書いた。
  - `i==2` の場合を初期化に含めてしまえば、ループがシンプルになってバグりにくいと思ったので。

---

## B問題

- （個人的には）A問題は「貰うDP」が書きやすかったので、今度は「配るDP」をやってみてください、と言われた感じだった。

---

## C問題

- 「貰うDP」の形式で書いたが、あまり気にすることではなさそう。

---

## D問題

- 典型的なナップサックDP。
  - 何回かすでに解いてしまったため、ほぼ解法を暗記してしまっている。。

---

## E問題

- ナップサック問題のよくある変形（らしい）。
- はまやんはまやんさんの解説を見た感じ、自分の解法で問題なさそう。
  - 自分はなんとなく「貰うDP」のほうが確信を漸化式を立てやすい気がする。
    - とはいえ、ナップサックのようなDPで貰う形式で書く場合、条件分岐のコードが若干冗長になる。

---

## F問題

- LCSはLongest Common Stringの略？
- 今の所一番むずかしい、遷移があまり脳になじまない感じ。。

---

## G問題

- DAG上のLongest Pathの長さを調べる問題、自力で解けたのは嬉しい。
- けんちょんさんの解説記事の以下の文がとても納得できた。

> 問題Aでは「for文を回すDP」と「メモ化再帰」とで大きな違いはないと書きました。
> しかし、メモ化再帰が大きなメリットを生む状況があります。
> それは **DPの更新順序が非自明** という場合です。

- for文を回すタイプのDPでこの問題を解くためには、以下の手順が必要らしい。。
  - まずトポロジカルソートする
  - それによってDPを回していくべきノード順が決まるので、DPする
- 日経のD問題もこれに近いような問題だった気がするので、相互参照する形で学習に利用したい。
- 今日は仕事でつかれたのでここまで。。

---

## H問題

- グリッド上の目的地への経路の数の数え上げ問題
- 割と易しめ
- けんちょんさんの解説では `(0, 0)` から遷移していたが、自分は当初メモ化再帰で考えようとしていたため、結果的に逆からのdpテーブル埋めをしていた
  - 本質的には同じことをしているはず

---

## I問題

- 20190606に再開。
- 以前はわからなかったのでここでストップしていたが、なぜわからなかったのかがわからないくらい普通に解けた。
- 確率DPとか言う名前があるかはわからないが、こういった初期値の設定や遷移はかなり初歩的と思われるので、似たような問題が出たらしっかり仕留めたい。
- 制約に目をつけたらもっと早く解けたのかも？
- 今回は配るDPのほうが余計な場合分けが不要で簡潔だと思う。

---

## J問題

- はじめての（？）期待値DP
- 期待値漸化式をそれなりにしっかり理解しないと挑めない。
  - 難関大学の入試勉強をしてると触れているらしい（自分は触れていなかった）
- 高校数学の物語で「期待値漸化式」を検索すると、コンプガチャの記事があり、こちらは幾分問題設定がシンプルであるため、はじめにこちらから勉強するとスムーズに理解できると思う。
- 肝心のDP部分については、遷移式が複雑なので、メモ化再帰で書くのがきれい。

---

## K問題

- ゲーム系の基本問題。ひょっとしたらDPじゃなくても解けるのかも？
- **石の残り数のみで状態と見立てて、その状態で手番が回ってきたときに勝てるかどうか？を小さい数から記憶していく。**
  - CADDiコンテストのゲームを思い出す形。
  - 小さい数からイメージするのは大事。
- 遷移は、選択肢として与えられる最大100個の数について、**それらからいずれかを選んだときに、相手を負け状態に追い詰められるかどうか？** で考えることができる。

---

## L問題

- 最大3000個程度の要素を含むキューから、一番前と一番うしろからのみ要素の取得が許されるゲーム。
  - 先手はできるだけ取り出した合計値を大きくしたい、後手は小さくしたい。
  - つまりは、先手・後手とも、自分のとった数値の合計が大きくなるようにしたい。
- 一見、与えられた2択のうち、大きい方を取るのが良さそうにも見えるが、そうしたあとにもっと良い数値が露出してしまうと、相手にそれを取られて結果的に不利になるケースが有る。
  - よって、なんとかして全探索を考えたい。
- この問題も、サイズが小さい部分問題の答えがわかっていれば、「前をとったときの残りの部分問題」「後ろをとったときの残りの部分問題」を考えて、最大・最小をとるでいけそう。
- `dp[i][j]: i<=x<=j の区間で手番が回ってきたときの X-Y の値` として解いた。
  - 遷移をforループで書ききるのは大変そうだったため、メモ化再帰で考えた。
    - 与えられた区間は、先手・後手で戦略が変わるので、取り出した数値をプラスしたりマイナスしたりは、再帰関数の引数にフラグを渡すことで行った。
- [競プロフレンズさんの解説](https://kyopro-friends.hatenablog.com/entry/2019/01/12/231000)だと、コードはもっとシンプルになる。
  - `dp[i][j]: i<=x<=j の区間で「次の手番の人のスコア - そうじゃない方の人のスコア」` として解いている。
    - 手番の意味の取り込み方はK問題っぽい。

---

## M問題

- やたらと時間がかかったがなんとか自力でできた。
- **典型: DPテーブルの遷移（更新）に、すでに求まったテーブルの累積和を用いる。**
  - ちょっと応用が効いたDP問題では本当に典型なのだろうと思う。
  - ABC130のE問題などは、解法によってはそれまでのDPテーブルの2次元累積和が必要になったりしていた。
- 2次元程度ならば遷移表を追うことはなんとかできる可能性があるので、諦めずに愚直に遷移表を描いてみることもコンテスト中はやっていきたい。

---

## N問題

- なんかそれっぽいメモ化再帰の関数は簡単にかけたが、問題の分析が甘く、遷移が間違っていて自力で解けなかった。
- 逆向きに考える発想は良かったが、コスト計算が間違っていた。
  - 大きいスライムを2分割する、そのとき分割前のスライムの大きさがコストとしてかかる、という見方が必要だった。
- **典型: 与えられた配列の累積和を使ったDPテーブルの遷移。**
  - こういった累積和の使い方もDPでは頻出っぽい。
- 制約は最大400なのでいろいろ考えてしまいそうだが、「状態数が `O(N^2)` 、遷移が `O(N)` だから計算量は `O(N^3)` 」という冷静な分析はできるようになりたい。

---

## O問題

- bitDP！はなから勉強のために答えを見た。答えを読んでも全くわからなかった。

---

---

## S問題

- オーソドックスな10進数記法の桁DP。
- 個人的には桁DPは **「上の桁から確定させつつ `1->1, 0->1, 0->0` の遷移を気をつける」** でなんとかなるような気がしている。
  - 解いたバリエーションが足りないので余り自信はないが、当分はこの方針でやってみたい。

