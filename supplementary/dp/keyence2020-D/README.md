# 解法

整理するまでが大変だが、整理すると素直なbitDPを書けば良くなる。

並び替えのカードの挙動が非常に目まぐるしく見えるが、実際には位置によって表か裏かは確定する（パリティに注目）。

よって、並び替え方を全探索して、それぞれのパターンを作るのに必要なスワップ回数を調べれば良い。
その中で最小値を取るものが答え。最小値が初期値以上だったら不可能と判定できる。

では、そのパターンを作るのに必要なスワップ回数とはなにか？
これは転倒数そのものとなる。

**よってバブルソートおよび転倒数の理解が曖昧だと絶対に解けない。**

**典型: 隣接要素のスワップ回数といえば転倒数！**

## バブルソートと転倒数

アルゴリズムを書いてみる。

螺旋本およびWikipediaより。

```go
// AOJ
func bubbleSortAOJ(A []int, n int) int {
	flag := true
	res := 0
	for flag {
		flag = false
		for j := n - 1; j >= 1; j-- {
			if A[j-1] > A[j] {
				A[j-1], A[j] = A[j], A[j-1]
				res++
				flag = true
			}
		}
	}

	return res
}

// wikipedia
func bubbleSortWikipedia(A []int, n int) int {
	res := 0
	for i := 0; i < n-1; i++ {
		for j := 1; j < n-i; j++ {
			if A[j-1] > A[j] {
				A[j-1], A[j] = A[j], A[j-1]
				res++
			}
		}
	}

	return res
}
```

Wikipediaの説明を見ると、以下のようになっている。

> すべての要素に関して、隣接する要素と比較し順序が逆であれば入れ替える。
> これを `n-1` 回繰り返すことでソートを行う。
> なおこの繰り返しは、入れ替えが起こらなくなった時点で（それ以降は何度繰り返しても変化が起こらなくなるので）
> 中断することができる。

これがバブルソートの定義だとすると、定数倍の部分次第でいろいろなバリエーションがあると言えそう。

とりあえずはWikipediaのアルゴリズムを頭に染み込ませたい。

