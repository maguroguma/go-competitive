# Educational Codeforces Round 101 感想

Cがあまり見たことない感じで難しかった。

## A問題

いきなりかなり考えてしまった。  
まずは長さが奇数のときはノーチャンスなのは明らか。  
そしてよくよく考えると、「初期状態で閉じカッコと開きカッコは1つずつ必ず存在する」
という条件から、最初が閉じカッコ、あるいは最後が開きカッコ、という明らかな詰み状態でなければ、必ず正しいカッコ列は作ることができる。

## B問題

こちらのほうが簡単だった。  
それぞれの数列の累積和を計算して、それぞれをどこまで取るか、というのを全探索すれば良い。

自分のこの方法だと計算量は `O(n * m)` だが、よく考えたらそれぞれの累積和では最大を取るべきなので、
`O(n+m)` の全探索で十分であった。

## C問題

自分は変な解き方をしてしまった。  
というかちゃんと正しいのかも証明できていない。

方針としては、両端を除いたセグメントについて、高さが高いところから処理する、ということを行った。  
具体的には、両隣が自分より低ければ何もせず、高いのであれば、最低限高いところまで持っていかなければならないので、
それはできるだけ小さい値を貪欲に選択する。  
最後に両端についても忘れずに条件をチェックしてやる。  
両端の条件チェックを間違えてしまい、1WAしてしまった。

自分の方法はpriority queueを使うため、計算量は `O(nlogn)` となってしまう。

editorialの想定解法は、左から有効範囲を決めておき、違反がないかを調べていくというものだった。

## D問題

そんなに難しくはなさそうな構築だったが、時間がないと無理程度には難しかった。  
時間がない状態では2ベキを巧く残してやる方法などしか浮かばず、これでは回数が足りなかった。

