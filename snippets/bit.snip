snippet     binaryIndexedTree
abbr        type BinaryIndexedTree struct
options     head
  // Public methods
  // bit := NewBIT(200000 + 5)
  // s := bit.Sum(i) 						// Sum of [1, i] (1-based)
  // bit.Add(i, x) 							// Add x to i (1-based)
  // idx := bit.LowerBound(w) 	// minimum idx such that bit.Sum(idx) >= w

  type BinaryIndexedTree struct {
    bit     []int
    n       int
    minPow2 int
  }

  // n(>=1) is number of elements of original data
  func NewBIT(n int) *BinaryIndexedTree {
    newBit := new(BinaryIndexedTree)

    newBit.bit = make([]int, n+1)
    newBit.n = n

    newBit.minPow2 = 1
    for {
      if (newBit.minPow2 << 1) > n {
        break
      }
      newBit.minPow2 <<= 1
    }

    return newBit
  }

  // Sum of [1, i](1-based)
  func (b *BinaryIndexedTree) Sum(i int) int {
    s := 0

    for i > 0 {
      s += b.bit[i]
      i -= i & (-i)
    }

    return s
  }

  // Add x to i(1-based)
  func (b *BinaryIndexedTree) Add(i, x int) {
    for i <= b.n {
      b.bit[i] += x
      i += i & (-i)
    }
  }

  // LowerBound returns minimum i such that bit.Sum(i) >= w.
  func (b *BinaryIndexedTree) LowerBound(w int) int {
    if w <= 0 {
      return 0
    }

    x := 0
    for k := b.minPow2; k > 0; k /= 2 {
      if x+k <= b.n && b.bit[x+k] < w {
        w -= b.bit[x+k]
        x += k
      }
    }

    return x + 1
  }

snippet     binaryIndexedTreeSetVer
abbr        type BITSet struct
options     head
  // Public methods
  // bit := NewBITSet(200000 + 5)
  // c := bit.Count(b.n)
  // bit.Insert(val, 1)
  // bit.Delete(val, 1)
  // ans := bit.Kth(k)

  type BITSet struct {
    bit     []int
    n       int
    minPow2 int
  }

  // n(>=1) is maximum integer for the set.
  func NewBITSet(n int) *BITSet {
    newBit := new(BITSet)

    newBit.bit = make([]int, n+1)
    newBit.n = n

    newBit.minPow2 = 1
    for {
      if (newBit.minPow2 << 1) > n {
        break
      }
      newBit.minPow2 <<= 1
    }

    return newBit
  }

  // Count returns number of elements less or equal than e in the set.
  // b.Count(b.n) returns total number of elements in the set.
  // O(logN)
  func (b *BITSet) Count(e int) int {
    s := 0

    for e > 0 {
      s += b.bit[e]
      e -= e & (-e)
    }

    return s
  }

  // Insert e(1<=e<=n) for num(>= 1) times.
  func (b *BITSet) Insert(e, num int) {
    for e <= b.n {
      b.bit[e] += num
      e += e & (-e)
    }
  }

  // Delete e(1<=e<=n) for num(>= 1) times.
  func (b *BITSet) Delete(e, num int) {
    num *= -1
    for e <= b.n {
      b.bit[e] += num
      e += e & (-e)
    }
  }

  // Kth returns kth element in the set
  func (b *BITSet) Kth(kth int) int {
    if kth <= 0 {
      return 0
    }

    x := 0
    for k := b.minPow2; k > 0; k /= 2 {
      if x+k <= b.n && b.bit[x+k] < kth {
        kth -= b.bit[x+k]
        x += k
      }
    }

    return x + 1
  }

snippet     binaryIndexedTreeSimpleVersion
abbr        var bit [1000000 + 1]int
options     head
  // [1, n]
  var bit [1000000 + 1]int
  var n int
  var A []int

  func sum(i int) int {
    s := 0

    for i > 0 {
      s += bit[i]
      i -= i & (-i)
    }

    return s
  }

  func add(i, x int) {
    for i <= n {
      bit[i] += x
      i += i & (-i)
    }
  }

