# difficulty順に埋める

Last Change: 2020-07-16 00:14:02.

@2020-06-29より、埋めていないところから順に埋めていく。
おそらくは復習が必要な問題が並ぶはずなので、最初から集めておく。

## [ABC161-F ★](https://atcoder.jp/contests/abc161/tasks/abc161_f) @2020-06-29

こどふぉならmath, number theoryタグがついてdiff 1600ぐらいになりそうな問題。
でもわからずに解説AC。

剰余の推移に目をつけたのは良かったが、逆から考えようとした時点で間違いだった。

ていうか誤読してた、死にたい。

## [ABC030-D](https://atcoder.jp/contests/abc030/tasks/abc030_d) @2020-06-30

[ABC167-D](https://atcoder.jp/contests/abc167/tasks/abc167_d)とほぼ同じな気がする。

バカでかい `k` の対処は桁DPなどでよくある剰余の扱いをすればよいが、違いはそこだけだと思う。

これもダブリングをするとライブラリ貼るだけとかにできるのかもしれないが、
ライブラリチェックはよりシンプルな問題の方だけで試せば良い気がする。

## [AGC044-A ★](https://atcoder.jp/contests/agc044/tasks/agc044_a) @2020-06-30

難しい。答えを効いても計算量見積もりが非常に難しい。
すぬけさんの解説放送でのざっくりとした見積もりが一番わかり易い気がする。

とりあえずは「ハッシュマップを使ったメモ化再帰」というのがこの問題で一番手にしておきたい経験値だと思う。

## [ABC025-C ★★](https://atcoder.jp/contests/abc025/tasks/abc025_c) @2020-07-01

答えを見たが面白かった。ゲーム木の基本問題として覚えておきたい。

ゲーム木の考え方（再帰部分）もそうだが、
「ゲームにおいて最大化と最小化を考える2プレイヤーがいるとき、総和が一定であることに注目すると見通しが良くなる」
という部分は応用の幅が広そうであるため、ぜひ覚えておきたい。

## [ABC013-D](https://atcoder.jp/contests/abc013/tasks/abc013_4) @2020-07-01

自力。ダブリングの練習ができた。

ダブリングのコードは[けんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2020/06/20/190700)
がわかりやすかったので、変数名なども含めて写経した感じになった。

## [ARC023-C](https://atcoder.jp/contests/arc023/tasks/arc023_3) @2020-07-02

自力。

逆元が一般的でなかった時代の過去のもの。
注意点としては、制約が最近では見ない感じで、もろもろを前計算する自前の組み合わせライブラリではうまく行かず、
コンビネーションを愚直に計算しないと駄目なタイプだった。

## [ABC011-D ★](https://atcoder.jp/contests/abc011/tasks/abc011_4) @2020-07-02

解説AC。

場合の数なら簡単だが、確率を求めろとなると場合の数を考えると失敗してしまう。

パスカルの三角形を応用すると、 `C(n, r), r = 0, 1, .., n` までのすべての組み合わせの確率が直接求まる。
この事実をうまく利用すると、所望の確率が計算できる。

ポイントは、一度場合の数の考え方をリセットして忘れて、 `C(n, r)` に閉じた積事象の確率で考えること。

`O(N^2)` で任意の確率が求まる可能性があることについては覚えておきたい（これから出題される可能性は低そうだが）。

## [ABC023-D](https://atcoder.jp/contests/abc023/tasks/abc023_d) @2020-07-03

自力。

最大値の最小化といえば二分探索がまっさきに思いつくので、そこを狙って考えれば簡単だと思う。

判定関数の中でソート処理が含まれるので計算量にはlogが2つつくことになるが、
制限時間が5秒なので大抵の言語で余裕だと思う。
Goだと1100msecぐらいだった。

## [ABC014-D](https://atcoder.jp/contests/abc014/tasks/abc014_4) @2020-07-04

自力。

木のLCAを求めて、与えられたノード2つの根からの深さとLCAの根からの深さを用いて計算してやる。
LCAの利用問題としては最易の部類だと思う（ので、verify用問題として良さそう）。

※LCAはフルスクラッチで書ける必要はないが、アルゴリズムの動作原理や内部で保持しているデータ構造（ `depth` ）については理解しておくべきだと思う。

## [ABC162-F ★★](https://atcoder.jp/contests/abc162/tasks/abc162_f) @2020-07-04

解説放送AC。

解説PDFだけだと理解がきつい。
解説放送ではDPの組み方まで教えてくれたのでわかりやすかった。

制約が厳しいことから状況を整理して、最終的にやるべきDPを見出したい。

## [ABC171-F ★★](https://atcoder.jp/contests/abc171/tasks/abc171_f) @2020-07-05

解説放送AC。

これもPDFだけだと理解がきつい。

独立？な数え上げをうまくやる方法として「最終的なものが部分列として含まなければ行けない」という点から出発している（多分）。
発想がとても賢い。。

最終的には、組み合わせライブラリを用いるシンプルな数え上げになる。

- 操作手順を考えると重複が出てきてわけがわからない。
- **挿入後に出来上がる文字列が「どういう性質を持つか？」から考える。**
- ある文字列が部分列を含むか？の判定はシンプルに前からみる貪欲法で良い。

## [ABC154-F ★★](https://atcoder.jp/contests/abc154/tasks/abc154_f) @2020-07-05

解説（放送）AC。

まず、2次元累積和的な発想が求められる。
これにより、原点中心の「量」が高速に求められればOKというシンプルな問題になる。

※実際に小さい範囲でマス目を書いて、通り数を埋める実験をやるべき！

※すぬけさんの解説放送の方法はパスカルの三角形の理解が深まるので、これはこれで面白い。
（というより「組み合わせ」という量の性質が色々見つかって面白い。）

**※今までパスカルの三角形は「貰うDP」っぽく考えていたが、すぬけさんの解説のように「配るDP」の視点も持てると、色々と応用幅が出そうな気がした。**

## [ABC165-F](https://atcoder.jp/contests/abc165/tasks/abc165_f) @2020-07-05

久しぶりに自力で解けるABC-Fが出てきた。

「DPの巻き戻し」と呼ばれるテクニックを使うらしい（復元とは全くの別物っぽい？）。

何やらstackを使うと良いらしいとあるが、自分はLISのデータ構造をスライスのスライスとして持って、
最後尾の該当するものを都度削除するという方法をとったらうまくいった。

※同じ値の要素が存在するLISは少し注意が必要！（1回WAしてしまったので）

## [ABC159-F ★★](https://atcoder.jp/contests/abc159/tasks/abc159_f) @2020-07-05

解説AC。

耳DPが難しい。。
絶対に復習が必要となる問題。

※解説放送を見ればわかるが、部分和問題の数え上げ問題は、多項式の係数と深い関わりがある。
割り算だったり順序を入れ替えたり、とかの正当性がすっきりわかるので、数え上げ手段としては強力（っぽい）。
実装も多項式バージョンを紹介しているっぽいので、気になったときにチェックして写経してみるといいかもしれない。

※いつも頼りになる[けんちょんさんの解説ブログ](https://drken1215.hatenablog.com/entry/2020/03/22/224200)

## [ABC173-E ★](https://atcoder.jp/contests/abc173/tasks/abc173_e) @2020-07-06

コンテスト中に解けなかった問題。注意力要素も強めな気がする。

解説放送で勉強する。

- 適当にやると場合分けがやばいので、丁寧にやりましょう。
- 0は一旦無視する。
- 「積を正にできるか⇔負を偶数個選べるか」←これが結構難しい。
  - 「正が1つでもあるかどうか」という視点は重要（最後の1つで帳尻合わせできる）
    - 実際、「負の数をk個選んだらどうなるか」を考えると、帳尻合わせが簡単に出来る（正は1つかならず残るので）。

## [ABC173-F ★★](https://atcoder.jp/contests/abc173/tasks/abc173_f) @2020-07-06

解説放送AC。簡単とか言われてたが、PDFを読んだ感じ初めて出会う考察だったように見える。

- 連結成分数を言い換える
  - `頂点数 - 辺数`
    - **これは「木の頂点数と辺数の関係を森の各木に対して適用してやる」ことで知らなくても発想できる！**
  - サイクルが起き得ない木グラフだからこそできる言い換え
- 辺数を数えるときは「横から見るものを縦から見る」やつで数える
  - 「主客転倒」とか「寄与ゲー」とかも言われるらしい（個人的に前者の言い回しが好き）

## [ARC014-D](https://atcoder.jp/contests/arc014/tasks/arc014_4) @2020-07-07

自力。易しめではあるものの、ノーミスで通せたのは嬉しい。

マージされる行間に注目すると良い。
マージされるものが増えていくと、その分 `x+y+1` を考えるべき個数が減っていく
（ちょうど↑の問題で、森に閉路とならないように辺を足すと連結成分が1つずつ減っていくように）。
その代わりにマージされた間の長さを加算すれば良いことになる。

これらの計算は行間のdiffを集めた配列を照準ソートして、
二分探索によってマージする個数が、prefix sumによって加算すべき値（寄与させる値）がわかる。

端っこの処理に注意。

## [ABC131-F ★★](https://atcoder.jp/contests/abc131/tasks/abc131_f) @2020-07-07

解説放送AC。PDFだけでは考察の流れ（気持ち）がわからなかった。

- 2次元の点を軸に射影するのは典型？[多分そう。](https://drken1215.hatenablog.com/entry/2019/06/23/004700)
  - 点を辺だと考える。2部グラフ上の点。
  - **完全二部グラフになるまで辺を追加する。**

**典型: 格子点を二部グラフとして考える。**

「二部グラフの奇数長のパス」というのも既視感があるので、発想の種として覚えておきたい。

実装は割と簡単かも（ちょっと考えたものが解説のすぬけさんのものとほぼ同等だったのは自分を誉めたい）。
連結成分でちょっと複雑なことをしたいときは、アドホックにDFSを書いたほうが融通がききそう。
（ABCの序盤ではunion findで雑にやるのも検討したい。）

## [ABC142-F ★★](https://atcoder.jp/contests/abc142/tasks/abc142_f)

解説放送AC。

なんとなくやりたいことはわかっても実装方法がよくわからない問題だった。
ので、最初から解説を参照した。

閉路ができたら必ずOKなものが存在する。
閉路があって条件を満たさない場合、その中に余計な辺があることになるが、
それを利用してより小さい閉路ができる。
よって、再帰的に調べていけば、いずれ条件を満たす閉路が見つかる。

↑多分、この考察が一番配点の大きい部分だと思う。
実装は割と適当でもいい、はずだがよくわからなかった。

また、言い換えるとBFSで最小（極小）サイズのサイクルを見つける、というのでよい。

BFS, DFS両方の実装をやってみたい。
が、BFSのほうが大分素直に見えるし、BFSにもっと慣れたいこともあるので、まずはここを強く覚えるのが良いかもしれない。

。。この問題などを見ると、ABC-Fは意外とシンプルに考えて良いものが多いのかもしれない。

**典型: BFS, DFSで有向グラフの閉路を取得する実装。**

※DFSの実装は[毎度おなじみのけんちょんさんのブログ](https://drken1215.hatenablog.com/entry/2019/09/29/012000)が大いに参考になりそう。

## [ARC031-C ★★](https://atcoder.jp/contests/arc031/tasks/arc031_3) @2020-07-10

解説AC。簡単だと思ったが、多分どこかに間違いがあり、サンプルを除いて全然テストをパスしていなかった。

転倒数っぽいからBITを使う発想はすぐに出てきたが、転倒数の発想のママでは解けなかった。
てっきり累積和的なものを使って、最大のものをどこに置くかを全探索するものだと思ったが。。

正解は、その時点で最も小さいものを左右の端どちらかに寄せる必要があるが、どちらでも問題ないので近い方に寄せる貪欲を繰り返す、というものだった。
「小さいものから処理していく」というのは典型発想だったので、これも考えたかった。

この手法は、BITを使うことによって実装できるが、BITの扱い自体もあまり慣れていないので、いい練習問題として覚えておきたい。

**典型: 小さいものから処理していく。**

※転倒数を考えて全探索する方法もあまり間違いっぽくはない気がするので、どこかで解き直してみても良いかもしれない。

## [ARC051-C ★](https://atcoder.jp/contests/arc051/tasks/arc051_c) @2020-07-10

解説AC。というか、公式PDFを読んでもよくわからなかったので、色々なブログ解説を読んだ。
が、それでも最初はよくわからなかった。

よーく考えたら簡単な話だった。

「最小値にAをかけたものが、直前の状態の最大値以上になったら、以降は周期性を伴って変化する」というのは簡単な話だった。
最初、なぜそうなるのか理解できなかったが、具体的に昇順に並べた数列に対して、例えば2でもかけたものを書いてみると良い。

`A[n] <= A[1]*2` となったら、当然次は `A[1]*2 <= A[2]*2` となる。
これが繰り返されるのだから、周期性に疑問を抱く必要はない。

よって、最大値を超えるまではシミュレーションして、それ以降は周期性を利用して、二分累乗法によって計算を進めれば良い。
最初のシミュレーションについて注意が必要そうに見えるかが、結果は `int64` に収まるのと、
最大値を超えるまでに必要な掛け算の数はせいぜい30回もあれば十分なのはすぐわかる。
よって、そんなに悩む必要はない。

## [CODE FESTIVAL 2014 予選A C ★★](https://atcoder.jp/contests/code-festival-2014-quala/tasks/code_festival_qualA_d) @2020-07-11

解説AC。実装でコーナーに気づけず、地獄を見た。

桁DP的な考え方で数を捉える必要がある。
すなわち、貪欲的に左の桁をあわせたいわけだが、どこかでずらさざるを得ない時が来る。
これ以降は、大きくしてしまったなら選べる選択肢の中で最小を目指し続けるし、
小さくなってしまったら選べる選択肢の中で最大を目指し続ける必要がある。

よって、元の数字を左からいくつコピーするか、次の桁はどの数字にするか（ずらすか）、以降の桁はどの数字を連続させるか、
を全探索すれば良い。

おそらく、leading zeroをちゃんと扱わないと最小値を見逃してしまうテストケースが2つ存在する（具体的にどのようなものかは調べていないが）。
[この方の記事](https://qiita.com/ophhdn/items/339133a31b9e33c8c264)で気づけた。
「なんで戦闘のものだけ除けば十分なのだろう？」と思ったが、2つ0が続くようなものは最適にはなりえないため（多分）。
。。一回整数に変換してからまたOK判定するほうが賢かったかもしれない。。

その他、計算量は大分余裕があるので、イミュータブルなコーディングを心がけるのも大事。

※bitDPと桁DPをあわせたようなDPでも解けるようなので、いつか練習してみても良いかもしれない。

## [Indeedなう予選A D ★★](https://atcoder.jp/contests/indeednow-quala/tasks/indeednow_2015_quala_4) @2020-07-11

解説AC。実装が大変だが面白かった。

半分全列挙の考え方。
すなわち、 `3^24` は探索できないけど、 `3^12` ならOKなことを利用する。

初期状態から12階層、ゴール状態から12階層探索する。
盤面をハッシュ化することでハッシュマップに載せられるため、初期状態あるいはゴール状態からその盤面に至る最短手数を求めておく。
最後に、初期状態から到達可能な盤面とゴール状態から到達可能な盤面で一致するものを調べ、
最短手数を更新していけば良い。

**複雑なものでも、一致判定ではハッシュ化、あるいはソートをすぐさま検討できるようにしたい。**

※DFSの場合は途中で更新が起きうる場合があることに注意！その意味ではBFSのほうが高速な気がする。

※Aスターアルゴリズムでも解けるっぽい。kenkooooさんがブログを上げていた。

## [ABC167-F ★](https://atcoder.jp/contests/abc167/tasks/abc167_f) @2020-07-11

解説（放送）AC。

貪欲を詰めていくのが難しいと思う。
とはいえ、特別なアルゴリズムは用いない。

すぬけさん曰く、「アドホックな問題」。

- **カッコ列は折れ線グラフで考えると良い。**
  - **正しいカッコ列であるための条件は「0で終わる、0未満にならない」となる。**
- 断片を2つの値で表す。
  - ここはいろいろな見方ができそう。
  - 最下点と最終的な増加量を調べる。
    - 一度下がって一度上がる、シンプルなV字のものに統一できる。
- 増加量の正負でわけると、理想的な高さまで上がり下がりする、という考え方のもとでは、並べ方をシンプルにできる。
  - 上がるときは、最下点が大きいものからつなげるのが良い。
    - くっつけやすいものからくっつけていることになるので、それが無理ならどうあがいても無理。
  - 下がるときは難しい。逆から考えると同じ話になっていることに着目しないといけない。

## [ABC152-F ★★★](https://atcoder.jp/contests/abc152/tasks/abc152_f) @2020-07-11

解説（放送）AC。これも包除原理だった。

余事象っぽく考えれば良いのでは？と思ったが、あまりにもシンプルに考えすぎた。

包除原理を真面目に計算するタイプの問題に初めて出会えたので良かった。
**包除原理は、余事象を考慮するときに一緒に考えておくと良さそう。**

- 包除原理は、一般的には2のべき乗の計算量になる。

※すぬけさんの放送でやっていた実装では、パスを求めるのにDFSを行って、
「ゴールを引数に入れてそこに到達したらそこから巻き戻してパスを逆順にスライスに突っ込む」
というのが賢かった（ゴールとは違う終点にたどり着いたら `false` を返すことで無視できる）。
パスのスライスは、グローバルにおいてDFSを大元で呼ぶ前に初期化すれば良い。
シグネチャは `func dfs(cid, gid, pid int) bool` という感じ。

※包除原理の辺の数を数えるところは一貫してビット演算に閉じると、ビットマスクのOR演算で収まったり、大分高速になりそう。

※LCAを使った「木上の累積和」というのは結局謎のままだった。

## [CODE FESTIVAL 2014 Easy D ★★](https://atcoder.jp/contests/code-festival-2014-morning-easy/tasks/code_festival_morning_easy_d) @2020-07-12

非公式の解説ブログを読んでAC。

貪欲の考え方は合っていたが、実装に嘘が含まれていた。

多分、priority queueをうまく使うしかない。

**典型: 貪欲法にはpriority queueが相性が良い。**

- [mayokoさんのブログ](http://mayokoex.hatenablog.com/entry/2015/10/08/210337)
- [kmjpさんのブログ](https://kmjp.hatenablog.jp/entry/2014/11/10/1030)

多分、どちらも同じことをやっていると思われるが、mayokoさんのブログのほうがわかりやすかった。

まず、「枕を小さい順に見るとき、その枕に適合する人の中で、最も右端が小さい人に割り当てるのが最適」といえる。
これは、残った以降の枕は今見ているものよりも高いので、より割り当てる人が多く存在させることができ有利だから、
というので直感的な証明になる（。。と思う）。

自分は最初、区間スケジューリングの要領でソート後は線形な探索をしてしまったが、
ここで捨てては行けないものを捨ててしまっていた。
すなわち、今見ている枕に適合しないものを捨ててしまって、後で再びみることがないようなコードになっていたが、
たとえば、 `(25, 41)` という人は `12` の枕には適合しないが、あとから来る `35` には適合する。
一方で、自分が書いた嘘コードでは、 `12` に適合しない時点で捨ててしまっている。

そこで、小さい順に枕を検査する部分は変えずに、「今見ている枕については左端の条件が全て満たされているような人集合」
を保存しながらすすめる方法を考える。

このためには、まず人スライスを左端で昇順ソートすれば良い。
一方、人を対象とするpriority queueを用意し、こちらは右端の小さいものが優先的に並ぶようにする。

アルゴリズムは、今観ている枕よりも左端が小さい人をすべてqueueに詰めていく。
詰めるフェーズが終わったら、queueから右端が小さいものを順に取り出し、
適合するものが見つかったら（それが最も選べる人集合の中で最適なので）それを選んで次の枕に進む。

## [ARC075-E](https://atcoder.jp/contests/arc075/tasks/arc075_c) @2020-07-12

自力、というかもはや超有名問題。

変数分離をすると、よくあるzero sum rangesのテクニックが使える数え上げ問題になる。

累積和を使ったりした後は、「すでに見たものの中で、現在注目している値以下のものの個数は？」というのを
都度数え上げる問題になる。
模範解答でもそうだったが（evimaさんいわく「最もかんたんと思われる手法」）、
座標圧縮してからBITによる各要素の個数管理を用いるものを利用して、実装した。

多分treapなどのordered setでもできると思うが、普段の使用頻度が小さいものを練習してみた。

## [ARC026-C](https://atcoder.jp/contests/arc026/tasks/arc026_3) @2020-07-12

自力。以前にも似たようなものを解いたことがあったためできた。とはいえ時間かかりすぎ。。

まずは、貪欲的な発想の元、左端の昇順ソートを行う（もれなく廊下を照らす必要があるため）。

`dp[i] := iまで照らされている場合の費用の最小値` とすれば、RMQのセグメントツリーと合わせて解ける。
更新は `dp[l] ~ dp[r-1]` までの最小値がわかれば、それプラス現在観ている蛍光灯のコストとの和をみて、
更新すべきかどうかの判断ができる。

## [ARC029-C](https://atcoder.jp/contests/arc029/tasks/arc029_3) @2020-07-14

自力。こどふぉでほぼ同じ問題を解いたことが合った。

交易所を作る、というのを架空の都市との間に同じコストでエッジを張る、という操作とみなすと、
エッジ数のオーダーが変わらない範囲でエッジ数が増えた上での、単なる最小全域木を求める問題になる。

## [ABC170-F ★★★★](https://atcoder.jp/contests/abc170/tasks/abc170_f) @2020-07-14

解説放送AC。

グラフ拡張＋順序が定義できる構造体をpriority queueに詰めるダイクストラで解ける（TLギリギリだったが）。

`dp[i][j][d] := (i, j) における方向 d を向いている時の状態` とし、状態を「水かき回数、残りの推進力」で表す。
すぬけさんの実装による `(i, j, d) => id` という変換やその逆操作を行う関数など、非常に勉強になった。

順序が定義できる構造体のダイクストラや、3次元の複雑なグリッドグラフの変換など、練習できる要素が多い。

## [ABC151-F ★](https://atcoder.jp/contests/abc151/tasks/abc151_f) @2020-07-14

最初から解説放送を観た。

最小包含円。

**「円は3つの点によって定まる（外接円）」**
他に点は乗っていることもあるが、気にしなくて良い。
また、2つの点が直径をなすときにも円は定まる。
これらの2つのパターンをすべて試す（すべての点が入っているかどうか判定する）。

真面目にやると計算量が大変（らしい）。具体的にはどうやって実装するか？

三分探索を行う。
関数の傾きが単調増加・減少するものについて極値が求まる？
幅が `2/3` ずつ徐々に縮まっていくイメージ。
（関数が微分できる場合は二分探索の問題に帰着させられる場合もある。）

。。正直よくわからず。解説PDFの方法がわかりやすいと思ったし、実装方法もほぼ説明されていたので、そちらでやってみた。

「N個の点が与えられる。それぞれの点を中心とし、半径が `r` の円にいずれにも含まれる点が存在するための **`r` の最小値** を求めよ。」
という問題と同値になる。
こう考えると、二分探索が適用できるようになる。

半径 `r` を決めたとき、ある2点を中心とした半径 `r` の2円の交点（2つ）は、最小包含円の中心候補となる。
（多分あってるはず。直感的には、選んだ2点を円の周上に持つ「ギリギリの円」を作ることになる。）
よって、ある決め打った `r` に対してこのような交点をすべて列挙し、
また、それらを1つずつ検査する、すなわち「中心を決めたときにすべての点が半径 `r` より内に存在するか」を判定すれば良い。
そのような中心が1つでも存在すれば `true` でありより小さな半径を調べる、そうでなければより大きな半径を調べる、とすればよい。

このとき必要となるツールは以下ぐらいの初歩的なもので、ABCレベルの幾何問題であれば常に取り出せるようにして置けると良い。

- ベクトルの加減算
- 単位ベクトルの計算
- 回転行列（ベクトルの回転）
- 中点座標の計算

※解説放送では三分探索の説明を詳しくしているので、いつか練習問題として解き直してみても良いかもしれない。

## [ABC166-F](https://atcoder.jp/contests/abc166/tasks/abc166_f) @2020-07-14

解説放送で思考の流れを学びたかった。

- 0を2箇所以上作らなければ絶対に詰まない。
- 全体にたくさん石があれば、実験とかかんたんにすればなんとなく詰まなそうというのがわかる。
- 「厳しい状況」というのを考えてみる。
- 全体の和を中心にして考えてみる。
  - （結局はここを真面目に考えるかどうかに集約される気がする。。）
- **「小さいケース（※今回の場合は、総和が小さいケース）」を考えてみる**

※実はDFSでも枝刈りが早い段階でできるらしく、一本道に毛が生えたような分岐しか起きないので、案外大丈夫、らしい。
いずれ実装してみたい。

※すぬけさんのクロージャを使う実装がとてもキレイ。

## [ARC032-C ★★★](https://atcoder.jp/contests/arc032/tasks/arc032_3) @2020-07-14

解説AC。

「こういうDPもあるのか」という感じで非常に勉強になる。
一方でもう少しシンプルに書きたい気もするが、あまりいいアイデアが浮かばない。

- `dp[i] := (時刻i以降で最大可能仕事数, 最大を達成する場合の次に取るべき仕事ID)`
  - つまり、ダイクストラで時々あるような、順序が定義できる構造体（タプル）を値とするDPテーブルを定義する。
- `dp[i] <= dp[i+1]` のような遷移になるため、後ろから埋めていく。
  - あまり慣れていないので、いい練習問題としてキープしておきたい。

## [ARC045-C ★★](https://atcoder.jp/contests/arc045/tasks/arc045_c) @2020-07-15

解説AC。これは解けないとだめだった。

LCAとかでよく考える「根からのコストのXOR」というのを考えておくと、2点間のそれらのXORが2点間のコストのXORに等しくなる。
なぜなら、LCAから根までの部分は二重にXORが取られることで打ち消されるから。

。。ここまではわかったが具体的な数え上げの方法がわからなかったが、実はzero sum rangesのアレで良かった。

すなわち、 `a ^ b == x` のとき `a` を固定すると `x ^ a` の個数がわかれば、 `a` とXORを取って `x` が出来上がるペアの個数がわかる。
よって、今まで見てきたもので個数を調べれば良い、ということになる。

**典型: zero sum rangesの数え上げは、左から配列をなめるだけでなくとも良い。木のDFSの順序上でも可能。**

※練習のため、 `C(n, 2)` で最後に数え上げをまとめる方法を取ってみたが、コーナーケースの処理が難しかった。
「もれなく、重複なく」の数え上げの原則を考えると、組み合わせを使うよりは逐次加算するほうが良い方法だと感じた。

## [ARC009-C](https://atcoder.jp/contests/arc009/tasks/arc009_3) @2020-07-15

自力。ABC172-Eを解いた後だと自力で考えられた。

[完全順列、撹乱順列](https://ja.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E9%A0%86%E5%88%97)というものの通り数が本番で、
これはモンモール数とか呼ばれるらしい。
ABC172-Eと同じく、包除原理の応用によって `O(k)` で求められる。

`N` が法外に大きいため、掛け算の前に単項に対してMODを取らないと駄目なケースがあり、1WAしてしまった。

## [ARC053-C ★](https://atcoder.jp/contests/arc053/tasks/arc053_c) @2020-07-16

ABC167-Fと酷似している。
自力。。でやりたかったが嘘解法に陥ってしまったため、解説ACした。

結果がマイナスになるものは最高点が小さいものから並べるのが最適、というのはすぐわかった。
後半もフィーリングで「最高点が大きいものから並べてしまったほうが良さそう」と考えてやってみたら、
サンプルが通ったので提出した。
が、半分くらいWAの明らかな嘘解法だった。

後半ついては「降下量が大きいものから並べるのが最適」となる。
ABC167-Fと同じく、反転して考えたら対称的な問題になるため、このように考えれば良い（けど、定性的に？一瞬では納得しづらい気がする。。）。

