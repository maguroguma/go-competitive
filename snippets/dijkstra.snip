snippet     dijkstraSquareOrderVer
abbr        func dijkstra() []int
options     head
  const (
    MAX   = 2500 + 5
    INFTY = 1 << 30
  )

  var n int           // ノード数
  var M [MAX][MAX]int // グラフ（隣接行列形式）

  // O(|V|^2)
  // 各ノードの最短路の長さを返す
  func dijkstra(sid int) []int {
    var minv int
    d, color := make([]int, MAX), make([]int, MAX)

    for i := 0; i < n; i++ {
      d[i] = INFTY
      color[i] = WHITE
    }

    d[sid] = 0
    color[sid] = GRAY
    for {
      minv = INFTY
      u := -1
      for i := 0; i < n; i++ {
        if minv > d[i] && color[i] != BLACK {
          u = i
          minv = d[i]
        }
      }
      if u == -1 {
        break
      }

      color[u] = BLACK

      for v := 0; v < n; v++ {
        if color[v] != BLACK && M[u][v] != INFTY {
          if d[v] > d[u]+M[u][v] {
            d[v] = d[u] + M[u][v]
            color[v] = GRAY
          }
        }
      }
    }

    return d
  }

snippet     dijkstraHowTo
abbr        how to implement dijkstra
options     head
  // 1. グラフ |G| を隣接リストで作る
  //   - エッジ構造体 |Edge| には遷移先のノードID |to| と重み |w| が定義されていれば良い。
  // 2. ノード構造体 |Vertex| とそのpriority queueを定義する
  //   - ノード構造体 |Vertex| にはノードID |id| と必要な **コスト** を定義する必要がある。
  //   - priority queueは、コストに関して昇順となるように適当に |Less| を定義する必要がある。
  //     - ここは問題によってまちまちなので注意！
  //     - とはいえ大抵は |int| だと思われる。
  // 3. ノードの個数分だけ配列でコスト、色、親それぞれ |dp, colors, parents| を定義し初期化する。
  //   - |dp| の型はノード構造体におけるコストの型と一致。
  //   - |dp| の初期値はいわゆる無限大に当たる値。
  //   - |colors| の初期値はすべて |WHITE| 。
  //   - |parents| に関しては
  //     - アルゴリズム上は初期値は不要だが、デバッグ等の都合を考えると |-1| などがよさそう。
  // 4. キューに始点のノードのみ追加する。
  //   - 追加するノードのコストは |0| とする。
  //   - 始点の状態を変更する |dp[s] = 0, colors[s] = GRAY, parents[s] = -1| 。
  //     - 始点の親は当然なし。
  // 5. 以下をキューが空になるまで繰り返す。
  //   1. キューからノード構造体を取り出す。
  //   2. 取り出したノードを |BLACK| に変更する。
  //     - 冪等性があるので特に条件分岐は考えなくてよい。
  //   3. ノードのコストが |dp[cid]| **より大きい** 場合は無視してループを |continue| する（手順1へ）
  //     - 計算量削減のため。
  //       - **等号を含めて「以上」としては行けないことには注意！等号を入れると一切更新がなされなくなってしまう。**
  //     - 5.2の更新前にBLACKかどうかを判定するのも良さそう。
  //   4. ノード構造体から伸びるすべてのエッジについて調べる。
  //   5. 移動先がすでに |BLACK| の場合は確定しているので |continue| して次のエッジを調べる。
  //     - 計算量削減のため。
  //   6. そうでない場合かつ、移動先のコスト |dp[nid]| が |dp[cid] + {{エッジのコスト}}| よりも大きい場合、小さい方で更新する。
  //   7. 更新したコストでキューに移動先のノード構造体を追加。
  //   8. 移動先の色を |GRAY| に変更し、親を更新する |colors[nid] = GRAY, parents[nid] = cid|
  //     - 色に関しては冪等性があるので特に条件分岐は考えなくて良い。

snippet     dijkstraBase
abbr        func dijkstra(sid, n int, AG [][]Edge) ([]int, []int)
options     head
  type (
    Edge struct {
      to   int
      cost int
    }
    Vertex struct {
      pri int
      id  int
    }
  )

  const INF_DIJK = 1 << 60

  func dijkstra(sid, n int, AG [][]Edge) (dp, parents []int) {
    dp = make([]int, n)
    parents = make([]int, n)
    colors := make([]int, n)
    for i := 0; i < n; i++ {
      dp[i] = INF_DIJK
      colors[i], parents[i] = WHITE, -1
    }

    temp := make(VertexPQ, 0, 100000+5)
    pq := &temp
    heap.Init(pq)
    heap.Push(pq, &Vertex{pri: 0, id: sid})
    dp[sid] = 0
    colors[sid] = GRAY

    for pq.Len() > 0 {
      pop := heap.Pop(pq).(*Vertex)

      colors[pop.id] = BLACK

      if pop.pri > dp[pop.id] {
        continue
      }

      for _, e := range AG[pop.id] {
        if colors[e.to] == BLACK {
          continue
        }

        if dp[e.to] > dp[pop.id]+e.cost {
          dp[e.to] = dp[pop.id] + e.cost
          heap.Push(pq, &Vertex{pri: dp[e.to], id: e.to})
          colors[e.to], parents[e.to] = GRAY, pop.id
        }
      }
    }

    return dp, parents
  }

  type VertexPQ []*Vertex

  func (pq VertexPQ) Len() int           { return len(pq) }
  func (pq VertexPQ) Less(i, j int) bool { return pq[i].pri < pq[j].pri } // <: ASC, >: DESC
  func (pq VertexPQ) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
  }
  func (pq *VertexPQ) Push(x interface{}) {
    item := x.(*Vertex)
    *pq = append(*pq, item)
  }
  func (pq *VertexPQ) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
  }

  // how to use
  // temp := make(VertexPQ, 0, 100000+1)
  // pq := &temp
  // heap.Init(pq)
  // heap.Push(pq, &Vertex{pri: intValue})
  // popped := heap.Pop(pq).(*Vertex)


snippet     dijkstraByBFS
abbr        func SSSPByBFS(sid, n int, AG [][]int) (dp []int, visited []bool)
options     head
  // verified by https://codeforces.com/contest/1320/problem/B
  func SSSPByBFS(sid, n int, AG [][]int) (dp []int, visited []bool) {
    dp = make([]int, n)
    visited = make([]bool, n)

    for i := 0; i < n; i++ {
      dp[i] = INF_BIT30
      visited[i] = false
    }

    Q := []Node{}
    dp[sid] = 0
    visited[sid] = true
    Q = append(Q, Node{id: sid, cost: dp[sid]})

    for len(Q) > 0 {
      cnode := Q[0]
      Q = Q[1:]

      for _, nid := range G[cnode.id] {
        // 訪問済みならパス
        if visited[nid] {
          continue
        }

        dp[nid] = cnode.cost + 1
        visited[nid] = true
        Q = append(Q, Node{id: nid, cost: dp[nid]})
      }
    }

    return dp, visited
  }

  type Node struct {
    id, cost int
  }

snippet     dijkstraGeneral
abbr        type V struct
options     head
  // verified by ABC143-E
  func Dijkstra(sid, n int, AG [][]Edge) []V {
    // データをすべて初期化
    dp, colors := InitAll(n)

    // 始点の設定（問題によっては複数始点もありうる）
    pq := InitStartPoint(sid, dp, colors)

    // アルゴリズム本体
    for pq.Len() > 0 {
      pop := pq.pop()
      colors[pop.id] = BLACK
      if Less(dp[pop.id], pop.v) {
        continue
      }

      // 次のノードへの遷移
      for _, e := range AG[pop.id] {
        if colors[e.to] == BLACK {
          continue
        }

        // 値の更新
        nv := GenNextV(pop, e, dp)

        if Less(nv, dp[e.to]) {
          dp[e.to] = nv
          pq.push(&Vertex{id: e.to, v: nv})
          colors[e.to] = GRAY
        }
      }
    }

    return dp
  }

  // DP value type
  type V struct {
    // {{
    gas, times int
    // }}
  }

  // InitAll returns initialized dp and colors slices.
  func InitAll(n int) (dp []V, colors []int) {
    dp, colors = make([]V, n), make([]int, n)
    for i := 0; i < n; i++ {
      dp[i] = DijkstraVInf()
      colors[i] = WHITE
    }

    return dp, colors
  }

  // DijkstraVInf returns a infinite value for DP.
  func DijkstraVInf() V {
    // {{
    return V{gas: -1, times: INF_BIT60}
    // }}
  }

  // InitStartPoint returns initialized priority queue, and update dp and colors slices.
  // *This function update arguments (side effects).*
  func InitStartPoint(sid int, dp []V, colors []int) *VertexPQ {
    pq := NewVertexPQ()

    // {{
    pq.push(&Vertex{id: sid, v: V{gas: l, times: 0}})
    dp[sid] = V{gas: l, times: 0}
    colors[sid] = GRAY
    // }}

    return pq
  }

  // Less returns whether l is strictly less than r.
  // This function is also used by priority queue.
  func Less(l, r V) bool {
    // {{
    if l.times < r.times {
      return true
    } else if l.times > r.times {
      return false
    } else {
      return l.gas > r.gas
    }
    // }}
  }

  // GenNextV returns next value considered by transition.
  func GenNextV(cv *Vertex, e Edge, dp []V) V {
    // {{
    if l < e.cost {
      return DijkstraVInf()
    }

    if dp[cv.id].gas >= e.cost {
      return V{gas: dp[cv.id].gas - e.cost, times: dp[cv.id].times}
    }

    return V{gas: l - e.cost, times: dp[cv.id].times + 1}
    // }}
  }

  type Edge struct {
    to   int
    cost int
  }

  type Vertex struct {
    id int
    v  V
  }
  type VertexPQ []*Vertex

  func NewVertexPQ() *VertexPQ {
    temp := make(VertexPQ, 0)
    pq := &temp
    heap.Init(pq)

    return pq
  }
  func (pq *VertexPQ) push(target *Vertex) {
    heap.Push(pq, target)
  }
  func (pq *VertexPQ) pop() *Vertex {
    return heap.Pop(pq).(*Vertex)
  }

  func (pq VertexPQ) Len() int { return len(pq) }
  func (pq VertexPQ) Less(i, j int) bool {
    return Less(pq[i].v, pq[j].v)
  }
  func (pq VertexPQ) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
  }
  func (pq *VertexPQ) Push(x interface{}) {
    item := x.(*Vertex)
    *pq = append(*pq, item)
  }
  func (pq *VertexPQ) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
  }
